# Core Directory Structure

# core/
# core\migrations/
# core\models/
# core\models\client/
# core\models\organization/
# core\models\other/
# core\models\output/
# core\models\phase/
# core\models\ppap/
# core\models\project/
# core\seeder/
# core\serializers/
# core\services/
# core\services\authorization/
# core\services\client/
# core\services\contact/
# core\services\department/
# core\services\document/
# core\services\history/
# core\services\logic/
# core\services\output/
# core\services\person/
# core\services\phase/
# core\services\ppap/
# core\services\ppap_element/
# core\services\project/
# core\services\team/
# core\services\template/
# core\services\timeline/
# core\services\todo/
# core\views/


# ======================================
# FILE CONTENTS
# ======================================

# core\migrations\0001_initial.py =================================================

core\migrations\0001_initial.py:
```python
# Generated by Django 4.2.7 on 2025-05-06 15:17

from django.conf import settings
from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('auth', '0012_alter_user_first_name_max_length'),
    ]

    operations = [
        migrations.CreateModel(
            name='User',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('username', models.CharField(max_length=150, unique=True)),
                ('password', models.CharField(max_length=128)),
                ('last_login', models.DateTimeField(blank=True, null=True)),
                ('is_active', models.BooleanField(default=True)),
                ('is_staff', models.BooleanField(default=False)),
                ('is_superuser', models.BooleanField(default=False)),
                ('history_id', models.CharField(max_length=100, unique=True)),
            ],
            options={
                'db_table': 'user',
                'ordering': ['username'],
            },
        ),
        migrations.CreateModel(
            name='Authorization',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('name', models.CharField(max_length=50)),
                ('history_id', models.CharField(max_length=100, unique=True)),
            ],
            options={
                'db_table': 'authorization',
                'ordering': ['name'],
            },
        ),
        migrations.CreateModel(
            name='Client',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('name', models.CharField(max_length=255)),
                ('address', models.TextField()),
                ('code', models.JSONField(default=dict)),
                ('description', models.TextField(blank=True, null=True)),
                ('contact_id', models.CharField(max_length=100, unique=True)),
                ('history_id', models.CharField(max_length=100, unique=True)),
            ],
            options={
                'db_table': 'client',
                'ordering': ['name'],
            },
        ),
        migrations.CreateModel(
            name='Contact',
            fields=[
                ('id', models.CharField(max_length=100, primary_key=True, serialize=False)),
                ('address', models.TextField()),
                ('email', models.EmailField(max_length=254)),
                ('phone', models.CharField(max_length=50)),
                ('type', models.CharField(max_length=50)),
                ('history_id', models.CharField(max_length=100, unique=True)),
            ],
            options={
                'db_table': 'contact',
                'ordering': ['id'],
            },
        ),
        migrations.CreateModel(
            name='Department',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('name', models.CharField(max_length=255)),
                ('history_id', models.CharField(max_length=100, unique=True)),
                ('responsible', models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='responsible_departments', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'db_table': 'department',
                'ordering': ['name'],
            },
        ),
        migrations.CreateModel(
            name='Document',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('name', models.CharField(max_length=255)),
                ('description', models.TextField(blank=True, null=True)),
                ('file_path', models.CharField(max_length=255)),
                ('file_type', models.CharField(max_length=50)),
                ('file_size', models.BigIntegerField()),
                ('version', models.CharField(max_length=50)),
                ('status', models.CharField(default='Draft', max_length=50)),
                ('history_id', models.CharField(max_length=100, unique=True)),
            ],
            options={
                'db_table': 'document',
                'ordering': ['-id'],
            },
        ),
        migrations.CreateModel(
            name='History',
            fields=[
                ('id', models.CharField(max_length=100, primary_key=True, serialize=False)),
                ('title', models.CharField(max_length=255)),
                ('event', models.TextField()),
                ('table_name', models.CharField(max_length=100)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('started_at', models.DateTimeField(blank=True, null=True)),
                ('updated_at', models.DateTimeField(blank=True, null=True)),
                ('deadline', models.DateTimeField(blank=True, null=True)),
                ('finished_at', models.DateTimeField(blank=True, null=True)),
            ],
            options={
                'db_table': 'history',
                'ordering': ['-created_at'],
            },
        ),
        migrations.CreateModel(
            name='Output',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('description', models.TextField(blank=True, null=True)),
                ('status', models.CharField(default='Not Started', max_length=50)),
                ('history_id', models.CharField(max_length=100, unique=True)),
                ('document', models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='outputs', to='core.document')),
            ],
            options={
                'db_table': 'output',
                'ordering': ['id'],
            },
        ),
        migrations.CreateModel(
            name='Permission',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('name', models.CharField(max_length=50)),
                ('description', models.TextField(blank=True, null=True)),
                ('history_id', models.CharField(max_length=100, unique=True)),
            ],
            options={
                'db_table': 'permission',
                'ordering': ['name'],
            },
        ),
        migrations.CreateModel(
            name='PhaseTemplate',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('name', models.CharField(max_length=255)),
                ('description', models.TextField(blank=True, null=True)),
                ('order', models.IntegerField()),
            ],
            options={
                'db_table': 'phase_template',
                'ordering': ['order'],
            },
        ),
        migrations.CreateModel(
            name='PPAP',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('level', models.IntegerField()),
                ('status', models.CharField(default='Not Started', max_length=50)),
                ('review', models.TextField(blank=True, null=True)),
                ('history_id', models.CharField(max_length=100, unique=True)),
            ],
            options={
                'db_table': 'ppap',
                'ordering': ['-id'],
            },
        ),
        migrations.CreateModel(
            name='PPAPElement',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('name', models.CharField(max_length=255)),
                ('level', models.CharField(max_length=50)),
            ],
            options={
                'db_table': 'ppap_element',
                'ordering': ['name'],
            },
        ),
        migrations.CreateModel(
            name='Team',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('name', models.CharField(max_length=255)),
                ('description', models.TextField(blank=True, null=True)),
                ('history_id', models.CharField(max_length=100, unique=True)),
            ],
            options={
                'db_table': 'team',
                'ordering': ['name'],
            },
        ),
        migrations.CreateModel(
            name='Todo',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('output', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='todos', to='core.output')),
                ('permission', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='todos', to='core.permission')),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='todos', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'db_table': 'todo',
                'ordering': ['-id'],
            },
        ),
        migrations.CreateModel(
            name='Project',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('name', models.CharField(max_length=255)),
                ('description', models.TextField(blank=True, null=True)),
                ('status', models.CharField(default='Planning', max_length=50)),
                ('history_id', models.CharField(max_length=100, unique=True)),
                ('client', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='projects', to='core.client')),
                ('ppap', models.OneToOneField(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='associated_project', to='core.ppap')),
                ('team', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='projects', to='core.team')),
            ],
            options={
                'db_table': 'project',
                'ordering': ['-id'],
            },
        ),
        migrations.AddField(
            model_name='ppap',
            name='project',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='ppaps', to='core.project'),
        ),
        migrations.CreateModel(
            name='Phase',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('status', models.CharField(default='Not Started', max_length=50)),
                ('history_id', models.CharField(max_length=100, unique=True)),
                ('ppap', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='phases', to='core.ppap')),
                ('responsible', models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='responsible_phases', to=settings.AUTH_USER_MODEL)),
                ('template', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='phases', to='core.phasetemplate')),
            ],
            options={
                'db_table': 'phase',
                'ordering': ['template__order'],
            },
        ),
        migrations.CreateModel(
            name='Person',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('first_name', models.CharField(max_length=255)),
                ('last_name', models.CharField(max_length=255)),
                ('contact_id', models.CharField(max_length=100, unique=True)),
                ('is_user', models.BooleanField(default=False)),
                ('history_id', models.CharField(max_length=100, unique=True)),
                ('department', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='persons', to='core.department')),
                ('teams', models.ManyToManyField(blank=True, related_name='members', to='core.team')),
            ],
            options={
                'db_table': 'person',
                'ordering': ['last_name', 'first_name'],
            },
        ),
        migrations.CreateModel(
            name='OutputTemplate',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('name', models.CharField(max_length=255)),
                ('configuration', models.JSONField(default=dict)),
                ('phase', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='output_templates', to='core.phasetemplate')),
                ('ppap_element', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='output_templates', to='core.ppapelement')),
            ],
            options={
                'db_table': 'output_template',
                'ordering': ['name'],
            },
        ),
        migrations.AddField(
            model_name='output',
            name='phase',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='outputs', to='core.phase'),
        ),
        migrations.AddField(
            model_name='output',
            name='template',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='outputs', to='core.outputtemplate'),
        ),
        migrations.AddField(
            model_name='output',
            name='user',
            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='assigned_outputs', to=settings.AUTH_USER_MODEL),
        ),
        migrations.CreateModel(
            name='FastQuery',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('index', models.JSONField(default=dict)),
                ('project', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, related_name='fastquery', to='core.project')),
            ],
            options={
                'db_table': 'fastquery',
            },
        ),
        migrations.AddField(
            model_name='document',
            name='output',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='documents', to='core.output'),
        ),
        migrations.AddField(
            model_name='document',
            name='uploader',
            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='uploaded_documents', to=settings.AUTH_USER_MODEL),
        ),
        migrations.AddField(
            model_name='client',
            name='team',
            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='clients', to='core.team'),
        ),
        migrations.AddField(
            model_name='user',
            name='authorization',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='users', to='core.authorization'),
        ),
        migrations.AddField(
            model_name='user',
            name='groups',
            field=models.ManyToManyField(blank=True, help_text='The groups this user belongs to. A user will get all permissions granted to each of their groups.', related_name='user_set', related_query_name='user', to='auth.group', verbose_name='groups'),
        ),
        migrations.AddField(
            model_name='user',
            name='person',
            field=models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, related_name='user', to='core.person'),
        ),
        migrations.AddField(
            model_name='user',
            name='user_permissions',
            field=models.ManyToManyField(blank=True, help_text='Specific permissions for this user.', related_name='user_set', related_query_name='user', to='auth.permission', verbose_name='user permissions'),
        ),
    ]

```

#----------------------------------------------------------------------------------------------------

# core\migrations\__init__.py =====================================================

core\migrations\__init__.py:
```python

```

#----------------------------------------------------------------------------------------------------

# core\models\__init__.py =========================================================

core\models\__init__.py:
```python
from core.models.history import History
from core.models.project.project import Project
from core.models.project.client import Client
from core.models.project.fastquery import FastQuery
from core.models.ppap.ppap import PPAP
from core.models.ppap.element import PPAPElement
from core.models.phase.phase import Phase
from core.models.phase.template import PhaseTemplate
from core.models.output.output import Output
from core.models.output.template import OutputTemplate
from core.models.output.document import Document
from core.models.organization.team import Team
from core.models.organization.department import Department
from core.models.organization.todo import Todo
from core.models.organization.user import User
from core.models.other.person import Person
from core.models.other.contact import Contact
from core.models.other.permission import Permission
from core.models.other.authorization import Authorization

```

#----------------------------------------------------------------------------------------------------

# core\models\client\client.py ====================================================

core\models\client\client.py:
```python
from django.db import models
import uuid
import json

class Client(models.Model):
    id = models.AutoField(primary_key=True)
    name = models.CharField(max_length=255)
    address = models.TextField()
    code = models.JSONField(default=dict)  # Stores code information as JSON
    description = models.TextField(blank=True, null=True)
    team = models.ForeignKey('Team', on_delete=models.SET_NULL, null=True, related_name='clients')
    contact_id = models.CharField(max_length=100, unique=True)
    history_id = models.CharField(max_length=100, unique=True)

    class Meta:
        db_table = 'client'
        ordering = ['name']

    def __str__(self):
        return self.name
    
def save(self, *args, **kwargs):
    # Prepare for a new record
    create_new = self.id is None
    
    # For new records, set a temporary unique values before first save
    if create_new:
        # Generate a temporary unique ID to avoid constraint violation
        import uuid
        temp_uuid = uuid.uuid4().hex
        
        # Set temporary unique values for constrained fields
        if not self.contact_id:
            self.contact_id = f"temp_{temp_uuid}"
        if not self.history_id:
            self.history_id = f"temp_{temp_uuid}"
        
        # First save to get an ID
        super().save(*args, **kwargs)
        
        # Now set the real IDs based on the client ID
        new_contact_id = f"{self.id}client"
        new_history_id = f"{self.id}client"
        
        # Use update to avoid another save() call
        Client.objects.filter(id=self.id).update(
            contact_id=new_contact_id,
            history_id=new_history_id
        )
        
        # Update the instance attributes to match the database
        self.contact_id = new_contact_id
        self.history_id = new_history_id
    else:
        # For existing records, save normally
        super().save(*args, **kwargs)
```

#----------------------------------------------------------------------------------------------------

# core\models\history.py ==========================================================

core\models\history.py:
```python
from django.db import models

class History(models.Model):
    id = models.CharField(max_length=100, primary_key=True)
    title = models.CharField(max_length=255)
    event = models.TextField()
    table_name = models.CharField(max_length=100)
    created_at = models.DateTimeField(auto_now_add=True)
    started_at = models.DateTimeField(null=True, blank=True)
    updated_at = models.DateTimeField(null=True, blank=True)
    deadline = models.DateTimeField(null=True, blank=True)
    finished_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        db_table = 'history'
        ordering = ['-created_at']

    def __str__(self):
        return f"{self.title} - {self.created_at}"

```

#----------------------------------------------------------------------------------------------------

# core\models\organization\department.py ==========================================

core\models\organization\department.py:
```python
from django.db import models
import uuid

class Department(models.Model):
    id = models.AutoField(primary_key=True)
    name = models.CharField(max_length=255)
    responsible = models.ForeignKey('User', on_delete=models.SET_NULL, null=True, related_name='responsible_departments')
    history_id = models.CharField(max_length=100, unique=True)

    class Meta:
        db_table = 'department'
        ordering = ['name']

    def __str__(self):
        return self.name

    def save(self, *args, **kwargs):
        # Prepare for a new record
        create_new = self.id is None
        
        # For new records, set a temporary unique value before first save
        if create_new:
            # Generate a temporary unique ID to avoid constraint violation
            import uuid
            temp_uuid = uuid.uuid4().hex
            
            # Set temporary unique values for constrained fields
            if not self.history_id:
                self.history_id = f"temp_{temp_uuid}"
            
            # First save to get an ID
            super().save(*args, **kwargs)
            
            # Now set the real ID based on the department ID
            new_history_id = f"{self.id}department"
            
            # Use update to avoid another save() call
            Department.objects.filter(id=self.id).update(
                history_id=new_history_id
            )
            
            # Update the instance attribute to match the database
            self.history_id = new_history_id
        else:
            # For existing records, save normally
            super().save(*args, **kwargs)

```

#----------------------------------------------------------------------------------------------------

# core\models\organization\team.py ================================================

core\models\organization\team.py:
```python
from django.db import models
import uuid

class Team(models.Model):
    id = models.AutoField(primary_key=True)
    name = models.CharField(max_length=255)
    description = models.TextField(blank=True, null=True)
    history_id = models.CharField(max_length=100, unique=True)
    # Remove the related_name='persons' since we're now using ManyToManyField in Person model

    class Meta:
        db_table = 'team'
        ordering = ['name']

    def __str__(self):
        return self.name

    def save(self, *args, **kwargs):
        # Prepare for a new record
        create_new = self.id is None
        
        # For new records, set a temporary unique value before first save
        if create_new:
            # Generate a temporary unique ID to avoid constraint violation
            import uuid
            temp_uuid = uuid.uuid4().hex
            
            # Set temporary unique values for constrained fields
            if not self.history_id:
                self.history_id = f"temp_{temp_uuid}"
            
            # First save to get an ID
            super().save(*args, **kwargs)
            
            # Now set the real ID based on the team ID
            new_history_id = f"{self.id}team"
            
            # Use update to avoid another save() call
            Team.objects.filter(id=self.id).update(
                history_id=new_history_id
            )
            
            # Update the instance attribute to match the database
            self.history_id = new_history_id
        else:
            # For existing records, save normally
            super().save(*args, **kwargs)

```

#----------------------------------------------------------------------------------------------------

# core\models\organization\todo.py ================================================

core\models\organization\todo.py:
```python
from django.db import models

class Todo(models.Model):
    id = models.AutoField(primary_key=True)
    permission = models.ForeignKey('Permission', on_delete=models.CASCADE, related_name='todos')
    user = models.ForeignKey('User', on_delete=models.CASCADE, related_name='todos')
    output = models.ForeignKey('Output', on_delete=models.CASCADE, related_name='todos')

    class Meta:
        db_table = 'todo'
        ordering = ['-id']

    def __str__(self):
        return f"Todo for {self.user} on {self.output}"
    
    def save(self, *args, **kwargs):
        # Prepare for a new record
        create_new = self.id is None
        
        # For new records, set a temporary unique value before first save
        if create_new:
            # Generate a temporary unique ID to avoid constraint violation
            import uuid
            temp_uuid = uuid.uuid4().hex
            
            # Set temporary unique values for constrained fields
            if not self.history_id:
                self.history_id = f"temp_{temp_uuid}"
            
            # First save to get an ID
            super().save(*args, **kwargs)
            
            # Now set the real ID based on the output ID
            new_history_id = f"{self.id}todo"
            
            # Use update to avoid another save() call
            Todo.objects.filter(id=self.id).update(
                history_id=new_history_id
            )
            
            # Update the instance attribute to match the database
            self.history_id = new_history_id
        else:
            # For existing records, save normally
            super().save(*args, **kwargs)

```

#----------------------------------------------------------------------------------------------------

# core\models\organization\user.py ================================================

core\models\organization\user.py:
```python
from django.db import models
import uuid
from django.contrib.auth.models import AbstractBaseUser, BaseUserManager, PermissionsMixin

class UserManager(BaseUserManager):
    def create_user(self, username, password=None, **extra_fields):
        if not username:
            raise ValueError('The Username field must be set')
        user = self.model(username=username, **extra_fields)
        user.set_password(password)
        user.save(using=self._db)
        return user

    def create_superuser(self, username, password=None, **extra_fields):
        extra_fields.setdefault('is_staff', True)
        extra_fields.setdefault('is_superuser', True)
        extra_fields.setdefault('is_active', True)

        if extra_fields.get('is_staff') is not True:
            raise ValueError('Superuser must have is_staff=True.')
        if extra_fields.get('is_superuser') is not True:
            raise ValueError('Superuser must have is_superuser=True.')

        return self.create_user(username, password, **extra_fields)

class User(AbstractBaseUser, PermissionsMixin):
    id = models.AutoField(primary_key=True)
    username = models.CharField(max_length=150, unique=True)
    password = models.CharField(max_length=128)
    person = models.OneToOneField('Person', on_delete=models.CASCADE, related_name='user')
    authorization = models.ForeignKey('Authorization', on_delete=models.CASCADE, related_name='users')
    last_login = models.DateTimeField(null=True, blank=True)
    is_active = models.BooleanField(default=True)
    is_staff = models.BooleanField(default=False)
    is_superuser = models.BooleanField(default=False)
    history_id = models.CharField(max_length=100, unique=True)

    objects = UserManager()

    USERNAME_FIELD = 'username'
    REQUIRED_FIELDS = []

    class Meta:
        db_table = 'user'
        ordering = ['username']

    def __str__(self):
        return self.username

    def save(self, *args, **kwargs):
        # Prepare for a new record
        create_new = self.id is None
        
        # For new records, set a temporary unique value before first save
        if create_new:
            # Generate a temporary unique ID to avoid constraint violation
            import uuid
            temp_uuid = uuid.uuid4().hex
            
            # Set temporary unique values for constrained fields
            if not self.history_id:
                self.history_id = f"temp_{temp_uuid}"
            
            # First save to get an ID
            super().save(*args, **kwargs)
            
            # Now set the real ID based on the output ID
            new_history_id = f"{self.id}user"
            
            # Use update to avoid another save() call
            User.objects.filter(id=self.id).update(
                history_id=new_history_id
            )
            
            # Update the instance attribute to match the database
            self.history_id = new_history_id
        else:
            # For existing records, save normally
            super().save(*args, **kwargs)

```

#----------------------------------------------------------------------------------------------------

# core\models\other\authorization.py ==============================================

core\models\other\authorization.py:
```python
from django.db import models
import uuid

class Authorization(models.Model):
    id = models.AutoField(primary_key=True)
    name = models.CharField(max_length=50)  # admin, create, edit
    history_id = models.CharField(max_length=100, unique=True)

    class Meta:
        db_table = 'authorization'
        ordering = ['name']

    def __str__(self):
        return self.name

    def save(self, *args, **kwargs):
        # Prepare for a new record
        create_new = self.id is None
        
        # For new records, set a temporary unique value before first save
        if create_new:
            # Generate a temporary unique ID to avoid constraint violation
            import uuid
            temp_uuid = uuid.uuid4().hex
            
            # Set temporary unique values for constrained fields
            if not self.history_id:
                self.history_id = f"temp_{temp_uuid}"
            
            # First save to get an ID
            super().save(*args, **kwargs)
            
            # Now set the real ID based on the output ID
            new_history_id = f"{self.id}authorization"
            
            # Use update to avoid another save() call
            Authorization.objects.filter(id=self.id).update(
                history_id=new_history_id
            )
            
            # Update the instance attribute to match the database
            self.history_id = new_history_id
        else:
            # For existing records, save normally
            super().save(*args, **kwargs)

```

#----------------------------------------------------------------------------------------------------

# core\models\other\contact.py ====================================================

core\models\other\contact.py:
```python
from django.db import models
import uuid  # Add this import at the top

class Contact(models.Model):
    id = models.CharField(max_length=100, primary_key=True)
    address = models.TextField()
    email = models.EmailField()
    phone = models.CharField(max_length=50)
    type = models.CharField(max_length=50)  # user, client, client_member
    history_id = models.CharField(max_length=100, unique=True)

    class Meta:
        db_table = 'contact'
        ordering = ['id']

    def __str__(self):
        return f"{self.type} Contact: {self.email}"
    
    # Add this save method to ensure history_id is always generated
    def save(self, *args, **kwargs):
        # Generate history_id if not provided
        if not self.history_id:
            self.history_id = f"{self.id}contact"
        
        # Ensure id exists
        if not self.id:
            self.id = f"{self.id}contact" 
            
        super().save(*args, **kwargs)

```

#----------------------------------------------------------------------------------------------------

# core\models\other\permission.py =================================================

core\models\other\permission.py:
```python
from django.db import models
import uuid

class Permission(models.Model):
    id = models.AutoField(primary_key=True)
    name = models.CharField(max_length=50)  # r (read only), e (edit and read)
    description = models.TextField(blank=True, null=True)
    history_id = models.CharField(max_length=100, unique=True)

    class Meta:
        db_table = 'permission'
        ordering = ['name']

    def __str__(self):
        return self.name

    def save(self, *args, **kwargs):
        # Prepare for a new record
        create_new = self.id is None
        
        # For new records, set a temporary unique value before first save
        if create_new:
            # Generate a temporary unique ID to avoid constraint violation
            import uuid
            temp_uuid = uuid.uuid4().hex
            
            # Set temporary unique values for constrained fields
            if not self.history_id:
                self.history_id = f"temp_{temp_uuid}"
            
            # First save to get an ID
            super().save(*args, **kwargs)
            
            # Now set the real ID based on the output ID
            new_history_id = f"{self.id}permission"
            
            # Use update to avoid another save() call
            Permission.objects.filter(id=self.id).update(
                history_id=new_history_id
            )
            
            # Update the instance attribute to match the database
            self.history_id = new_history_id
        else:
            # For existing records, save normally
            super().save(*args, **kwargs)

```

#----------------------------------------------------------------------------------------------------

# core\models\other\person.py =====================================================

core\models\other\person.py:
```python
from django.db import models
import uuid

class Person(models.Model):
    id = models.AutoField(primary_key=True)
    first_name = models.CharField(max_length=255)
    last_name = models.CharField(max_length=255)
    contact_id = models.CharField(max_length=100, unique=True)
    # Change from ForeignKey to ManyToManyField to allow a person to be in multiple teams
    teams = models.ManyToManyField('Team', related_name='members', blank=True)
    department = models.ForeignKey('Department', on_delete=models.SET_NULL, null=True, blank=True, related_name='persons')
    is_user = models.BooleanField(default=False)
    history_id = models.CharField(max_length=100, unique=True)

    class Meta:
        db_table = 'person'
        ordering = ['last_name', 'first_name']

    def __str__(self):
        return f"{self.first_name} {self.last_name}"

    def save(self, *args, **kwargs):
        # Prepare for a new record
        create_new = self.id is None
        
        # For new records, set a temporary unique values before first save
        if create_new:
            # Generate a temporary unique ID to avoid constraint violation
            import uuid
            temp_uuid = uuid.uuid4().hex
            
            # Set temporary unique values for constrained fields
            if not self.contact_id:
                self.contact_id = f"temp_{temp_uuid}"
            if not self.history_id:
                self.history_id = f"temp_{temp_uuid}"
            
            # First save to get an ID
            super().save(*args, **kwargs)
            
            # Now set the real IDs based on the person ID
            new_contact_id = f"{self.id}person"
            new_history_id = f"{self.id}person"
            
            # Use update to avoid another save() call
            Person.objects.filter(id=self.id).update(
                contact_id=new_contact_id,
                history_id=new_history_id
            )
            
            # Update the instance attributes to match the database
            self.contact_id = new_contact_id
            self.history_id = new_history_id
        else:
            # For existing records, save normally
            super().save(*args, **kwargs)

```

#----------------------------------------------------------------------------------------------------

# core\models\output\document.py ==================================================

core\models\output\document.py:
```python
from django.db import models
import uuid

class Document(models.Model):
    id = models.AutoField(primary_key=True)
    name = models.CharField(max_length=255)
    description = models.TextField(blank=True, null=True)
    file_path = models.CharField(max_length=255)
    file_type = models.CharField(max_length=50)
    file_size = models.BigIntegerField()
    uploader = models.ForeignKey('User', on_delete=models.SET_NULL, null=True, related_name='uploaded_documents')
    output = models.ForeignKey('Output', on_delete=models.CASCADE, related_name='documents')
    version = models.CharField(max_length=50)
    status = models.CharField(max_length=50, default='Draft')
    history_id = models.CharField(max_length=100, unique=True)

    class Meta:
        db_table = 'document'
        ordering = ['-id']

    def __str__(self):
        return self.name

    def save(self, *args, **kwargs):
        # Prepare for a new record
        create_new = self.id is None
        
        # For new records, set a temporary unique value before first save
        if create_new:
            # Generate a temporary unique ID to avoid constraint violation
            import uuid
            temp_uuid = uuid.uuid4().hex
            
            # Set temporary unique values for constrained fields
            if not self.history_id:
                self.history_id = f"temp_{temp_uuid}"
            
            # First save to get an ID
            super().save(*args, **kwargs)
            
            # Now set the real ID based on the output ID
            new_history_id = f"{self.id}document"
            
            # Use update to avoid another save() call
            Document.objects.filter(id=self.id).update(
                history_id=new_history_id
            )
            
            # Update the instance attribute to match the database
            self.history_id = new_history_id
        else:
            # For existing records, save normally
            super().save(*args, **kwargs)

```

#----------------------------------------------------------------------------------------------------

# core\models\output\output.py ====================================================

core\models\output\output.py:
```python
from django.db import models
import uuid

class Output(models.Model):
    id = models.AutoField(primary_key=True)
    template = models.ForeignKey('OutputTemplate', on_delete=models.CASCADE, related_name='outputs')
    description = models.TextField(blank=True, null=True)
    document = models.ForeignKey('Document', on_delete=models.SET_NULL, null=True, related_name='outputs')
    user = models.ForeignKey('User', on_delete=models.SET_NULL, null=True, related_name='assigned_outputs')
    phase = models.ForeignKey('Phase', on_delete=models.CASCADE, related_name='outputs')
    status = models.CharField(max_length=50, default='Not Started')
    history_id = models.CharField(max_length=100, unique=True)

    class Meta:
        db_table = 'output'
        ordering = ['id']
        
    def save(self, *args, **kwargs):
        # Prepare for a new record
        create_new = self.id is None
        
        # For new records, set a temporary unique value before first save
        if create_new:
            # Generate a temporary unique ID to avoid constraint violation
            import uuid
            temp_uuid = uuid.uuid4().hex
            
            # Set temporary unique values for constrained fields
            if not self.history_id:
                self.history_id = f"temp_{temp_uuid}"
            
            # First save to get an ID
            super().save(*args, **kwargs)
            
            # Now set the real ID based on the output ID
            new_history_id = f"{self.id}output"
            
            # Use update to avoid another save() call
            Output.objects.filter(id=self.id).update(
                history_id=new_history_id
            )
            
            # Update the instance attribute to match the database
            self.history_id = new_history_id
        else:
            # For existing records, save normally
            super().save(*args, **kwargs)

    def __str__(self):
        return f"{self.template.name} for Phase {self.phase_id}"

```

#----------------------------------------------------------------------------------------------------

# core\models\output\template.py ==================================================

core\models\output\template.py:
```python
from django.db import models
import json

class OutputTemplate(models.Model):
    id = models.AutoField(primary_key=True)
    name = models.CharField(max_length=255)
    configuration = models.JSONField(default=dict)  # Stores configuration as JSON
    phase = models.ForeignKey('PhaseTemplate', on_delete=models.CASCADE, related_name='output_templates')
    ppap_element = models.ForeignKey('PPAPElement', on_delete=models.CASCADE, related_name='output_templates')

    class Meta:
        db_table = 'output_template'
        ordering = ['name']

    def __str__(self):
        return self.name


```

#----------------------------------------------------------------------------------------------------

# core\models\phase\phase.py ======================================================

core\models\phase\phase.py:
```python
from django.db import models
import uuid

class Phase(models.Model):
    id = models.AutoField(primary_key=True)
    template = models.ForeignKey('PhaseTemplate', on_delete=models.CASCADE, related_name='phases')
    responsible = models.ForeignKey('User', on_delete=models.SET_NULL, null=True, related_name='responsible_phases')
    ppap = models.ForeignKey('PPAP', on_delete=models.CASCADE, related_name='phases')
    status = models.CharField(max_length=50, default='Not Started')
    history_id = models.CharField(max_length=100, unique=True)

    class Meta:
        db_table = 'phase'
        ordering = ['template__order']

    def __str__(self):
        return f"{self.template.name} for PPAP {self.ppap_id}"

    def save(self, *args, **kwargs):
        # Prepare for a new record
        create_new = self.id is None
        
        # For new records, set a temporary unique value before first save
        if create_new:
            # Generate a temporary unique ID to avoid constraint violation
            import uuid
            temp_uuid = uuid.uuid4().hex
            
            # Set temporary unique values for constrained fields
            if not self.history_id:
                self.history_id = f"temp_{temp_uuid}"
            
            # First save to get an ID
            super().save(*args, **kwargs)
            
            # Now set the real ID based on the phase ID
            new_history_id = f"{self.id}phase"
            
            # Use update to avoid another save() call
            Phase.objects.filter(id=self.id).update(
                history_id=new_history_id
            )
            
            # Update the instance attribute to match the database
            self.history_id = new_history_id
        else:
            # For existing records, save normally
            super().save(*args, **kwargs)

```

#----------------------------------------------------------------------------------------------------

# core\models\phase\template.py ===================================================

core\models\phase\template.py:
```python
from django.db import models

class PhaseTemplate(models.Model):
    id = models.AutoField(primary_key=True)
    name = models.CharField(max_length=255)
    description = models.TextField(blank=True, null=True)
    order = models.IntegerField()

    class Meta:
        db_table = 'phase_template'
        ordering = ['order']

    def __str__(self):
        return self.name
    
```

#----------------------------------------------------------------------------------------------------

# core\models\ppap\element.py =====================================================

core\models\ppap\element.py:
```python
from django.db import models

class PPAPElement(models.Model):
    id = models.AutoField(primary_key=True)
    name = models.CharField(max_length=255)
    level = models.CharField(max_length=50)  # Stores level information (e.g., "1,4,custom")

    class Meta:
        db_table = 'ppap_element'
        ordering = ['name']

    def __str__(self):
        return self.name

```

#----------------------------------------------------------------------------------------------------

# core\models\ppap\ppap.py ========================================================

core\models\ppap\ppap.py:
```python
from django.db import models
import uuid

class PPAP(models.Model):
    id = models.AutoField(primary_key=True)
    project = models.ForeignKey('Project', on_delete=models.CASCADE, related_name='ppaps')
    level = models.IntegerField()
    status = models.CharField(max_length=50, default='Not Started')
    review = models.TextField(blank=True, null=True)
    history_id = models.CharField(max_length=100, unique=True)

    class Meta:
        db_table = 'ppap'
        ordering = ['-id']

    def __str__(self):
        return f"PPAP for Project {self.project} (Level {self.level})"

    def save(self, *args, **kwargs):
        # Prepare for a new record
        create_new = self.id is None
        
        # For new records, set a temporary unique values before first save
        if create_new:
            # Generate a temporary unique ID to avoid constraint violation
            import uuid
            temp_uuid = uuid.uuid4().hex
            
            # Set temporary unique values for constrained fields

            if not self.history_id:
                self.history_id = f"temp_{temp_uuid}"
            
            # First save to get an ID
            super().save(*args, **kwargs)
            
            # Now set the real IDs based on the ppap ID
            new_history_id = f"{self.id}ppap"
            
            # Use update to avoid another save() call
            PPAP.objects.filter(id=self.id).update(
                history_id=new_history_id
            )
            
            # Update the instance attributes to match the database
            self.history_id = new_history_id
        else:
            # For existing records, save normally
            super().save(*args, **kwargs)

```

#----------------------------------------------------------------------------------------------------

# core\models\project\client.py ===================================================

core\models\project\client.py:
```python
from django.db import models
import uuid
import json

class Client(models.Model):
    id = models.AutoField(primary_key=True)
    name = models.CharField(max_length=255)
    address = models.TextField()
    code = models.JSONField(default=dict)  # Stores code information as JSON
    description = models.TextField(blank=True, null=True)
    team = models.ForeignKey('Team', on_delete=models.SET_NULL, null=True, related_name='clients')
    contact_id = models.CharField(max_length=100, unique=True)
    history_id = models.CharField(max_length=100, unique=True)

    class Meta:
        db_table = 'client'
        ordering = ['name']

    def __str__(self):
        return self.name

    def save(self, *args, **kwargs):
        create_new = self.id is None
        
        # Generate IDs before first save for new objects
        if create_new:
            # Save once to get an ID
            super().save(*args, **kwargs)
            
            # Set the IDs
            self.contact_id = f"{self.id}client"
            self.history_id = f"{self.id}history"
            
            # Update only the specific fields
            kwargs['update_fields'] = ['contact_id', 'history_id'] if kwargs.get('update_fields') else None
            super().save(*args, **kwargs)
        else:
            # Normal save for updates
            super().save(*args, **kwargs)
        
        # Ensure code is JSON
        if isinstance(self.code, str):
            try:
                self.code = json.loads(self.code)
            except json.JSONDecodeError:
                self.code = {"value": self.code}

```

#----------------------------------------------------------------------------------------------------

# core\models\project\fastquery.py ================================================

core\models\project\fastquery.py:
```python
from django.db import models
import json

class FastQuery(models.Model):
    id = models.AutoField(primary_key=True)
    project = models.OneToOneField('Project', on_delete=models.CASCADE, related_name='fastquery')
    index = models.JSONField(default=dict)  # Stores index information as JSON

    class Meta:
        db_table = 'fastquery'

    def __str__(self):
        return f"FastQuery for Project {self.project_id}"

    def save(self, *args, **kwargs):
        # Ensure index is JSON
        if isinstance(self.index, str):
            try:
                self.index = json.loads(self.index)
            except json.JSONDecodeError:
                self.index = {"error": "Invalid JSON"}
        
        super().save(*args, **kwargs)

```

#----------------------------------------------------------------------------------------------------

# core\models\project\project.py ==================================================

core\models\project\project.py:
```python
from django.db import models
import uuid

class Project(models.Model):
    id = models.AutoField(primary_key=True)
    name = models.CharField(max_length=255)
    description = models.TextField(blank=True, null=True)
    client = models.ForeignKey('Client', on_delete=models.CASCADE, related_name='projects')
    team = models.ForeignKey('Team', on_delete=models.CASCADE, related_name='projects')
    status = models.CharField(max_length=50, default='Planning')
    ppap = models.OneToOneField('PPAP', on_delete=models.SET_NULL, null=True, blank=True, related_name='associated_project')
    history_id = models.CharField(max_length=100, unique=True)

    class Meta:
        db_table = 'project'
        ordering = ['-id']

    def __str__(self):
        return self.name

    def save(self, *args, **kwargs):
        # Prepare for a new record
        create_new = self.id is None
        
        # For new records, set a temporary unique value before first save
        if create_new:
            # Generate a temporary unique ID to avoid constraint violation
            import uuid
            temp_uuid = uuid.uuid4().hex
            
            # Set temporary unique values for constrained fields
            if not self.history_id:
                self.history_id = f"temp_{temp_uuid}"
            
            # First save to get an ID
            super().save(*args, **kwargs)
            
            # Now set the real ID based on the project ID
            new_history_id = f"{self.id}project"
            
            # Use update to avoid another save() call
            Project.objects.filter(id=self.id).update(
                history_id=new_history_id
            )
            
            # Update the instance attribute to match the database
            self.history_id = new_history_id
        else:
            # For existing records, save normally
            super().save(*args, **kwargs)

```

#----------------------------------------------------------------------------------------------------

# core\seeder\__init__.py =========================================================

core\seeder\__init__.py:
```python
# Seeder package initialization
"""
This package contains seeders for all database tables.
Each seeder is in a separate file and can be run independently or in sequence.
"""

```

#----------------------------------------------------------------------------------------------------

# core\seeder\authorization_seeder.py =============================================

core\seeder\authorization_seeder.py:
```python
"""
Seeder for Authorization model
"""
import os
import django
import uuid

# Set up Django environment
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'apqp_manager.settings')
django.setup()

from django.db import transaction
from core.models import Authorization

@transaction.atomic
def seed_authorizations():
    """Seed authorization data"""
    print("Seeding authorizations...")
    
    # Clear existing data
    Authorization.objects.all().delete()
    
    # Create authorizations
    authorizations = [
        {
            'name': 'admin',
            'history_id': f"{uuid.uuid4().hex}authorization"
        },
        {
            'name': 'create',
            'history_id': f"{uuid.uuid4().hex}authorization"
        },
        {
            'name': 'edit',
            'history_id': f"{uuid.uuid4().hex}authorization"
        }
    ]
    
    # Insert authorizations
    for auth_data in authorizations:
        Authorization.objects.create(**auth_data)
    
    print(f"Created {len(authorizations)} authorizations")
    return Authorization.objects.all()

if __name__ == "__main__":
    seed_authorizations()

```

#----------------------------------------------------------------------------------------------------

# core\seeder\client_seeder.py ====================================================

core\seeder\client_seeder.py:
```python
"""
Seeder for Client model
"""
import os
import django
import uuid
from faker import Faker

# Set up Django environment
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'apqp_manager.settings')
django.setup()

from django.db import transaction
from core.models import Client, Team, Contact

fake = Faker()

@transaction.atomic
def seed_clients():
    """Seed client data"""
    print("Seeding clients...")
    
    # Clear existing data
    Client.objects.all().delete()
    
    # Get client team
    try:
        client_team = Team.objects.get(name='Client Team')
    except Team.DoesNotExist:
        client_team = Team.objects.first()
    
    # Create clients
    clients = []
    
    for i in range(5):
        # Generate a unique contact_id for each client
        contact_id = f"{uuid.uuid4().hex}client"
        history_id = f"{uuid.uuid4().hex}client"
        
        client_data = {
            'name': fake.company(),
            'address': fake.address(),
            'code': {
                'DUNS': fake.numerify('#########'),
                'Fiscal': f"FC-{fake.numerify('######')}"
            },
            'description': fake.catch_phrase(),
            'team': client_team,
            'contact_id': contact_id,
            'history_id': history_id
        }
        
        # Create client
        client = Client.objects.create(**client_data)
        
        # Create contact for client
        Contact.objects.create(
            id=contact_id,
            address=client.address,
            email=fake.company_email(),
            phone=fake.phone_number(),
            type='client',
            history_id=f"{uuid.uuid4().hex}contact"
        )
        
        clients.append(client)
    
    print(f"Created {len(clients)} clients with contacts")
    return clients

if __name__ == "__main__":
    seed_clients()

```

#----------------------------------------------------------------------------------------------------

# core\seeder\contact_seeder.py ===================================================

core\seeder\contact_seeder.py:
```python
"""
Seeder for Contact model
"""
import os
import django
import uuid
from faker import Faker

# Set up Django environment
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'apqp_manager.settings')
django.setup()

from django.db import transaction
from core.models import Contact, Person

fake = Faker()

@transaction.atomic
def seed_contacts():
    """Seed contact data"""
    print("Seeding contacts...")
    
    # Clear existing data
    Contact.objects.all().delete()
    
    # Get persons
    persons = Person.objects.all()
    
    if not persons:
        print("Error: Persons must be seeded first")
        return
    
    # Create contacts for each person
    contacts = []
    for person in persons:
        contact_data = {
            'id': person.contact_id,  # Use the contact_id from the person
            'address': fake.address(),
            'email': fake.email(),
            'phone': fake.phone_number(),
            'type': 'user' if person.is_user else 'client_member',
            'history_id': f"{uuid.uuid4().hex}contact"
        }
        contacts.append(contact_data)
    
    # Insert contacts
    created_contacts = []
    for contact_data in contacts:
        created_contacts.append(Contact.objects.create(**contact_data))
    
    print(f"Created {len(created_contacts)} contacts")
    return created_contacts

if __name__ == "__main__":
    seed_contacts()

```

#----------------------------------------------------------------------------------------------------

# core\seeder\department_seeder.py ================================================

core\seeder\department_seeder.py:
```python
"""
Seeder for Department model
"""
import os
import django
import uuid

# Set up Django environment
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'apqp_manager.settings')
django.setup()

from django.db import transaction
from core.models import Department

@transaction.atomic
def seed_departments():
    """Seed department data"""
    print("Seeding departments...")
    
    # Clear existing data
    Department.objects.all().delete()
    
    # Create departments
    departments = [
        {
            'name': 'Engineering',
            'history_id': f"{uuid.uuid4().hex}department"
        },
        {
            'name': 'Quality',
            'history_id': f"{uuid.uuid4().hex}department"
        },
        {
            'name': 'Production',
            'history_id': f"{uuid.uuid4().hex}department"
        },
        {
            'name': 'Management',
            'history_id': f"{uuid.uuid4().hex}department"
        },
        {
            'name': 'Sales',
            'history_id': f"{uuid.uuid4().hex}department"
        }
    ]
    
    # Insert departments
    for dept_data in departments:
        Department.objects.create(**dept_data)
    
    print(f"Created {len(departments)} departments")
    return Department.objects.all()

if __name__ == "__main__":
    seed_departments()

```

#----------------------------------------------------------------------------------------------------

# core\seeder\document_seeder.py ==================================================

core\seeder\document_seeder.py:
```python
"""
Seeder for Document model
"""
import os
import django
import uuid
from faker import Faker

# Set up Django environment
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'apqp_manager.settings')
django.setup()

from django.db import transaction
from core.models import Document, Output, User

fake = Faker()

@transaction.atomic
def seed_documents():
    """Seed document data"""
    print("Seeding documents...")
    
    # Clear existing data
    Document.objects.all().delete()
    
    # Get outputs and users
    outputs = Output.objects.filter(status__in=['In Progress', 'Completed'])
    users = User.objects.all()
    
    if not outputs or not users:
        print("Error: Outputs and Users must be seeded first")
        return
    
    # Create documents for each output
    documents = []
    
    for output in outputs:
        # Create 1-3 documents per output
        num_documents = fake.random_int(min=1, max=3)
        
        for i in range(num_documents):
            history_id = f"{uuid.uuid4().hex}document"
            
            # Determine document status based on output status
            if output.status == 'Completed':
                doc_status = fake.random_element(['Approved', 'Draft'])
            else:
                doc_status = 'Draft'
            
            # Generate random file details
            file_types = ['pdf', 'docx', 'xlsx', 'pptx', 'jpg']
            file_type = fake.random_element(file_types)
            file_name = f"{fake.word()}_{fake.random_int(min=1000, max=9999)}.{file_type}"
            file_path = f"documents/{file_name}"
            file_size = fake.random_int(min=10000, max=5000000)  # 10KB to 5MB
            
            # Assign a random uploader
            uploader = fake.random_element(users)
            
            document_data = {
                'name': f"{output.template.name} - {fake.word().capitalize()}",
                'description': fake.paragraph(),
                'file_path': file_path,
                'file_type': file_type,
                'file_size': file_size,
                'uploader': uploader,
                'output': output,
                'version': f"{fake.random_int(min=1, max=5)}.{fake.random_int(min=0, max=9)}",
                'status': doc_status,
                'history_id': history_id
            }
            
            documents.append(Document.objects.create(**document_data))
    
    print(f"Created {len(documents)} documents")
    return documents

if __name__ == "__main__":
    seed_documents()

```

#----------------------------------------------------------------------------------------------------

# core\seeder\fastquery_seeder.py =================================================

core\seeder\fastquery_seeder.py:
```python
"""
Seeder for FastQuery model
"""
import os
import django

# Set up Django environment
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'apqp_manager.settings')
django.setup()

from django.db import transaction
from core.models import FastQuery, Project, PPAP, Phase, Output

@transaction.atomic
def seed_fastqueries():
    """Seed fastquery data"""
    print("Seeding fastqueries...")
    
    # Clear existing data
    FastQuery.objects.all().delete()
    
    # Get projects
    projects = Project.objects.all()
    
    if not projects:
        print("Error: Projects must be seeded first")
        return
    
    # Create fastqueries for each project
    fastqueries = []
    
    for project in projects:
        # Get PPAP, phases, and outputs for this project
        ppap = project.ppap
        
        if not ppap:
            continue
        
        phases = Phase.objects.filter(ppap=ppap)
        
        # Collect all related IDs
        phase_ids = list(phases.values_list('id', flat=True))
        
        output_ids = []
        for phase in phases:
            outputs = Output.objects.filter(phase=phase)
            output_ids.extend(list(outputs.values_list('id', flat=True)))
        
        # Create index
        index = {
            'project_id': project.id,
            'ppap_id': ppap.id,
            'phase_ids': phase_ids,
            'output_ids': output_ids
        }
        
        # Create fastquery
        fastquery = FastQuery.objects.create(
            project=project,
            index=index
        )
        
        fastqueries.append(fastquery)
    
    print(f"Created {len(fastqueries)} fastqueries")
    return fastqueries

if __name__ == "__main__":
    seed_fastqueries()

```

#----------------------------------------------------------------------------------------------------

# core\seeder\history_seeder.py ===================================================

core\seeder\history_seeder.py:
```python
"""
Seeder for History model
"""
import os
import django
from faker import Faker
from datetime import datetime, timedelta

# Set up Django environment
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'apqp_manager.settings')
django.setup()

from django.db import transaction
from core.models import History, Project, PPAP, Phase, Output, Document, User, Client, Team, Person, Contact, Department

fake = Faker()

@transaction.atomic
def seed_histories():
    """Seed history data"""
    print("Seeding histories...")
    
    # Clear existing data
    History.objects.all().delete()
    
    # Get all entities with history_id
    projects = Project.objects.all()
    ppaps = PPAP.objects.all()
    phases = Phase.objects.all()
    outputs = Output.objects.all()
    documents = Document.objects.all()
    users = User.objects.all()
    clients = Client.objects.all()
    teams = Team.objects.all()
    persons = Person.objects.all()
    contacts = Contact.objects.all()
    departments = Department.objects.all()
    
    # Create histories
    histories = []
    
    # Project histories
    for project in projects:
        # Creation event
        created_at = fake.date_time_between(start_date='-1y', end_date='-6m')
        
        history_data = {
            'id': project.history_id,
            'title': project.name,
            'event': f"Project created with ID {project.id}",
            'table_name': 'project',
            'created_at': created_at,
            'started_at': created_at if project.status != 'Planning' else None,
            'updated_at': fake.date_time_between(start_date=created_at, end_date='now') if project.status != 'Planning' else None,
            'deadline': fake.date_time_between(start_date='+1m', end_date='+6m'),
            'finished_at': fake.date_time_between(start_date='-3m', end_date='-1m') if project.status in ['Completed', 'Archived'] else None
        }
        
        histories.append(History.objects.create(**history_data))
    
    # PPAP histories
    for ppap in ppaps:
        # Creation event
        project_history = History.objects.get(id=ppap.project.history_id)
        created_at = project_history.created_at
        
        history_data = {
            'id': ppap.history_id,
            'title': f"PPAP for Project {ppap.project_id}",
            'event': f"PPAP created with level {ppap.level}",
            'table_name': 'ppap',
            'created_at': created_at,
            'started_at': created_at if ppap.status != 'Not Started' else None,
            'updated_at': fake.date_time_between(start_date=created_at, end_date='now') if ppap.status != 'Not Started' else None,
            'deadline': project_history.deadline,
            'finished_at': fake.date_time_between(start_date='-3m', end_date='-1m') if ppap.status in ['Completed', 'Approved'] else None
        }
        
        histories.append(History.objects.create(**history_data))
    
    # Phase histories
    for phase in phases:
        # Creation event
        ppap_history = History.objects.get(id=phase.ppap.history_id)
        created_at = ppap_history.created_at
        
        # Calculate phase deadline based on template order
        total_phases = Phase.objects.filter(ppap=phase.ppap).count()
        phase_duration = (ppap_history.deadline - created_at) / total_phases
        phase_deadline = created_at + (phase_duration * phase.template.order)
        
        history_data = {
            'id': phase.history_id,
            'title': f"{phase.template.name} for PPAP {phase.ppap_id}",
            'event': f"Phase created based on template {phase.template.id}",
            'table_name': 'phase',
            'created_at': created_at,
            'started_at': created_at if phase.status != 'Not Started' else None,
            'updated_at': fake.date_time_between(start_date=created_at, end_date='now') if phase.status != 'Not Started' else None,
            'deadline': phase_deadline,
            'finished_at': fake.date_time_between(start_date='-3m', end_date='-1m') if phase.status == 'Completed' else None
        }
        
        histories.append(History.objects.create(**history_data))
    
    # Output histories
    for output in outputs:
        # Creation event
        phase_history = History.objects.get(id=output.phase.history_id)
        created_at = phase_history.created_at
        
        # Calculate output deadline
        total_outputs = Output.objects.filter(phase=output.phase).count()
        output_duration = (phase_history.deadline - created_at) / total_outputs
        output_deadline = created_at + output_duration
        
        history_data = {
            'id': output.history_id,
            'title': f"{output.template.name} for Phase {output.phase_id}",
            'event': f"Output created based on template {output.template.id}",
            'table_name': 'output',
            'created_at': created_at,
            'started_at': created_at if output.status != 'Not Started' else None,
            'updated_at': fake.date_time_between(start_date=created_at, end_date='now') if output.status != 'Not Started' else None,
            'deadline': output_deadline,
            'finished_at': fake.date_time_between(start_date='-3m', end_date='-1m') if output.status == 'Completed' else None
        }
        
        histories.append(History.objects.create(**history_data))
    
    # Document histories
    for document in documents:
        # Creation event
        output_history = History.objects.get(id=document.output.history_id)
        created_at = fake.date_time_between(start_date=output_history.created_at, end_date='now')
        
        history_data = {
            'id': document.history_id,
            'title': document.name,
            'event': f"Document uploaded for Output {document.output_id}",
            'table_name': 'document',
            'created_at': created_at,
            'updated_at': fake.date_time_between(start_date=created_at, end_date='now') if document.status != 'Draft' else None,
            'deadline': output_history.deadline,
            'finished_at': fake.date_time_between(start_date=created_at, end_date='now') if document.status == 'Approved' else None
        }
        
        histories.append(History.objects.create(**history_data))
    
    # Other entity histories (simplified)
    for entity, table_name in [
        (users, 'user'),
        (clients, 'client'),
        (teams, 'team'),
        (persons, 'person'),
        (contacts, 'contact'),
        (departments, 'department')
    ]:
        for item in entity:
            created_at = fake.date_time_between(start_date='-1y', end_date='-6m')
            
            history_data = {
                'id': item.history_id,
                'title': str(item),
                'event': f"{table_name.capitalize()} created",
                'table_name': table_name,
                'created_at': created_at,
                'updated_at': fake.date_time_between(start_date=created_at, end_date='now') if fake.boolean(chance_of_getting_true=30) else None
            }
            
            histories.append(History.objects.create(**history_data))
    
    print(f"Created {len(histories)} history records")
    return histories

if __name__ == "__main__":
    seed_histories()

```

#----------------------------------------------------------------------------------------------------

# core\seeder\output_seeder.py ====================================================

core\seeder\output_seeder.py:
```python
"""
Seeder for Output model
"""
import os
import django
import uuid
from faker import Faker

# Set up Django environment
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'apqp_manager.settings')
django.setup()

from django.db import transaction
from core.models import Output, Phase, OutputTemplate, User

fake = Faker()

@transaction.atomic
def seed_outputs():
    """Seed output data"""
    print("Seeding outputs...")
    
    # Clear existing data
    Output.objects.all().delete()
    
    # Get phases, output templates, and users
    phases = Phase.objects.all()
    users = User.objects.all()
    
    if not phases or not users:
        print("Error: Phases and Users must be seeded first")
        return
    
    # Create outputs for each phase
    outputs = []
    
    for phase in phases:
        # Get output templates for this phase's template
        output_templates = OutputTemplate.objects.filter(phase=phase.template)
        
        # Map phase status to output statuses
        phase_status = phase.status
        
        for template in output_templates:
            history_id = f"{uuid.uuid4().hex}output"
            
            # Determine output status based on phase status
            if phase_status == 'Not Started':
                output_status = 'Not Started'
            elif phase_status == 'On Hold':
                output_status = 'On Hold'
            elif phase_status == 'Completed':
                output_status = 'Completed'
            else:  # In Progress
                output_status = fake.random_element(['Not Started', 'In Progress', 'Completed'])
            
            # Assign a random user
            user = fake.random_element(users)
            
            output_data = {
                'template': template,
                'description': fake.paragraph(),
                'user': user,
                'phase': phase,
                'status': output_status,
                'history_id': history_id
            }
            
            outputs.append(Output.objects.create(**output_data))
    
    print(f"Created {len(outputs)} outputs")
    return outputs

if __name__ == "__main__":
    seed_outputs()

```

#----------------------------------------------------------------------------------------------------

# core\seeder\output_template_seeder.py ===========================================

core\seeder\output_template_seeder.py:
```python
"""
Seeder for OutputTemplate model
"""
import os
import django
from faker import Faker

# Set up Django environment
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'apqp_manager.settings')
django.setup()

from django.db import transaction
from core.models import OutputTemplate, PhaseTemplate, PPAPElement

fake = Faker()

@transaction.atomic
def seed_output_templates():
    """Seed output template data"""
    print("Seeding output templates...")
    
    # Clear existing data
    OutputTemplate.objects.all().delete()
    
    # Get phase templates and PPAP elements
    phase_templates = PhaseTemplate.objects.all()
    ppap_elements = PPAPElement.objects.all()
    
    if not phase_templates or not ppap_elements:
        print("Error: Phase templates and PPAP elements must be seeded first")
        return
    
    # Create output templates for each phase
    output_templates = []
    
    # Phase 1: Prepare for APQP
    phase1 = PhaseTemplate.objects.get(name='Prepare for APQP')
    output_templates.extend([
        {
            'name': 'Team Organization',
            'configuration': {},
            'phase': phase1,
            'ppap_element': PPAPElement.objects.get(name='Customer-Specific Requirements')
        },
        {
            'name': 'Project Scope Definition',
            'configuration': {},
            'phase': phase1,
            'ppap_element': PPAPElement.objects.get(name='Customer-Specific Requirements')
        },
        {
            'name': 'Team Communication Plan',
            'configuration': {},
            'phase': phase1,
            'ppap_element': PPAPElement.objects.get(name='Customer-Specific Requirements')
        },
        {
            'name': 'Core Tools Training',
            'configuration': {},
            'phase': phase1,
            'ppap_element': PPAPElement.objects.get(name='Customer-Specific Requirements')
        }
    ])
    
    # Phase 2: Plan and Define Program
    phase2 = PhaseTemplate.objects.get(name='Plan and Define Program')
    output_templates.extend([
        {
            'name': 'Voice of Customer',
            'configuration': {},
            'phase': phase2,
            'ppap_element': PPAPElement.objects.get(name='Customer-Specific Requirements')
        },
        {
            'name': 'Business Plan',
            'configuration': {},
            'phase': phase2,
            'ppap_element': PPAPElement.objects.get(name='Customer-Specific Requirements')
        },
        {
            'name': 'Product/Process Benchmark',
            'configuration': {},
            'phase': phase2,
            'ppap_element': PPAPElement.objects.get(name='Customer-Specific Requirements')
        },
        {
            'name': 'Reliability Studies',
            'configuration': {},
            'phase': phase2,
            'ppap_element': PPAPElement.objects.get(name='Design FMEA')
        }
    ])
    
    # Phase 3: Product Design and Development
    phase3 = PhaseTemplate.objects.get(name='Product Design and Development')
    output_templates.extend([
        {
            'name': 'Design Goals',
            'configuration': {},
            'phase': phase3,
            'ppap_element': PPAPElement.objects.get(name='Design Records')
        },
        {
            'name': 'Preliminary Bill of Material',
            'configuration': {},
            'phase': phase3,
            'ppap_element': PPAPElement.objects.get(name='Design Records')
        },
        {
            'name': 'Design FMEA',
            'configuration': {},
            'phase': phase3,
            'ppap_element': PPAPElement.objects.get(name='Design FMEA')
        },
        {
            'name': 'Design Verification Plan',
            'configuration': {},
            'phase': phase3,
            'ppap_element': PPAPElement.objects.get(name='Design Records')
        }
    ])
    
    # Phase 4: Process Design and Development
    phase4 = PhaseTemplate.objects.get(name='Process Design and Development')
    output_templates.extend([
        {
            'name': 'Packaging Standards',
            'configuration': {},
            'phase': phase4,
            'ppap_element': PPAPElement.objects.get(name='Process Flow Diagrams')
        },
        {
            'name': 'Process Flow Chart',
            'configuration': {},
            'phase': phase4,
            'ppap_element': PPAPElement.objects.get(name='Process Flow Diagrams')
        },
        {
            'name': 'Floor Plan Layout',
            'configuration': {},
            'phase': phase4,
            'ppap_element': PPAPElement.objects.get(name='Process Flow Diagrams')
        },
        {
            'name': 'Process FMEA',
            'configuration': {},
            'phase': phase4,
            'ppap_element': PPAPElement.objects.get(name='Process FMEA')
        },
        {
            'name': 'Control Plan',
            'configuration': {},
            'phase': phase4,
            'ppap_element': PPAPElement.objects.get(name='Control Plan')
        }
    ])
    
    # Phase 5: Product and Process Validation
    phase5 = PhaseTemplate.objects.get(name='Product and Process Validation')
    output_templates.extend([
        {
            'name': 'Production Trial Run',
            'configuration': {},
            'phase': phase5,
            'ppap_element': PPAPElement.objects.get(name='Sample Production Parts')
        },
        {
            'name': 'Measurement Systems Evaluation',
            'configuration': {},
            'phase': phase5,
            'ppap_element': PPAPElement.objects.get(name='Measurement System Analysis Studies')
        },
        {
            'name': 'Process Capability Study',
            'configuration': {},
            'phase': phase5,
            'ppap_element': PPAPElement.objects.get(name='Initial Process Studies')
        },
        {
            'name': 'Production Part Approval',
            'configuration': {},
            'phase': phase5,
            'ppap_element': PPAPElement.objects.get(name='Part Submission Warrant')
        },
        {
            'name': 'Production Validation Testing',
            'configuration': {},
            'phase': phase5,
            'ppap_element': PPAPElement.objects.get(name='Material, Performance Test Results')
        }
    ])
    
    # Phase 6: Feedback, Assessment and Corrective Action
    phase6 = PhaseTemplate.objects.get(name='Feedback, Assessment and Corrective Action')
    output_templates.extend([
        {
            'name': 'Variation Reduction',
            'configuration': {},
            'phase': phase6,
            'ppap_element': PPAPElement.objects.get(name='Initial Process Studies')
        },
        {
            'name': 'Customer Satisfaction Survey',
            'configuration': {},
            'phase': phase6,
            'ppap_element': PPAPElement.objects.get(name='Customer-Specific Requirements')
        },
        {
            'name': 'Delivery Performance',
            'configuration': {},
            'phase': phase6,
            'ppap_element': PPAPElement.objects.get(name='Customer-Specific Requirements')
        },
        {
            'name': 'Corrective Action Plan',
            'configuration': {},
            'phase': phase6,
            'ppap_element': PPAPElement.objects.get(name='Customer-Specific Requirements')
        }
    ])
    
    # Insert output templates
    created_templates = []
    for template_data in output_templates:
        created_templates.append(OutputTemplate.objects.create(**template_data))
    
    print(f"Created {len(created_templates)} output templates")
    return created_templates

if __name__ == "__main__":
    seed_output_templates()

```

#----------------------------------------------------------------------------------------------------

# core\seeder\permission_seeder.py ================================================

core\seeder\permission_seeder.py:
```python
"""
Seeder for Permission model
"""
import os
import django
import uuid

# Set up Django environment
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'apqp_manager.settings')
django.setup()

from django.db import transaction
from core.models import Permission

@transaction.atomic
def seed_permissions():
    """Seed permission data"""
    print("Seeding permissions...")
    
    # Clear existing data
    Permission.objects.all().delete()
    
    # Create permissions
    permissions = [
        {
            'name': 'r',
            'description': 'Read only',
            'history_id': f"{uuid.uuid4().hex}permission"
        },
        {
            'name': 'e',
            'description': 'Edit and read',
            'history_id': f"{uuid.uuid4().hex}permission"
        }
    ]
    
    # Insert permissions
    for perm_data in permissions:
        Permission.objects.create(**perm_data)
    
    print(f"Created {len(permissions)} permissions")
    return Permission.objects.all()

if __name__ == "__main__":
    seed_permissions()

```

#----------------------------------------------------------------------------------------------------

# core\seeder\person_seeder.py ====================================================

core\seeder\person_seeder.py:
```python
"""
Seeder for Person model
"""
import os
import django
import uuid
from faker import Faker

# Set up Django environment
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'apqp_manager.settings')
django.setup()

from django.db import transaction
from core.models import Person, Team, Department, Contact
from core.services.contact.initialization import initialize_person_contact

fake = Faker()

@transaction.atomic
def seed_persons():
    """Seed person data"""
    print("Seeding persons...")
    
    # Clear existing data
    Person.objects.all().delete()
    
    # Get teams and departments
    teams = list(Team.objects.all())
    departments = list(Department.objects.all())
    
    if not teams or not departments:
        print("Error: Teams and Departments must be seeded first")
        return
    
    # Create persons
    persons = []
    
    # Create 20 persons
    for i in range(20):
        # Generate unique IDs for each person
        history_id = f"{uuid.uuid4().hex}person"
        contact_id = f"{uuid.uuid4().hex}person"
        
        # Create person without teams first
        person = Person.objects.create(
            first_name=fake.first_name(),
            last_name=fake.last_name(),
            contact_id=contact_id,
            department=fake.random_element(departments),
            is_user=fake.boolean(chance_of_getting_true=70),
            history_id=history_id
        )
        
        # Assign 1-3 random teams to each person
        num_teams = fake.random_int(min=1, max=3)
        random_teams = fake.random_elements(elements=teams, length=num_teams, unique=True)
        person.teams.set(random_teams)
        
        # Create contact for person
        initialize_person_contact(
            person=person,
            address=fake.address(),
            email=fake.email(),
            phone=fake.phone_number()
        )
        
        persons.append(person)
    
    # Add specific persons for admin, engineer, and quality roles
    admin_person = Person.objects.create(
        first_name='Admin',
        last_name='User',
        contact_id=f"{uuid.uuid4().hex}person",
        department=Department.objects.get(name='Management'),
        is_user=True,
        history_id=f"{uuid.uuid4().hex}person"
    )
    admin_person.teams.add(Team.objects.get(name='Management Team'))
    initialize_person_contact(
        person=admin_person,
        address=fake.address(),
        email='admin@example.com',
        phone=fake.phone_number()
    )
    
    engineer_person = Person.objects.create(
        first_name='John',
        last_name='Engineer',
        contact_id=f"{uuid.uuid4().hex}person",
        department=Department.objects.get(name='Engineering'),
        is_user=True,
        history_id=f"{uuid.uuid4().hex}person"
    )
    engineer_person.teams.add(Team.objects.get(name='Engineering Team'))
    initialize_person_contact(
        person=engineer_person,
        address=fake.address(),
        email='engineer@example.com',
        phone=fake.phone_number()
    )
    
    quality_person = Person.objects.create(
        first_name='Jane',
        last_name='Quality',
        contact_id=f"{uuid.uuid4().hex}person",
        department=Department.objects.get(name='Quality'),
        is_user=True,
        history_id=f"{uuid.uuid4().hex}person"
    )
    quality_person.teams.add(Team.objects.get(name='Quality Team'))
    initialize_person_contact(
        person=quality_person,
        address=fake.address(),
        email='quality@example.com',
        phone=fake.phone_number()
    )
    
    print(f"Created {len(persons) + 3} persons")
    return persons

```

#----------------------------------------------------------------------------------------------------

# core\seeder\phase_seeder.py =====================================================

core\seeder\phase_seeder.py:
```python
"""
Seeder for Phase model
"""
import os
import django
import uuid
from faker import Faker

# Set up Django environment
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'apqp_manager.settings')
django.setup()

from django.db import transaction
from core.models import Phase, PPAP, PhaseTemplate, User

fake = Faker()

@transaction.atomic
def seed_phases():
    """Seed phase data"""
    print("Seeding phases...")
    
    # Clear existing data
    Phase.objects.all().delete()
    
    # Get PPAPs, phase templates, and users
    ppaps = PPAP.objects.all()
    phase_templates = PhaseTemplate.objects.all().order_by('order')
    users = User.objects.all()
    
    if not ppaps or not phase_templates or not users:
        print("Error: PPAPs, Phase Templates, and Users must be seeded first")
        return
    
    # Create phases for each PPAP
    phases = []
    
    for ppap in ppaps:
        # Map PPAP status to phase statuses
        ppap_status = ppap.status
        
        for template in phase_templates:
            history_id = f"{uuid.uuid4().hex}phase"
            
            # Determine phase status based on PPAP status and template order
            if ppap_status == 'Not Started':
                phase_status = 'Not Started'
            elif ppap_status == 'On Hold':
                phase_status = 'On Hold'
            elif ppap_status in ['Completed', 'Approved']:
                phase_status = 'Completed'
            else:  # In Progress
                # Earlier phases are more likely to be completed
                if template.order < 3:
                    phase_status = fake.random_element(['Completed', 'In Progress'])
                elif template.order < 5:
                    phase_status = fake.random_element(['In Progress', 'Not Started'])
                else:
                    phase_status = 'Not Started'
            
            # Assign a random responsible user
            responsible = fake.random_element(users)
            
            phase_data = {
                'template': template,
                'responsible': responsible,
                'ppap': ppap,
                'status': phase_status,
                'history_id': history_id
            }
            
            phases.append(Phase.objects.create(**phase_data))
    
    print(f"Created {len(phases)} phases")
    return phases

if __name__ == "__main__":
    seed_phases()

```

#----------------------------------------------------------------------------------------------------

# core\seeder\phase_template_seeder.py ============================================

core\seeder\phase_template_seeder.py:
```python
"""
Seeder for PhaseTemplate model
"""
import os
import django

# Set up Django environment
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'apqp_manager.settings')
django.setup()

from django.db import transaction
from core.models import PhaseTemplate

@transaction.atomic
def seed_phase_templates():
    """Seed phase template data"""
    print("Seeding phase templates...")
    
    # Clear existing data
    PhaseTemplate.objects.all().delete()
    
    # Create phase templates based on APQP phases
    phase_templates = [
        {
            'name': 'Prepare for APQP',
            'description': 'Initial preparation phase for APQP',
            'order': 1
        },
        {
            'name': 'Plan and Define Program',
            'description': 'Planning and program definition phase',
            'order': 2
        },
        {
            'name': 'Product Design and Development',
            'description': 'Design and development of the product',
            'order': 3
        },
        {
            'name': 'Process Design and Development',
            'description': 'Design and development of the manufacturing process',
            'order': 4
        },
        {
            'name': 'Product and Process Validation',
            'description': 'Validation of product and process',
            'order': 5
        },
        {
            'name': 'Feedback, Assessment and Corrective Action',
            'description': 'Feedback, assessment and corrective action phase',
            'order': 6
        }
    ]
    
    # Insert phase templates
    created_templates = []
    for template_data in phase_templates:
        created_templates.append(PhaseTemplate.objects.create(**template_data))
    
    print(f"Created {len(created_templates)} phase templates")
    return created_templates

if __name__ == "__main__":
    seed_phase_templates()

```

#----------------------------------------------------------------------------------------------------

# core\seeder\ppap_element_seeder.py ==============================================

core\seeder\ppap_element_seeder.py:
```python
"""
Seeder for PPAPElement model
"""
import os
import django

# Set up Django environment
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'apqp_manager.settings')
django.setup()

from django.db import transaction
from core.models import PPAPElement

@transaction.atomic
def seed_ppap_elements():
    """Seed PPAP element data"""
    print("Seeding PPAP elements...")
    
    # Clear existing data
    PPAPElement.objects.all().delete()
    
    # Create PPAP elements
    ppap_elements = [
        {
            'name': 'Design Records',
            'level': '1,2,3,4,5'
        },
        {
            'name': 'Engineering Change Documents',
            'level': '1,2,3,4,5'
        },
        {
            'name': 'Customer Engineering Approval',
            'level': '1,2,3,4,5'
        },
        {
            'name': 'Design FMEA',
            'level': '2,3,4,5'
        },
        {
            'name': 'Process Flow Diagrams',
            'level': '2,3,4,5'
        },
        {
            'name': 'Process FMEA',
            'level': '2,3,4,5'
        },
        {
            'name': 'Control Plan',
            'level': '2,3,4,5'
        },
        {
            'name': 'Measurement System Analysis Studies',
            'level': '3,4,5'
        },
        {
            'name': 'Dimensional Results',
            'level': '3,4,5'
        },
        {
            'name': 'Material, Performance Test Results',
            'level': '3,4,5'
        },
        {
            'name': 'Initial Process Studies',
            'level': '3,4,5'
        },
        {
            'name': 'Qualified Laboratory Documentation',
            'level': '4,5'
        },
        {
            'name': 'Appearance Approval Report',
            'level': '4,5'
        },
        {
            'name': 'Sample Production Parts',
            'level': '4,5'
        },
        {
            'name': 'Master Sample',
            'level': '4,5'
        },
        {
            'name': 'Checking Aids',
            'level': '5'
        },
        {
            'name': 'Customer-Specific Requirements',
            'level': '5'
        },
        {
            'name': 'Part Submission Warrant',
            'level': '1,2,3,4,5'
        },
        {
            'name': 'Custom PPAP Element',
            'level': 'custom'
        }
    ]
    
    # Insert PPAP elements
    created_elements = []
    for element_data in ppap_elements:
        created_elements.append(PPAPElement.objects.create(**element_data))
    
    print(f"Created {len(created_elements)} PPAP elements")
    return created_elements

if __name__ == "__main__":
    seed_ppap_elements()

```

#----------------------------------------------------------------------------------------------------

# core\seeder\ppap_seeder.py ======================================================

core\seeder\ppap_seeder.py:
```python
"""
Seeder for PPAP model
"""
import os
import django
import uuid
from faker import Faker

# Set up Django environment
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'apqp_manager.settings')
django.setup()

from django.db import transaction
from core.models import PPAP, Project

fake = Faker()

@transaction.atomic
def seed_ppaps():
    """Seed PPAP data"""
    print("Seeding PPAPs...")
    
    # Clear existing data
    PPAP.objects.all().delete()
    
    # Get projects
    projects = Project.objects.all()
    
    if not projects:
        print("Error: Projects must be seeded first")
        return
    
    # Create PPAPs for each project
    ppaps = []
    
    for project in projects:
        # Map project status to PPAP status
        status_map = {
            'Planning': 'Not Started',
            'In Progress': 'In Progress',
            'On Hold': 'On Hold',
            'Completed': 'Completed',
            'Archived': 'Approved'
        }
        
        ppap_status = status_map.get(project.status, 'Not Started')
        
        # Generate a random PPAP level (1-5)
        ppap_level = fake.random_int(min=1, max=5)
        
        history_id = f"{uuid.uuid4().hex}ppap"
        
        ppap_data = {
            'project': project,
            'level': ppap_level,
            'status': ppap_status,
            'review': fake.paragraph() if ppap_status in ['Completed', 'Approved'] else None,
            'history_id': history_id
        }
        
        ppap = PPAP.objects.create(**ppap_data)
        
        # Update project with PPAP reference
        project.ppap = ppap
        project.save()
        
        ppaps.append(ppap)
    
    print(f"Created {len(ppaps)} PPAPs")
    return ppaps

if __name__ == "__main__":
    seed_ppaps()

```

#----------------------------------------------------------------------------------------------------

# core\seeder\project_seeder.py ===================================================

core\seeder\project_seeder.py:
```python
"""
Seeder for Project model
"""
import os
import django
import uuid
from faker import Faker

# Set up Django environment
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'apqp_manager.settings')
django.setup()

from django.db import transaction
from core.models import Project, Client, Team

fake = Faker()

@transaction.atomic
def seed_projects():
    """Seed project data"""
    print("Seeding projects...")
    
    # Clear existing data
    Project.objects.all().delete()
    
    # Get clients and teams
    clients = Client.objects.all()
    teams = Team.objects.exclude(name='Client Team')
    
    if not clients or not teams:
        print("Error: Clients and Teams must be seeded first")
        return
    
    # Create projects
    projects = []
    
    # Create 5 projects with different statuses
    statuses = ['Planning', 'In Progress', 'On Hold', 'Completed', 'Archived']
    
    for i, status in enumerate(statuses):
        history_id = f"{uuid.uuid4().hex}project"
        
        project_data = {
            'name': fake.catch_phrase(),
            'description': fake.paragraph(),
            'client': fake.random_element(clients),
            'team': fake.random_element(teams),
            'status': status,
            'history_id': history_id
        }
        
        projects.append(project_data)
    
    # Insert projects
    created_projects = []
    for project_data in projects:
        created_projects.append(Project.objects.create(**project_data))
    
    print(f"Created {len(created_projects)} projects")
    return created_projects

if __name__ == "__main__":
    seed_projects()

```

#----------------------------------------------------------------------------------------------------

# core\seeder\run_all.py ==========================================================

core\seeder\run_all.py:
```python
#!/usr/bin/env python
"""
Run all seeders in the correct order to populate the database
"""
import os
import django
import sys
import importlib
from django.db import transaction

# Set up Django environment
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'apqp_manager.settings')
django.setup()

# Import all seeders
from seeder.authorization_seeder import seed_authorizations
from seeder.permission_seeder import seed_permissions
from seeder.department_seeder import seed_departments
from seeder.team_seeder import seed_teams
from seeder.person_seeder import seed_persons
from seeder.contact_seeder import seed_contacts
from seeder.user_seeder import seed_users
from seeder.client_seeder import seed_clients
from seeder.phase_template_seeder import seed_phase_templates
from seeder.ppap_element_seeder import seed_ppap_elements
from seeder.output_template_seeder import seed_output_templates
from seeder.project_seeder import seed_projects
from seeder.ppap_seeder import seed_ppaps
from seeder.phase_seeder import seed_phases
from seeder.output_seeder import seed_outputs
from seeder.document_seeder import seed_documents
from seeder.todo_seeder import seed_todos
from seeder.history_seeder import seed_histories
from seeder.fastquery_seeder import seed_fastqueries

@transaction.atomic
def run_all_seeders():
    """Run all seeders in the correct order"""
    print("Starting database seeding...")
    
    # First, seed the basic models
    seed_authorizations()
    seed_permissions()
    seed_departments()
    seed_teams()
    
    # Then seed people and contacts
    seed_persons()
    seed_contacts()
    seed_users()
    seed_clients()
    
    # Seed templates
    seed_phase_templates()
    seed_ppap_elements()
    seed_output_templates()
    
    # Seed project hierarchy
    seed_projects()
    seed_ppaps()
    seed_phases()
    seed_outputs()
    seed_documents()
    
    # Seed relationships and metadata
    seed_todos()
    seed_histories()
    seed_fastqueries()
    
    print("Database seeding completed successfully!")

if __name__ == "__main__":
    run_all_seeders()

```

#----------------------------------------------------------------------------------------------------

# core\seeder\team_seeder.py ======================================================

core\seeder\team_seeder.py:
```python
"""
Seeder for Team model
"""
import os
import django
import uuid

# Set up Django environment
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'apqp_manager.settings')
django.setup()

from django.db import transaction
from core.models import Team

@transaction.atomic
def seed_teams():
    """Seed team data"""
    print("Seeding teams...")
    
    # Clear existing data
    Team.objects.all().delete()
    
    # Create teams
    teams = [
        {
            'name': 'Engineering Team',
            'description': 'Team responsible for engineering tasks',
            'history_id': f"{uuid.uuid4().hex}team"
        },
        {
            'name': 'Quality Team',
            'description': 'Team responsible for quality assurance',
            'history_id': f"{uuid.uuid4().hex}team"
        },
        {
            'name': 'Project Team',
            'description': 'Cross-functional project team',
            'history_id': f"{uuid.uuid4().hex}team"
        },
        {
            'name': 'Management Team',
            'description': 'Team responsible for management decisions',
            'history_id': f"{uuid.uuid4().hex}team"
        },
        {
            'name': 'Client Team',
            'description': 'Team for client representatives',
            'history_id': f"{uuid.uuid4().hex}team"
        }
    ]
    
    # Insert teams
    for team_data in teams:
        Team.objects.create(**team_data)
    
    print(f"Created {len(teams)} teams")
    return Team.objects.all()

if __name__ == "__main__":
    seed_teams()

```

#----------------------------------------------------------------------------------------------------

# core\seeder\todo_seeder.py ======================================================

core\seeder\todo_seeder.py:
```python
"""
Seeder for Todo model
"""
import os
import django
from faker import Faker

# Set up Django environment
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'apqp_manager.settings')
django.setup()

from django.db import transaction
from core.models import Todo, User, Output, Permission

fake = Faker()

@transaction.atomic
def seed_todos():
    """Seed todo data"""
    print("Seeding todos...")
    
    # Clear existing data
    Todo.objects.all().delete()
    
    # Get users, outputs, and permissions
    users = User.objects.all()
    outputs = Output.objects.filter(status__in=['Not Started', 'In Progress'])
    read_permission = Permission.objects.get(name='r')
    edit_permission = Permission.objects.get(name='e')
    
    if not users or not outputs or not read_permission or not edit_permission:
        print("Error: Users, Outputs, and Permissions must be seeded first")
        return
    
    # Create todos
    todos = []
    
    # Assign todos to output owners (edit permission)
    for output in outputs:
        if output.user:
            todo_data = {
                'permission': edit_permission,
                'user': output.user,
                'output': output
            }
            todos.append(Todo.objects.create(**todo_data))
    
    # Assign additional todos to random users (read permission)
    for i in range(30):
        user = fake.random_element(users)
        output = fake.random_element(outputs)
        
        # Skip if user already has a todo for this output
        if Todo.objects.filter(user=user, output=output).exists():
            continue
        
        todo_data = {
            'permission': read_permission,
            'user': user,
            'output': output
        }
        todos.append(Todo.objects.create(**todo_data))
    
    print(f"Created {len(todos)} todos")
    return todos

if __name__ == "__main__":
    seed_todos()

```

#----------------------------------------------------------------------------------------------------

# core\seeder\user_seeder.py ======================================================

core\seeder\user_seeder.py:
```python
"""
Seeder for User model
"""
import os
import django
import uuid
from faker import Faker

# Set up Django environment
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'apqp_manager.settings')
django.setup()

from django.db import transaction
from core.models import User, Person, Authorization

fake = Faker()

@transaction.atomic
def seed_users():
    """Seed user data"""
    print("Seeding users...")
    
    # Clear existing data
    User.objects.all().delete()
    
    # Get persons who are users and authorizations
    persons = Person.objects.filter(is_user=True)
    authorizations = Authorization.objects.all()
    
    if not persons or not authorizations:
        print("Error: Persons and Authorizations must be seeded first")
        return
    
    admin_auth = Authorization.objects.get(name='admin')
    create_auth = Authorization.objects.get(name='create')
    edit_auth = Authorization.objects.get(name='edit')
    
    # Create users
    users = []
    
    # Create admin user
    admin_person = Person.objects.get(first_name='Admin', last_name='User')
    admin_user = {
        'username': 'admin',
        'password': 'admin123',
        'person': admin_person,
        'authorization': admin_auth,
        'is_staff': True,
        'is_superuser': True,
        'history_id': f"{uuid.uuid4().hex}user"
    }
    users.append(admin_user)
    
    # Create engineer user
    engineer_person = Person.objects.get(first_name='John', last_name='Engineer')
    engineer_user = {
        'username': 'john',
        'password': 'john123',
        'person': engineer_person,
        'authorization': edit_auth,
        'history_id': f"{uuid.uuid4().hex}user"
    }
    users.append(engineer_user)
    
    # Create quality user
    quality_person = Person.objects.get(first_name='Jane', last_name='Quality')
    quality_user = {
        'username': 'jane',
        'password': 'jane123',
        'person': quality_person,
        'authorization': edit_auth,
        'history_id': f"{uuid.uuid4().hex}user"
    }
    users.append(quality_user)
    
    # Create additional users for other persons
    other_persons = persons.exclude(id__in=[admin_person.id, engineer_person.id, quality_person.id])
    
    for person in other_persons:
        username = f"{person.first_name.lower()}.{person.last_name.lower()}"
        password = f"{person.first_name.lower()}123"
        
        # Randomly assign authorization
        auth = fake.random_element([create_auth, edit_auth])
        
        user_data = {
            'username': username,
            'password': password,
            'person': person,
            'authorization': auth,
            'history_id': f"{uuid.uuid4().hex}user"
        }
        users.append(user_data)
    
    # Insert users
    created_users = []
    for user_data in users:
        password = user_data.pop('password')
        user = User.objects.create_user(**user_data)
        user.set_password(password)
        user.save()
        created_users.append(user)
    
    print(f"Created {len(created_users)} users")
    return created_users

if __name__ == "__main__":
    seed_users()

```

#----------------------------------------------------------------------------------------------------

# core\serializers.py =============================================================

core\serializers.py:
```python
from rest_framework import serializers
from core.models import (
    Project, PPAP, Phase, Output, Document, User, Client, Team,
    Person, Contact, Department, History, FastQuery, PhaseTemplate,
    OutputTemplate, PPAPElement, Todo, Permission, Authorization
)

class ContactSerializer(serializers.ModelSerializer):
    class Meta:
        model = Contact
        fields = '__all__'

class PersonSerializer(serializers.ModelSerializer):
    class Meta:
        model = Person
        fields = '__all__'

class AuthorizationSerializer(serializers.ModelSerializer):
    class Meta:
        model = Authorization
        fields = '__all__'

class UserSerializer(serializers.ModelSerializer):
    person_details = PersonSerializer(source='person', read_only=True)
    
    class Meta:
        model = User
        fields = ['id', 'username', 'person', 'person_details', 'authorization', 'last_login', 'is_active', 'history_id']
        extra_kwargs = {'password': {'write_only': True}}
    
    def create(self, validated_data):
        user = User.objects.create_user(**validated_data)
        return user

class TeamSerializer(serializers.ModelSerializer):
    members = PersonSerializer(many=True, read_only=True)
    
    class Meta:
        model = Team
        fields = '__all__'

class DepartmentSerializer(serializers.ModelSerializer):
    members = PersonSerializer(many=True, read_only=True)
    
    class Meta:
        model = Department
        fields = '__all__'

class ClientSerializer(serializers.ModelSerializer):
    contact = ContactSerializer(read_only=True)
    
    class Meta:
        model = Client
        fields = '__all__'

class PPAPElementSerializer(serializers.ModelSerializer):
    class Meta:
        model = PPAPElement
        fields = '__all__'

class OutputTemplateSerializer(serializers.ModelSerializer):
    ppap_element_details = PPAPElementSerializer(source='ppap_element', read_only=True)
    
    class Meta:
        model = OutputTemplate
        fields = '__all__'

class PhaseTemplateSerializer(serializers.ModelSerializer):
    output_templates = OutputTemplateSerializer(many=True, read_only=True)
    
    class Meta:
        model = PhaseTemplate
        fields = '__all__'

class DocumentSerializer(serializers.ModelSerializer):
    uploader_details = UserSerializer(source='uploader', read_only=True)
    
    class Meta:
        model = Document
        fields = '__all__'

class OutputSerializer(serializers.ModelSerializer):
    template_details = OutputTemplateSerializer(source='template', read_only=True)
    documents = DocumentSerializer(many=True, read_only=True)
    user_details = UserSerializer(source='user', read_only=True)
    
    class Meta:
        model = Output
        fields = '__all__'

class PhaseSerializer(serializers.ModelSerializer):
    template_details = PhaseTemplateSerializer(source='template', read_only=True)
    outputs = OutputSerializer(many=True, read_only=True)
    responsible_details = UserSerializer(source='responsible', read_only=True)
    
    class Meta:
        model = Phase
        fields = '__all__'

class PPAPSerializer(serializers.ModelSerializer):
    phases = PhaseSerializer(many=True, read_only=True)
    
    class Meta:
        model = PPAP
        fields = '__all__'

class FastQuerySerializer(serializers.ModelSerializer):
    class Meta:
        model = FastQuery
        fields = '__all__'

class ProjectSerializer(serializers.ModelSerializer):
    client_details = ClientSerializer(source='client', read_only=True)
    team_details = TeamSerializer(source='team', read_only=True)
    ppap_details = PPAPSerializer(source='ppap', read_only=True)
    
    class Meta:
        model = Project
        fields = '__all__'

class HistorySerializer(serializers.ModelSerializer):
    class Meta:
        model = History
        fields = '__all__'

class PermissionSerializer(serializers.ModelSerializer):
    class Meta:
        model = Permission
        fields = '__all__'

class TodoSerializer(serializers.ModelSerializer):
    user_details = UserSerializer(source='user', read_only=True)
    output_details = OutputSerializer(source='output', read_only=True)
    permission_details = PermissionSerializer(source='permission', read_only=True)
    
    class Meta:
        model = Todo
        fields = '__all__'

```

#----------------------------------------------------------------------------------------------------

# core\serializers\__init__.py ====================================================

core\serializers\__init__.py:
```python
from core.serializers.project_serializer import ProjectSerializer
from core.serializers.ppap_serializer import PPAPSerializer
from core.serializers.phase_serializer import PhaseSerializer
from core.serializers.output_serializer import OutputSerializer
from core.serializers.document_serializer import DocumentSerializer
from core.serializers.user_serializer import UserSerializer
from core.serializers.client_serializer import ClientSerializer
from core.serializers.team_serializer import TeamSerializer
from core.serializers.person_serializer import PersonSerializer
from core.serializers.contact_serializer import ContactSerializer
from core.serializers.department_serializer import DepartmentSerializer
from core.serializers.history_serializer import HistorySerializer
from core.serializers.fastquery_serializer import FastQuerySerializer
from core.serializers.phase_template_serializer import PhaseTemplateSerializer
from core.serializers.output_template_serializer import OutputTemplateSerializer
from core.serializers.ppap_element_serializer import PPAPElementSerializer
from core.serializers.todo_serializer import TodoSerializer
from core.serializers.permission_serializer import PermissionSerializer
from core.serializers.authorization_serializer import AuthorizationSerializer

```

#----------------------------------------------------------------------------------------------------

# core\serializers\authorization_serializer.py ====================================

core\serializers\authorization_serializer.py:
```python
from rest_framework import serializers
from core.models import Authorization

class AuthorizationSerializer(serializers.ModelSerializer):
    class Meta:
        model = Authorization
        fields = '__all__'

```

#----------------------------------------------------------------------------------------------------

# core\serializers\client_serializer.py ===========================================

core\serializers\client_serializer.py:
```python
from rest_framework import serializers
from core.models import Client
from core.serializers.contact_serializer import ContactSerializer

class ClientSerializer(serializers.ModelSerializer):
    contact = ContactSerializer(read_only=True)
    
    class Meta:
        model = Client
        fields = '__all__'

```

#----------------------------------------------------------------------------------------------------

# core\serializers\contact_serializer.py ==========================================

core\serializers\contact_serializer.py:
```python
from rest_framework import serializers
from core.models import Contact

class ContactSerializer(serializers.ModelSerializer):
    class Meta:
        model = Contact
        fields = '__all__'

```

#----------------------------------------------------------------------------------------------------

# core\serializers\department_serializer.py =======================================

core\serializers\department_serializer.py:
```python
from rest_framework import serializers
from core.models import Department
from core.serializers.person_serializer import PersonSerializer

class DepartmentSerializer(serializers.ModelSerializer):
    members = PersonSerializer(many=True, read_only=True)
    
    class Meta:
        model = Department
        fields = '__all__'

```

#----------------------------------------------------------------------------------------------------

# core\serializers\document_serializer.py =========================================

core\serializers\document_serializer.py:
```python
from rest_framework import serializers
from core.models import Document
from core.serializers.user_serializer import UserSerializer

class DocumentSerializer(serializers.ModelSerializer):
    uploader_details = UserSerializer(source='uploader', read_only=True)
    
    class Meta:
        model = Document
        fields = '__all__'

```

#----------------------------------------------------------------------------------------------------

# core\serializers\fastquery_serializer.py ========================================

core\serializers\fastquery_serializer.py:
```python
from rest_framework import serializers
from core.models import FastQuery

class FastQuerySerializer(serializers.ModelSerializer):
    class Meta:
        model = FastQuery
        fields = '__all__'

```

#----------------------------------------------------------------------------------------------------

# core\serializers\history_serializer.py ==========================================

core\serializers\history_serializer.py:
```python
from rest_framework import serializers
from core.models import History
import json

class HistorySerializer(serializers.ModelSerializer):
    events = serializers.SerializerMethodField()
    
    class Meta:
        model = History
        fields = [
            'id', 'title', 'table_name', 'created_at', 
            'started_at', 'updated_at', 'deadline', 'finished_at',
            'events'  # Replacing 'event' field with parsed 'events'
        ]
    
    def get_events(self, obj):
        """Parse the JSON events string into a list of event objects"""
        try:
            return json.loads(obj.event)
        except (json.JSONDecodeError, TypeError):
            # If event isn't valid JSON, return it as a single event
            return [{
                "type": "unknown",
                "details": obj.event or "No details available",
                "timestamp": obj.created_at.isoformat() if obj.created_at else None
            }]

```

#----------------------------------------------------------------------------------------------------

# core\serializers\output_serializer.py ===========================================

core\serializers\output_serializer.py:
```python
from rest_framework import serializers
from core.models import Output, OutputTemplate, Phase, Person
from core.serializers.output_template_serializer import OutputTemplateSerializer
from core.serializers.document_serializer import DocumentSerializer
from core.serializers.user_serializer import UserSerializer

class OutputSerializer(serializers.ModelSerializer):
    template_details = OutputTemplateSerializer(source='template', read_only=True)
    documents = DocumentSerializer(many=True, read_only=True)
    user_details = UserSerializer(source='user', read_only=True)
    
    class Meta:
        model = Output
        fields = '__all__'
        
    def create(self, validated_data):
        # Handle template_id if provided
        template_id = self.initial_data.get('template_id')
        if template_id and 'template' not in validated_data:
            try:
                validated_data['template'] = OutputTemplate.objects.get(id=template_id)
            except OutputTemplate.DoesNotExist:
                raise serializers.ValidationError({'template_id': f'Template with ID {template_id} not found'})
        
        # Handle phase_id if provided
        phase_id = self.initial_data.get('phase_id')
        if phase_id and 'phase' not in validated_data:
            try:
                validated_data['phase'] = Phase.objects.get(id=phase_id)
            except Phase.DoesNotExist:
                raise serializers.ValidationError({'phase_id': f'Phase with ID {phase_id} not found'})
                
        # Handle ppap_element_id if provided
        ppap_element_id = self.initial_data.get('ppap_element_id')
        if ppap_element_id and 'ppap_element' not in validated_data:
            try:
                from core.models import PPAPElement
                validated_data['ppap_element'] = PPAPElement.objects.get(id=ppap_element_id)
            except PPAPElement.DoesNotExist:
                raise serializers.ValidationError({'ppap_element_id': f'PPAP Element with ID {ppap_element_id} not found'})
                
        # Handle assigned_to_id if provided
        assigned_to_id = self.initial_data.get('assigned_to_id')
        if assigned_to_id and 'assigned_to' not in validated_data:
            try:
                validated_data['assigned_to'] = Person.objects.get(id=assigned_to_id)
            except Person.DoesNotExist:
                raise serializers.ValidationError({'assigned_to_id': f'Person with ID {assigned_to_id} not found'})
                
        return super().create(validated_data)

```

#----------------------------------------------------------------------------------------------------

# core\serializers\output_template_serializer.py ==================================

core\serializers\output_template_serializer.py:
```python
from rest_framework import serializers
from core.models import OutputTemplate
from core.serializers.ppap_element_serializer import PPAPElementSerializer

class OutputTemplateSerializer(serializers.ModelSerializer):
    ppap_element_details = PPAPElementSerializer(source='ppap_element', read_only=True)
    
    class Meta:
        model = OutputTemplate
        fields = '__all__'

```

#----------------------------------------------------------------------------------------------------

# core\serializers\permission_serializer.py =======================================

core\serializers\permission_serializer.py:
```python
from rest_framework import serializers
from core.models import Permission

class PermissionSerializer(serializers.ModelSerializer):
    class Meta:
        model = Permission
        fields = '__all__'

```

#----------------------------------------------------------------------------------------------------

# core\serializers\person_serializer.py ===========================================

core\serializers\person_serializer.py:
```python
from rest_framework import serializers
from core.models import Person, Team

class TeamMinimalSerializer(serializers.ModelSerializer):
    class Meta:
        model = Team
        fields = ['id', 'name']

class PersonSerializer(serializers.ModelSerializer):
    teams = TeamMinimalSerializer(many=True, read_only=True)
    team_ids = serializers.PrimaryKeyRelatedField(
        many=True, 
        write_only=True, 
        queryset=Team.objects.all(),
        source='teams',
        required=False
    )
    
    class Meta:
        model = Person
        fields = '__all__'

```

#----------------------------------------------------------------------------------------------------

# core\serializers\phase_serializer.py ============================================

core\serializers\phase_serializer.py:
```python
from rest_framework import serializers
from core.models import Phase
from core.serializers.phase_template_serializer import PhaseTemplateSerializer
from core.serializers.output_serializer import OutputSerializer
from core.serializers.user_serializer import UserSerializer

class PhaseSerializer(serializers.ModelSerializer):
    template_details = PhaseTemplateSerializer(source='template', read_only=True)
    outputs = OutputSerializer(many=True, read_only=True)
    responsible_details = UserSerializer(source='responsible', read_only=True)
    
    class Meta:
        model = Phase
        fields = '__all__'

```

#----------------------------------------------------------------------------------------------------

# core\serializers\phase_template_serializer.py ===================================

core\serializers\phase_template_serializer.py:
```python
from rest_framework import serializers
from core.models import PhaseTemplate
from core.serializers.output_template_serializer import OutputTemplateSerializer

class PhaseTemplateSerializer(serializers.ModelSerializer):
    output_templates = OutputTemplateSerializer(many=True, read_only=True)
    
    class Meta:
        model = PhaseTemplate
        fields = '__all__'

```

#----------------------------------------------------------------------------------------------------

# core\serializers\ppap_element_serializer.py =====================================

core\serializers\ppap_element_serializer.py:
```python
from rest_framework import serializers
from core.models import PPAPElement

class PPAPElementSerializer(serializers.ModelSerializer):
    class Meta:
        model = PPAPElement
        fields = '__all__'

```

#----------------------------------------------------------------------------------------------------

# core\serializers\ppap_serializer.py =============================================

core\serializers\ppap_serializer.py:
```python
from rest_framework import serializers
from core.models import PPAP
from core.serializers.phase_serializer import PhaseSerializer

class PPAPSerializer(serializers.ModelSerializer):
    phases = PhaseSerializer(many=True, read_only=True)
    
    class Meta:
        model = PPAP
        fields = '__all__'

```

#----------------------------------------------------------------------------------------------------

# core\serializers\project_serializer.py ==========================================

core\serializers\project_serializer.py:
```python
from rest_framework import serializers
from core.models import Project
from core.serializers.client_serializer import ClientSerializer
from core.serializers.team_serializer import TeamSerializer
from core.serializers.ppap_serializer import PPAPSerializer

class ProjectSerializer(serializers.ModelSerializer):
    client_details = ClientSerializer(source='client', read_only=True)
    team_details = TeamSerializer(source='team', read_only=True)
    ppap_details = PPAPSerializer(source='ppap', read_only=True)
    
    class Meta:
        model = Project
        fields = '__all__'

```

#----------------------------------------------------------------------------------------------------

# core\serializers\team_serializer.py =============================================

core\serializers\team_serializer.py:
```python
from rest_framework import serializers
from core.models import Team
from core.serializers.person_serializer import PersonSerializer

class TeamSerializer(serializers.ModelSerializer):
    members = PersonSerializer(many=True, read_only=True)
    
    class Meta:
        model = Team
        fields = '__all__'

```

#----------------------------------------------------------------------------------------------------

# core\serializers\todo_serializer.py =============================================

core\serializers\todo_serializer.py:
```python
from rest_framework import serializers
from core.models import Todo
from core.serializers.user_serializer import UserSerializer
from core.serializers.output_serializer import OutputSerializer
from core.serializers.permission_serializer import PermissionSerializer

class TodoSerializer(serializers.ModelSerializer):
    user_details = UserSerializer(source='user', read_only=True)
    output_details = OutputSerializer(source='output', read_only=True)
    permission_details = PermissionSerializer(source='permission', read_only=True)
    
    class Meta:
        model = Todo
        fields = '__all__'

```

#----------------------------------------------------------------------------------------------------

# core\serializers\user_serializer.py =============================================

core\serializers\user_serializer.py:
```python
from rest_framework import serializers
from core.models import User
from core.serializers.person_serializer import PersonSerializer

class UserSerializer(serializers.ModelSerializer):
    person_details = PersonSerializer(source='person', read_only=True)
    
    class Meta:
        model = User
        fields = ['id', 'username', 'person', 'person_details', 'authorization', 'last_login', 'is_active', 'history_id']
        extra_kwargs = {'password': {'write_only': True}}
    
    def create(self, validated_data):
        user = User.objects.create_user(**validated_data)
        return user

```

#----------------------------------------------------------------------------------------------------

# core\services\__init__.py =======================================================

core\services\__init__.py:
```python
# Services module
from core.services.history import api as history_api
from core.services.project import api as project_api
from core.services.ppap import api as ppap_api
from core.services.phase import api as phase_api
from core.services.output import api as output_api
from core.services.document import api as document_api
from core.services.timeline import api as timeline_api
from core.services.logic import api as logic_api

# Export all APIs for use in views
__all__ = [
    'history_api',
    'project_api',
    'ppap_api',
    'phase_api',
    'output_api',
    'document_api',
    'timeline_api',
    'logic_api'
]

```

#----------------------------------------------------------------------------------------------------

# core\services\authorization\api.py ==============================================

core\services\authorization\api.py:
```python
from core.services.authorization.functions import (
    get_authorization_by_id,
    get_authorization_by_name,
    create_authorization,
    update_authorization,
    delete_authorization,
    get_all_authorizations,
    assign_user_authorization
)

__all__ = [
    'get_authorization_by_id',
    'get_authorization_by_name',
    'create_authorization',
    'update_authorization',
    'delete_authorization',
    'get_all_authorizations',
    'assign_user_authorization'
]
```

#----------------------------------------------------------------------------------------------------

# core\services\authorization\functions.py ========================================

core\services\authorization\functions.py:
```python
from django.db import transaction
from core.models import Authorization, User

def get_authorization_by_id(authorization_id):
    """
    Get an authorization by ID
    
    Args:
        authorization_id (int): Authorization ID
        
    Returns:
        Authorization: The authorization object
        
    Raises:
        Authorization.DoesNotExist: If authorization not found
    """
    return Authorization.objects.get(id=authorization_id)

def get_authorization_by_name(name):
    """
    Get an authorization by name
    
    Args:
        name (str): Authorization name (admin, create, edit)
        
    Returns:
        Authorization: The authorization object
        
    Raises:
        Authorization.DoesNotExist: If authorization not found
    """
    return Authorization.objects.get(name=name)

def create_authorization(name):
    """
    Create a new authorization level
    
    Args:
        name (str): Authorization name
        
    Returns:
        Authorization: Created authorization
    """
    return Authorization.objects.create(name=name)

def update_authorization(authorization_id, name=None):
    """
    Update an authorization
    
    Args:
        authorization_id (int): Authorization ID
        name (str, optional): New name
        
    Returns:
        Authorization: Updated authorization
    """
    authorization = get_authorization_by_id(authorization_id)
    
    if name is not None:
        authorization.name = name
    
    authorization.save()
    return authorization

@transaction.atomic
def delete_authorization(authorization_id):
    """
    Delete an authorization level
    
    Args:
        authorization_id (int): Authorization ID
        
    Returns:
        bool: True if deleted, False if it couldn't be deleted
    """
    try:
        # Check if authorization is in use
        authorization = get_authorization_by_id(authorization_id)
        users_count = User.objects.filter(authorization=authorization).count()
        
        if users_count > 0:
            # Cannot delete authorization in use
            return False
        
        # Delete the authorization
        authorization.delete()
        return True
    except Exception:
        return False

def get_all_authorizations():
    """
    Get all authorization levels
    
    Returns:
        QuerySet: All authorizations
    """
    return Authorization.objects.all()

def assign_user_authorization(user_id, authorization_id):
    """
    Assign an authorization level to a user
    
    Args:
        user_id (int): User ID
        authorization_id (int): Authorization ID
        
    Returns:
        User: Updated user
    """
    user = User.objects.get(id=user_id)
    authorization = get_authorization_by_id(authorization_id)
    
    user.authorization = authorization
    user.save()
    
    return user
```

#----------------------------------------------------------------------------------------------------

# core\services\authorization\seeder.py ===========================================

core\services\authorization\seeder.py:
```python
from django.db import transaction
from core.models import Authorization

@transaction.atomic
def seed_standard_authorizations():
    """
    Seed standard authorization levels
    
    Returns:
        list: Created authorization levels
    """
    # Define standard authorizations
    standard_authorizations = [
        {'name': 'admin'},
        {'name': 'create'},
        {'name': 'edit'}
    ]
    
    created_authorizations = []
    
    for auth_data in standard_authorizations:
        authorization, created = Authorization.objects.get_or_create(
            name=auth_data['name']
        )
        created_authorizations.append(authorization)
        
    return created_authorizations
```

#----------------------------------------------------------------------------------------------------

# core\services\client\__init__.py ================================================

core\services\client\__init__.py:
```python
# Client services

```

#----------------------------------------------------------------------------------------------------

# core\services\client\api.py =====================================================

core\services\client\api.py:
```python
# Client service API
from core.services.client.initialization import initialize_client
from core.services.client.functions import (
    get_client_by_id,
    get_clients_by_name,
    get_clients_by_code,
    update_client,
    delete_client,
    get_client_projects
)

# Export all functions for use in views
__all__ = [
    # Initialization
    'initialize_client',
    
    # Functions
    'get_client_by_id',
    'get_clients_by_name',
    'get_clients_by_code',
    'update_client',
    'delete_client',
    'get_client_projects'
]

```

#----------------------------------------------------------------------------------------------------

# core\services\client\functions.py ===============================================

core\services\client\functions.py:
```python
from core.models import Client, Project, Contact
from core.services.history.client import (
    record_client_creation,
    record_client_update,
    record_client_deletion,
    get_client_history
)

def get_client_by_id(client_id):
    """
    Get client by ID
    
    Args:
        client_id (int): Client ID
    
    Returns:
        Client: The client object
    """
    return Client.objects.get(id=client_id)

def get_clients_by_name(name):
    """
    Search clients by name
    
    Args:
        name (str): Search term
    
    Returns:
        QuerySet: Clients matching the search term
    """
    return Client.objects.filter(name__icontains=name)

def get_clients_by_code(code_value):
    """
    Search clients by code value
    
    Args:
        code_value (str): Code value to search for
    
    Returns:
        list: Clients with matching code value
    """
    # Since code is stored as JSON, we need to filter in Python
    all_clients = Client.objects.all()
    matching_clients = []
    
    for client in all_clients:
        for key, value in client.code.items():
            if str(value).lower() == str(code_value).lower():
                matching_clients.append(client)
                break
    
    return matching_clients

def update_client(client, name=None, address=None, code=None, description=None):
    """
    Update client information
    
    Args:
        client: Client object
        name (str): New name (if None, keep existing)
        address (str): New address (if None, keep existing)
        code (dict): New code information (if None, keep existing)
        description (str): New description (if None, keep existing)
    
    Returns:
        Client: The updated client
    """
    updated_fields = []
    
    if name is not None and name != client.name:
        client.name = name
        updated_fields.append('name')
    
    if address is not None and address != client.address:
        client.address = address
        updated_fields.append('address')
    
    if code is not None and code != client.code:
        client.code = code
        updated_fields.append('code')
    
    if description is not None and description != client.description:
        client.description = description
        updated_fields.append('description')
    
    if updated_fields:
        client.save()
        record_client_update(client, updated_fields)
    
    return client

def delete_client(client):
    """
    Delete a client
    
    Args:
        client: Client object
    """
    # Check for projects associated with this client
    projects_count = Project.objects.filter(client=client).count()
    if projects_count > 0:
        raise ValueError(f"Cannot delete client. It is associated with {projects_count} projects.")
    
    record_client_deletion(client)
    
    # Delete associated contact
    try:
        contact = Contact.objects.get(id=client.contact_id)
        contact.delete()
    except Contact.DoesNotExist:
        pass
    
    client.delete()

def get_client_projects(client_id):
    """
    Get all projects for a client
    
    Args:
        client_id (int): Client ID
    
    Returns:
        QuerySet: Projects for the client
    """
    return Project.objects.filter(client_id=client_id)

```

#----------------------------------------------------------------------------------------------------

# core\services\client\initialization.py ==========================================

core\services\client\initialization.py:
```python
from core.models import Client
import uuid

def initialize_client(name, address, code=None, description='', team=None):
    """
    Initialize a new client
    
    Args:
        name (str): Client name
        address (str): Client address
        code (dict): Client code information (fiscal code, DUNS, etc.)
        description (str): Client description
        team (Team, optional): Team associated with the client
    
    Returns:
        Client: The created client
    """
    if code is None:
        code = {}
    
    # First create the client - the save() method will generate IDs
    client = Client.objects.create(
        name=name,
        address=address,
        code=code,
        description=description,
        team=team
    )
    
    return client

```

#----------------------------------------------------------------------------------------------------

# core\services\contact\__init__.py ===============================================

core\services\contact\__init__.py:
```python
# Contact service module

```

#----------------------------------------------------------------------------------------------------

# core\services\contact\api.py ====================================================

core\services\contact\api.py:
```python
from core.models import Contact
from core.services.contact.initialization import initialize_contact
from core.services.contact.functions import (
    get_contact_by_id,
    update_contact_address,
    update_contact_email,
    update_contact_phone,
    check_contact_dependencies,
    get_person_by_contact,
    get_client_by_contact
)

def update_contact(contact, address=None, email=None, phone=None):
    """
    Update contact
    
    Args:
        contact (Contact): Contact to update
        address (str, optional): New address
        email (str, optional): New email
        phone (str, optional): New phone
        
    Returns:
        Contact: Updated contact
    """
    if address is not None:
        update_contact_address(contact, address)
    
    if email is not None:
        update_contact_email(contact, email)
    
    if phone is not None:
        update_contact_phone(contact, phone)
    
    return contact

def delete_contact(contact):
    """
    Delete contact
    
    Args:
        contact (Contact): Contact to delete
        
    Raises:
        ValueError: If contact has dependencies
    """
    if check_contact_dependencies(contact):
        raise ValueError("Cannot delete contact with dependencies")
    
    contact.delete()

```

#----------------------------------------------------------------------------------------------------

# core\services\contact\functions.py ==============================================

core\services\contact\functions.py:
```python
from core.models import Contact, Person, Client
from core.services.history.contact import (
    record_contact_creation,
    record_contact_update,
    record_contact_deletion
)

def get_contact_by_id(contact_id):
    """
    Get contact by ID
    
    Args:
        contact_id (str): Contact ID
        
    Returns:
        Contact: The contact object
        
    Raises:
        Contact.DoesNotExist: If contact not found
    """
    return Contact.objects.get(id=contact_id)

def get_contacts_by_type(type):
    """
    Get contacts by type
    
    Args:
        type (str): Contact type
        
    Returns:
        QuerySet: Contacts of the given type
    """
    return Contact.objects.filter(type=type)

def get_person_by_contact(contact_id):
    """
    Get person by contact ID
    
    Args:
        contact_id (str): Contact ID
        
    Returns:
        Person: The person object or None if not found
    """
    try:
        return Person.objects.get(contact_id=contact_id)
    except Person.DoesNotExist:
        return None

def get_client_by_contact(contact_id):
    """
    Get client by contact ID
    
    Args:
        contact_id (str): Contact ID
        
    Returns:
        Client: The client object or None if not found
    """
    try:
        return Client.objects.get(contact_id=contact_id)
    except Client.DoesNotExist:
        return None

def update_contact_address(contact, address):
    """
    Update contact address
    
    Args:
        contact (Contact): Contact to update
        address (str): New address
        
    Returns:
        Contact: Updated contact
    """
    contact.address = address
    contact.save()
    return contact

def update_contact_email(contact, email):
    """
    Update contact email
    
    Args:
        contact (Contact): Contact to update
        email (str): New email
        
    Returns:
        Contact: Updated contact
    """
    contact.email = email
    contact.save()
    return contact

def update_contact_phone(contact, phone):
    """
    Update contact phone
    
    Args:
        contact (Contact): Contact to update
        phone (str): New phone
        
    Returns:
        Contact: Updated contact
    """
    contact.phone = phone
    contact.save()
    return contact

def check_contact_dependencies(contact):
    """
    Check if contact has dependencies
    
    Args:
        contact (Contact): Contact to check
        
    Returns:
        bool: True if contact has dependencies, False otherwise
    """
    # Check if contact is associated with a person
    if get_person_by_contact(contact.id) is not None:
        return True
    
    # Check if contact is associated with a client
    if get_client_by_contact(contact.id) is not None:
        return True
    
    return False

def update_contact(contact, address=None, email=None, phone=None):
    """
    Update contact information
    
    Args:
        contact: Contact object
        address (str): New address (if None, keep existing)
        email (str): New email (if None, keep existing)
        phone (str): New phone (if None, keep existing)
    
    Returns:
        Contact: The updated contact
    """
    updated_fields = []
    
    if address is not None and address != contact.address:
        contact.address = address
        updated_fields.append('address')
    
    if email is not None and email != contact.email:
        contact.email = email
        updated_fields.append('email')
    
    if phone is not None and phone != contact.phone:
        contact.phone = phone
        updated_fields.append('phone')
    
    if updated_fields:
        contact.save()
        record_contact_update(contact, updated_fields)
    
    return contact

def delete_contact(contact):
    """
    Delete a contact
    
    Args:
        contact: Contact object
    """
    record_contact_deletion(contact)
    contact.delete()

```

#----------------------------------------------------------------------------------------------------

# core\services\contact\initialization.py =========================================

core\services\contact\initialization.py:
```python
from core.models import Contact
import uuid

def initialize_contact(address='', email='', phone='', type='person'):
    """
    Initialize a new contact
    
    Args:
        address (str, optional): Contact address
        email (str, optional): Contact email
        phone (str, optional): Contact phone
        type (str, optional): Contact type (person, client, client_member)
        
    Returns:
        Contact: The created contact
    """
    contact = Contact.objects.create(
        id=str(uuid.uuid4()),
        address=address,
        email=email,
        phone=phone,
        type=type
    )
    
    return contact

```

#----------------------------------------------------------------------------------------------------

# core\services\department\__init__.py ============================================

core\services\department\__init__.py:
```python
# Department service module

```

#----------------------------------------------------------------------------------------------------

# core\services\department\api.py =================================================

core\services\department\api.py:
```python
from core.models import Department, Person
from core.services.department.initialization import initialize_department
from core.services.department.functions import (
    get_department_by_id,
    update_department_name,
    update_department_responsible,
    check_department_dependencies,
    get_department_members,
    get_department_teams
)

def update_department(department, name=None, responsible=None):
    """
    Update department
    
    Args:
        department (Department): Department to update
        name (str, optional): New name
        responsible (Person, optional): New responsible person
        
    Returns:
        Department: Updated department
    """
    if name is not None:
        update_department_name(department, name)
    
    if responsible is not None:
        update_department_responsible(department, responsible)
    
    return department

def delete_department(department):
    """
    Delete department
    
    Args:
        department (Department): Department to delete
        
    Raises:
        ValueError: If department has dependencies
    """
    if check_department_dependencies(department):
        raise ValueError("Cannot delete department with dependencies")
    
    department.delete()

```

#----------------------------------------------------------------------------------------------------

# core\services\department\functions.py ===========================================

core\services\department\functions.py:
```python
from core.models import Department, Person, Team
from core.services.history.department import (
    record_department_creation,
    record_department_update,
    record_department_responsible_change,
    record_department_deletion
)

def get_department_by_id(department_id):
    """
    Get department by ID
    
    Args:
        department_id (int): Department ID
        
    Returns:
        Department: The department object
        
    Raises:
        Department.DoesNotExist: If department not found
    """
    return Department.objects.get(id=department_id)

def get_department_by_name(name):
    """
    Get department by name
    
    Args:
        name (str): Department name
        
    Returns:
        Department: The department object or None if not found
    """
    try:
        return Department.objects.get(name=name)
    except Department.DoesNotExist:
        return None

def get_departments_by_responsible(responsible_id):
    """
    Get departments by responsible person
    
    Args:
        responsible_id (int): Responsible person ID
        
    Returns:
        QuerySet: Departments with the given responsible person
    """
    return Department.objects.filter(responsible_id=responsible_id)

def update_department(department, name=None, responsible=None):
    """
    Update department information
    
    Args:
        department: Department object
        name (str): New name (if None, keep existing)
        responsible: New responsible user (if None, keep existing)
    
    Returns:
        Department: The updated department
    """
    updated_fields = []
    
    if name is not None and name != department.name:
        department.name = name
        updated_fields.append('name')
    
    if responsible is not None and responsible != department.responsible:
        old_responsible = department.responsible
        department.responsible = responsible
        updated_fields.append('responsible')
        record_department_responsible_change(department, old_responsible.id if old_responsible else None, responsible.id if responsible else None)
    
    if updated_fields:
        department.save()
        record_department_update(department, updated_fields)
    
    return department

def delete_department(department):
    """
    Delete a department
    
    Args:
        department: Department object
    """
    # Check for persons in this department
    persons_count = Person.objects.filter(department=department).count()
    if persons_count > 0:
        raise ValueError(f"Cannot delete department. It has {persons_count} persons assigned.")
    
    record_department_deletion(department)
    department.delete()

def get_department_members(department_id):
    """
    Get all members of a department
    
    Args:
        department_id (int): Department ID
        
    Returns:
        QuerySet: Persons in the department
    """
    return Person.objects.filter(department_id=department_id)

def get_department_teams(department_id):
    """
    Get all teams in a department
    
    Args:
        department_id (int): Department ID
        
    Returns:
        QuerySet: Teams in the department
    """
    return Team.objects.filter(department_id=department_id)

def update_department_name(department, name):
    """
    Update department name
    
    Args:
        department (Department): Department to update
        name (str): New name
        
    Returns:
        Department: Updated department
    """
    department.name = name
    department.save()
    return department

def update_department_responsible(department, responsible):
    """
    Update department responsible person
    
    Args:
        department (Department): Department to update
        responsible (Person): New responsible person
        
    Returns:
        Department: Updated department
    """
    department.responsible = responsible
    department.save()
    return department

def check_department_dependencies(department):
    """
    Check if department has dependencies
    
    Args:
        department (Department): Department to check
        
    Returns:
        bool: True if department has dependencies, False otherwise
    """
    # Check if department has members
    if Person.objects.filter(department=department).exists():
        return True
    
    # Check if department has teams
    if Team.objects.filter(department=department).exists():
        return True
    
    return False

```

#----------------------------------------------------------------------------------------------------

# core\services\department\initialization.py ======================================

core\services\department\initialization.py:
```python
from core.models import Department

def initialize_department(name, responsible=None):
    """
    Initialize a new department
    
    Args:
        name (str): Department name
        responsible (Person, optional): Person responsible for the department
        
    Returns:
        Department: The created department
    """
    department = Department.objects.create(
        name=name,
        responsible=responsible
    )
    
    return department

```

#----------------------------------------------------------------------------------------------------

# core\services\document\__init__.py ==============================================

core\services\document\__init__.py:
```python
# Document services

```

#----------------------------------------------------------------------------------------------------

# core\services\document\api.py ===================================================

core\services\document\api.py:
```python
# Document service API
from core.services.document.initialization import initialize_document
from core.services.document.functions import (
    get_document_by_id,
    get_documents_by_output,
    get_documents_by_status,
    update_document,
    update_document_file,
    delete_document,
    change_document_output
)

# Export all functions for use in views
__all__ = [
    # Initialization
    'initialize_document',
    
    # Functions
    'get_document_by_id',
    'get_documents_by_output',
    'get_documents_by_status',
    'update_document',
    'update_document_file',
    'delete_document',
    'change_document_output'
]

```

#----------------------------------------------------------------------------------------------------

# core\services\document\functions.py =============================================

core\services\document\functions.py:
```python
from core.models import Document, Output, History
from core.services.history.document import (
    record_document_creation,
    record_document_update,
    record_document_version_change,
    record_document_status_change,
    record_document_deletion
)
import os
import shutil
from django.utils import timezone

def get_document_by_id(document_id):
    """
    Get document by ID
    
    Args:
        document_id (int): Document ID
    
    Returns:
        Document: The document object
    """
    return Document.objects.get(id=document_id)

def get_documents_by_output(output_id):
    """
    Get documents for a specific output
    
    Args:
        output_id (int): Output ID
    
    Returns:
        QuerySet: Documents for the specified output
    """
    return Document.objects.filter(output_id=output_id)

def get_documents_by_status(status):
    """
    Get documents with a specific status
    
    Args:
        status (str): Document status
    
    Returns:
        QuerySet: Documents with the specified status
    """
    return Document.objects.filter(status=status)

def update_document(document, name=None, status=None):
    """
    Update document information
    
    Args:
        document: Document object
        name (str): New name (if None, keep existing)
        status (str): New status (if None, keep existing)
    
    Returns:
        Document: The updated document
    """
    updated_fields = []
    
    if name is not None and name != document.name:
        document.name = name
        updated_fields.append('name')
    
    if status is not None and status != document.status:
        old_status = document.status
        document.status = status
        updated_fields.append('status')
        record_document_status_change(document, old_status, status)
    
    if updated_fields:
        document.save()
        record_document_update(document, updated_fields)
    
    return document

def update_document_file(document, new_file_path):
    """
    Update document file (create new version)
    
    Args:
        document: Document object
        new_file_path: Path to the new file
    
    Returns:
        Document: The updated document
    """
    old_version = document.version
    new_version = old_version + 1
    
    # Extract file name from path
    file_name = os.path.basename(new_file_path)
    
    document.file_path = new_file_path
    document.file_name = file_name
    document.version = new_version
    document.save()
    
    record_document_version_change(document, old_version, new_version)
    
    return document

def delete_document(document, delete_file=True):
    """
    Delete a document
    
    Args:
        document: Document object
        delete_file (bool): Whether to delete the physical file
    """
    record_document_deletion(document)
    
    # Delete physical file if requested
    if delete_file and document.file_path and os.path.exists(document.file_path):
        if os.path.isfile(document.file_path):
            os.remove(document.file_path)
        else:
            shutil.rmtree(document.file_path)
    
    document.delete()

def change_document_output(document, output):
    """
    Change the output associated with a document
    
    Args:
        document: Document object
        output: Output object
    
    Returns:
        Document: The updated document
    """
    old_output_id = document.output.id if document.output else None
    
    document.output = output
    document.save()
    
    History.objects.create(
        id=document.history_id,
        title=document.name,
        event=f"Document moved from output ID {old_output_id} to output ID {output.id}",
        table_name='document',
    )
    
    return document

```

#----------------------------------------------------------------------------------------------------

# core\services\document\initialization.py ========================================

core\services\document\initialization.py:
```python
import uuid
from core.models import Document, Output, History
from core.services.history.document import (
    record_document_creation,
    record_document_update,
    record_document_version_change,
    record_document_status_change,
    record_document_deletion
)
import os
import shutil
from django.utils import timezone

def initialize_document(name, file_path, file_name, output, status='draft', version=1):
    """
    Initialize a new document
    
    Args:
        name (str): Document name
        file_path (str): Path to the document file
        file_name (str): Name of the document file
        output (Output): Associated output
        status (str, optional): Document status, defaults to 'draft'
        version (int, optional): Document version, defaults to 1
    
    Returns:
        Document: The created document
    """
    # Generate history ID
    history_id = f"{uuid.uuid4().hex}document"
    
    # Create the document
    document = Document.objects.create(
        name=name,
        file_path=file_path,
        file_name=file_name,
        output=output,
        status=status,
        version=version,
        history_id=history_id
    )
    
    # Record creation in history
    record_document_creation(document)
    
    return document

def get_document_by_id(document_id):
    """
    Get document by ID
    
    Args:
        document_id (int): Document ID
    
    Returns:
        Document: The document object
    """
    return Document.objects.get(id=document_id)

def get_documents_by_output(output_id):
    """
    Get documents for a specific output
    
    Args:
        output_id (int): Output ID
    
    Returns:
        QuerySet: Documents for the specified output
    """
    return Document.objects.filter(output_id=output_id)

def get_documents_by_status(status):
    """
    Get documents with a specific status
    
    Args:
        status (str): Document status
    
    Returns:
        QuerySet: Documents with the specified status
    """
    return Document.objects.filter(status=status)

def update_document(document, name=None, status=None):
    """
    Update document information
    
    Args:
        document: Document object
        name (str): New name (if None, keep existing)
        status (str): New status (if None, keep existing)
    
    Returns:
        Document: The updated document
    """
    updated_fields = []
    
    if name is not None and name != document.name:
        document.name = name
        updated_fields.append('name')
    
    if status is not None and status != document.status:
        old_status = document.status
        document.status = status
        updated_fields.append('status')
        record_document_status_change(document, old_status, status)
    
    if updated_fields:
        document.save()
        record_document_update(document, updated_fields)
    
    return document

def update_document_file(document, new_file_path):
    """
    Update document file (create new version)
    
    Args:
        document: Document object
        new_file_path: Path to the new file
    
    Returns:
        Document: The updated document
    """
    old_version = document.version
    new_version = old_version + 1
    
    # Extract file name from path
    file_name = os.path.basename(new_file_path)
    
    document.file_path = new_file_path
    document.file_name = file_name
    document.version = new_version
    document.save()
    
    record_document_version_change(document, old_version, new_version)
    
    return document

def delete_document(document, delete_file=True):
    """
    Delete a document
    
    Args:
        document: Document object
        delete_file (bool): Whether to delete the physical file
    """
    record_document_deletion(document)
    
    # Delete physical file if requested
    if delete_file and document.file_path and os.path.exists(document.file_path):
        if os.path.isfile(document.file_path):
            os.remove(document.file_path)
        else:
            shutil.rmtree(document.file_path)
    
    document.delete()

def change_document_output(document, output):
    """
    Change the output associated with a document
    
    Args:
        document: Document object
        output: Output object
    
    Returns:
        Document: The updated document
    """
    old_output_id = document.output.id if document.output else None
    
    document.output = output
    document.save()
    
    History.objects.create(
        id=document.history_id,
        title=document.name,
        event=f"Document moved from output ID {old_output_id} to output ID {output.id}",
        table_name='document',
        timestamp=timezone.now()
    )
    
    return document

```

#----------------------------------------------------------------------------------------------------

# core\services\history\__init__.py ===============================================

core\services\history\__init__.py:
```python
# History tracking services

```

#----------------------------------------------------------------------------------------------------

# core\services\history\api.py ====================================================

core\services\history\api.py:
```python
# Define all API here
from core.services.history.initialization import initialize_history, generate_history_id
from core.services.history.project import (
    record_project_creation, 
    record_project_update, 
    record_project_deletion
)
from core.services.history.ppap import (
    record_ppap_creation, 
    record_ppap_update, 
    record_ppap_level_change
)
from core.services.history.phase import (
    record_phase_creation, 
    record_phase_update, 
    record_phase_status_change
)
from core.services.history.output import (
    record_output_creation, 
    record_output_update, 
    record_output_status_change,
    record_output_document_upload,
    record_output_responsibility_change,
    record_output_deletion,
    record_output_review,
    get_output_history
)
from core.services.history.user import (
    record_user_creation, 
    record_user_update, 
    record_user_login
)
from core.services.history.document import (
    record_document_creation,
    record_document_update,
    record_document_version_change,
    record_document_status_change,
    record_document_deletion,
    get_document_history
)
from core.services.history.client import (
    record_client_creation,
    record_client_update,
    record_client_deletion,
    get_client_history
)
from core.services.history.team import (
    record_team_creation,
    record_team_update,
    record_team_member_addition,
    record_team_member_removal,
    record_team_deletion,
    get_team_history
)
from core.services.history.department import (
    record_department_creation,
    record_department_update,
    record_department_responsible_change,
    record_department_deletion,
    get_department_history
)
from core.services.history.person import (
    record_person_creation,
    record_person_update,
    record_person_team_change,
    record_person_department_change,
    record_person_deletion,
    get_person_history
)
from core.services.history.contact import (
    record_contact_creation,
    record_contact_update,
    record_contact_deletion,
    get_contact_history
)
from core.services.history.editor import (
    update_history_dates,
    set_entity_deadline,
    get_entity_deadline,
    bulk_update_entity_deadlines
)


# Export all functions for use in views
__all__ = [
    # Initialization
    'initialize_history',
    'generate_history_id',
    
    # Project
    'record_project_creation',
    'record_project_update',
    'record_project_deletion',
    
    # PPAP
    'record_ppap_creation',
    'record_ppap_update',
    'record_ppap_level_change',
    
    # Phase
    'record_phase_creation',
    'record_phase_update',
    'record_phase_status_change',
    
    # Output
    'record_output_creation',
    'record_output_update',
    'record_output_status_change',
    'record_output_document_upload',
    'record_output_responsibility_change',
    'record_output_deletion',
    'record_output_review',
    'get_output_history',
    
    # User
    'record_user_creation',
    'record_user_update',
    'record_user_login',
    
    # Document
    'record_document_creation',
    'record_document_update',
    'record_document_version_change',
    'record_document_status_change',
    'record_document_deletion',
    'get_document_history',
    
    # Client
    'record_client_creation',
    'record_client_update',
    'record_client_deletion',
    'get_client_history',
    
    # Team
    'record_team_creation',
    'record_team_update',
    'record_team_member_addition',
    'record_team_member_removal',
    'record_team_deletion',
    'get_team_history',
    
    # Department
    'record_department_creation',
    'record_department_update',
    'record_department_responsible_change',
    'record_department_deletion',
    'get_department_history',
    
    # Person
    'record_person_creation',
    'record_person_update',
    'record_person_team_change',
    'record_person_department_change',
    'record_person_deletion',
    'get_person_history',
    
    # Contact
    'record_contact_creation',
    'record_contact_update',
    'record_contact_deletion',
    'get_contact_history',
    
    # Editor
    'update_history_dates',
    'set_entity_deadline',
    'get_entity_deadline',
    'bulk_update_entity_deadlines'
]

```

#----------------------------------------------------------------------------------------------------

# core\services\history\client.py =================================================

core\services\history\client.py:
```python
from core.models import Client
from django.utils import timezone
import uuid
import json
from core.services.history.initialization import (
    get_history, initialize_history, add_history_event, ensure_history_id
)

def record_client_creation(client):
    """
    Record client creation in history
    
    Args:
        client: Client object
        
    Returns:
        History: Created history record
    """
    # Ensure client has a history_id
    ensure_history_id(client)
    
    # Initialize a new history record
    history = initialize_history(
        title=client.name,
        event_type="create",
        event_details=f"Client created with ID {client.id}",
        table_name='client',
        history_id=client.history_id
    )
    
    return history

def record_client_update(client, updated_fields):
    """
    Record client update in history
    
    Args:
        client: Client object
        updated_fields: List of updated field names
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(client)
    
    if not history:
        return None
    
    # Add update event
    event_details = f"Client updated. Fields changed: {', '.join(updated_fields)}"
    
    return add_history_event(history, "update", event_details)

def record_client_name_change(client, old_name, new_name):
    """
    Record client name change in history
    
    Args:
        client: Client object
        old_name: Previous name
        new_name: New name
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(client)
    
    if not history:
        return None
    
    # Add name change event
    event_details = f"Client name changed from '{old_name}' to '{new_name}'"
    
    # Update the history title to reflect the new name
    history.title = new_name
    history.save(update_fields=['title'])
    
    return add_history_event(history, "name_change", event_details)

def record_client_status_change(client, old_status, new_status):
    """
    Record client status change in history
    
    Args:
        client: Client object
        old_status: Previous status
        new_status: New status
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(client)
    
    if not history:
        return None
    
    # Add status change event
    event_details = f"Client status changed from '{old_status}' to '{new_status}'"
    
    # Determine event type based on status
    event_type = "status_change"
    if new_status.lower() in ['active', 'approved']:
        event_type = "activate"
    elif new_status.lower() in ['inactive', 'suspended']:
        event_type = "deactivate"
    elif new_status.lower() in ['complete', 'finished']:
        event_type = "complete"
    
    return add_history_event(history, event_type, event_details)

def record_client_deletion(client):
    """
    Record client deletion in history
    
    Args:
        client: Client object
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(client)
    
    if not history:
        return None
    
    # Add deletion event
    event_details = f"Client deleted with ID {client.id}"
    
    return add_history_event(history, "delete", event_details)

def get_client_history(client_id):
    """
    Get history record for a client
    
    Args:
        client_id (int): Client ID
    
    Returns:
        History or None: Client history record if found, None otherwise
    """
    try:
        client = Client.objects.get(id=client_id)
        return get_history(client)
    except Client.DoesNotExist:
        return None

```

#----------------------------------------------------------------------------------------------------

# core\services\history\contact.py ================================================

core\services\history\contact.py:
```python
from core.models import Contact
from django.utils import timezone
from core.services.history.initialization import (
    get_history, initialize_history, add_history_event, ensure_history_id
)

def record_contact_creation(contact):
    """
    Record contact creation in history
    
    Args:
        contact (Contact): Created contact
        
    Returns:
        History: Created history record
    """
    # Ensure contact has a history_id
    ensure_history_id(contact)
    
    # Initialize a new history record
    history = initialize_history(
        title=f"Contact {contact.email}",
        event_type="create",
        event_details=f"Contact created with ID {contact.id}",
        table_name='contact',
        history_id=contact.history_id
    )
    
    return history

def record_contact_update(contact, updated_fields=None):
    """
    Record contact update in history
    
    Args:
        contact (Contact): Updated contact
        updated_fields (list, optional): List of updated fields
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(contact)
    
    if not history:
        return None
    
    # Add update event
    if updated_fields:
        event_details = f"Contact updated. Fields changed: {', '.join(updated_fields)}"
    else:
        event_details = "Contact updated."
    
    # Make sure title stays updated with current email
    history.title = f"Contact {contact.email}"
    history.save(update_fields=['title'])
    
    return add_history_event(history, "update", event_details)

def record_contact_email_change(contact, old_email, new_email):
    """
    Record contact email change in history
    
    Args:
        contact (Contact): Contact object
        old_email (str): Previous email address
        new_email (str): New email address
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(contact)
    
    if not history:
        return None
    
    # Update the title to reflect the new email
    history.title = f"Contact {new_email}"
    history.save(update_fields=['title'])
    
    # Add email change event
    event_details = f"Email changed from '{old_email}' to '{new_email}'"
    
    return add_history_event(history, "email_change", event_details)

def record_contact_address_change(contact, old_address, new_address):
    """
    Record contact address change in history
    
    Args:
        contact (Contact): Contact object
        old_address (str): Previous address
        new_address (str): New address
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(contact)
    
    if not history:
        return None
    
    # Add address change event
    event_details = f"Address updated"
    
    # If addresses are short enough, include them in the details
    if len(old_address) + len(new_address) < 200:
        event_details = f"Address changed from '{old_address}' to '{new_address}'"
    
    return add_history_event(history, "address_change", event_details)

def record_contact_phone_change(contact, old_phone, new_phone):
    """
    Record contact phone change in history
    
    Args:
        contact (Contact): Contact object
        old_phone (str): Previous phone number
        new_phone (str): New phone number
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(contact)
    
    if not history:
        return None
    
    # Add phone change event
    event_details = f"Phone changed from '{old_phone}' to '{new_phone}'"
    
    return add_history_event(history, "phone_change", event_details)

def record_contact_deletion(contact):
    """
    Record contact deletion in history
    
    Args:
        contact (Contact): Deleted contact
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(contact)
    
    if not history:
        return None
    
    # Add deletion event
    event_details = f"Contact with ID {contact.id} deleted"
    
    return add_history_event(history, "delete", event_details)

def get_contact_history(contact_id):
    """
    Get history record for a contact
    
    Args:
        contact_id (str): Contact ID
        
    Returns:
        History or None: Contact history record if found, None otherwise
    """
    try:
        contact = Contact.objects.get(id=contact_id)
        return get_history(contact)
    except Contact.DoesNotExist:
        return None

```

#----------------------------------------------------------------------------------------------------

# core\services\history\department.py =============================================

core\services\history\department.py:
```python
from core.models import Department
from django.utils import timezone
from core.services.history.initialization import (
    get_history, initialize_history, add_history_event, ensure_history_id
)

def record_department_creation(department):
    """
    Record department creation in history
    
    Args:
        department (Department): Created department
        
    Returns:
        History: Created history record
    """
    # Ensure department has a history_id
    ensure_history_id(department)
    
    # Initialize a new history record
    history = initialize_history(
        title=f"Department {department.name}",
        event_type="create",
        event_details=f"Department created with ID {department.id}",
        table_name='department',
        history_id=department.history_id
    )
    
    return history

def record_department_update(department, updated_fields=None):
    """
    Record department update in history
    
    Args:
        department (Department): Updated department
        updated_fields (list, optional): List of updated fields
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(department)
    
    if not history:
        return None
    
    # Add update event
    if updated_fields:
        event_details = f"Department updated. Fields changed: {', '.join(updated_fields)}"
    else:
        event_details = "Department updated."
    
    # Make sure title stays updated with current name
    history.title = f"Department {department.name}"
    history.save(update_fields=['title'])
    
    return add_history_event(history, "update", event_details)

def record_department_name_change(department, old_name, new_name):
    """
    Record department name change in history
    
    Args:
        department (Department): Department object
        old_name (str): Previous department name
        new_name (str): New department name
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(department)
    
    if not history:
        return None
    
    # Update the title to reflect the new name
    history.title = f"Department {new_name}"
    history.save(update_fields=['title'])
    
    # Add name change event
    event_details = f"Department name changed from '{old_name}' to '{new_name}'"
    
    return add_history_event(history, "name_change", event_details)

def record_department_responsible_change(department, old_responsible_id, new_responsible_id):
    """
    Record department responsible person change in history
    
    Args:
        department (Department): Department object
        old_responsible_id: ID of previous responsible person (can be None)
        new_responsible_id: ID of new responsible person (can be None)
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(department)
    
    if not history:
        return None
    
    # Create event details
    if old_responsible_id is None and new_responsible_id is not None:
        event_details = f"Responsible person assigned to department (ID: {new_responsible_id})"
        event_type = "responsible_assign"
    elif old_responsible_id is not None and new_responsible_id is None:
        event_details = f"Responsible person removed from department (was ID {old_responsible_id})"
        event_type = "responsible_remove"
    else:
        event_details = f"Department responsible changed from ID {old_responsible_id} to ID {new_responsible_id}"
        event_type = "responsible_change"
    
    return add_history_event(history, event_type, event_details)

def record_department_team_assignment(department, team):
    """
    Record department team assignment in history
    
    Args:
        department (Department): Department object
        team (Team): Team being assigned to department
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(department)
    
    if not history:
        return None
    
    # Add team assignment event
    event_details = f"Team '{team.name}' (ID: {team.id}) assigned to department"
    
    return add_history_event(history, "team_assign", event_details)

def record_department_team_removal(department, team):
    """
    Record department team removal in history
    
    Args:
        department (Department): Department object
        team (Team): Team being removed from department
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(department)
    
    if not history:
        return None
    
    # Add team removal event
    event_details = f"Team '{team.name}' (ID: {team.id}) removed from department"
    
    return add_history_event(history, "team_remove", event_details)

def record_department_deletion(department):
    """
    Record department deletion in history
    
    Args:
        department (Department): Deleted department
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(department)
    
    if not history:
        return None
    
    # Add deletion event
    event_details = f"Department with ID {department.id} deleted"
    
    return add_history_event(history, "delete", event_details)

def get_department_history(department_id):
    """
    Get history record for a department
    
    Args:
        department_id: Department ID
        
    Returns:
        History or None: Department history record if found, None otherwise
    """
    try:
        department = Department.objects.get(id=department_id)
        return get_history(department)
    except Department.DoesNotExist:
        return None

```

#----------------------------------------------------------------------------------------------------

# core\services\history\document.py ===============================================

core\services\history\document.py:
```python
# Document history tracking
from core.models import Document
from django.utils import timezone
from core.services.history.initialization import (
    get_history, initialize_history, add_history_event, ensure_history_id
)

def record_document_creation(document):
    """
    Record document creation in history
    
    Args:
        document (Document): Created document
        
    Returns:
        History: Created history record
    """
    # Ensure document has a history_id
    ensure_history_id(document)
    
    # Initialize a new history record
    history = initialize_history(
        title=document.name,
        event_type="create",
        event_details=f"Document created for Output {document.output_id}",
        table_name='document',
        history_id=document.history_id
    )
    
    return history

def record_document_update(document, updated_fields):
    """
    Record document update in history
    
    Args:
        document (Document): Updated document
        updated_fields (list): List of fields that were updated
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(document)
    
    if not history:
        return None
    
    # Make sure title stays updated with current name
    history.title = document.name
    history.save(update_fields=['title'])
    
    # Add update event
    event_details = f"Document updated: {', '.join(updated_fields)}"
    
    return add_history_event(history, "update", event_details)

def record_document_name_change(document, old_name, new_name):
    """
    Record document name change in history
    
    Args:
        document (Document): Document object
        old_name (str): Previous document name
        new_name (str): New document name
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(document)
    
    if not history:
        return None
    
    # Update the title to reflect the new name
    history.title = new_name
    history.save(update_fields=['title'])
    
    # Add name change event
    event_details = f"Document name changed from '{old_name}' to '{new_name}'"
    
    return add_history_event(history, "name_change", event_details)

def record_document_version_change(document, old_version, new_version):
    """
    Record document version change in history
    
    Args:
        document (Document): Document object
        old_version: Previous version number
        new_version: New version number
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(document)
    
    if not history:
        return None
    
    # Add version change event
    event_details = f"Document version changed from {old_version} to {new_version}"
    
    return add_history_event(history, "version_change", event_details)

def record_document_status_change(document, old_status, new_status):
    """
    Record document status change in history
    
    Args:
        document (Document): Document object
        old_status: Previous status
        new_status: New status
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(document)
    
    if not history:
        return None
    
    # Add status change event
    event_details = f"Document status changed from '{old_status}' to '{new_status}'"
    
    # Determine event type based on status
    event_type = "status_change"
    if new_status.lower() in ['completed', 'approved', 'finalized']:
        event_type = "complete"
    elif new_status.lower() in ['draft', 'in_progress']:
        event_type = "in_progress"
    elif new_status.lower() in ['review', 'reviewing']:
        event_type = "review"
        
    return add_history_event(history, event_type, event_details)

def record_document_file_change(document, old_file_path, new_file_path):
    """
    Record document file change in history
    
    Args:
        document (Document): Document object
        old_file_path: Previous file path
        new_file_path: New file path
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(document)
    
    if not history:
        return None
    
    # Add file change event
    event_details = f"Document file updated"
    
    return add_history_event(history, "file_change", event_details)

def record_document_review(document, reviewer_id, status, comments=None):
    """
    Record document review in history
    
    Args:
        document (Document): Document object
        reviewer_id: ID of the reviewer
        status: Review status (approved, rejected, etc.)
        comments: Optional review comments
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(document)
    
    if not history:
        return None
    
    # Add review event
    event_details = f"Document reviewed by User {reviewer_id} with status: {status}"
    if comments:
        event_details += f". Comments: {comments}"
    
    # Determine event type based on review status
    event_type = "review"
    if status.lower() in ['approved', 'accepted']:
        event_type = "approve"
    elif status.lower() in ['rejected', 'denied']:
        event_type = "reject"
        
    return add_history_event(history, event_type, event_details)

def record_document_deletion(document):
    """
    Record document deletion in history
    
    Args:
        document (Document): Document object being deleted
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(document)
    
    if not history:
        return None
    
    # Add deletion event
    event_details = f"Document deleted with ID {document.id}"
    
    return add_history_event(history, "delete", event_details)

def get_document_history(document_id):
    """
    Get history record for a document
    
    Args:
        document_id: Document ID
    
    Returns:
        History or None: Document history record if found, None otherwise
    """
    try:
        document = Document.objects.get(id=document_id)
        return get_history(document)
    except Document.DoesNotExist:
        return None

```

#----------------------------------------------------------------------------------------------------

# core\services\history\editor.py =================================================

core\services\history\editor.py:
```python
from core.models import History
from django.utils import timezone
from django.db import transaction
import uuid

def update_history_dates(history_id, deadline=None, started_at=None, completed_at=None):
    """
    Update date attributes for a history record
    
    Args:
        history_id (UUID): History ID
        deadline (datetime, optional): New deadline date
        started_at (datetime, optional): New start date
        completed_at (datetime, optional): New completion date
        
    Returns:
        History: Updated history record
        
    Raises:
        History.DoesNotExist: If history record not found
    """
    # Get most recent history record with this ID
    history = History.objects.filter(history_id=history_id).order_by('-created_at').first()
    
    if not history:
        raise History.DoesNotExist(f"History with ID {history_id} not found")
    
    # Track which fields were updated
    updated_fields = []
    
    if deadline is not None:
        history.deadline = deadline
        updated_fields.append('deadline')
    
    if started_at is not None:
        history.started_at = started_at
        updated_fields.append('started_at')
    
    if completed_at is not None:
        history.completed_at = completed_at if not hasattr(history, 'completed_at') else history.completed_at
        updated_fields.append('completed_at')
    
    # Save the changes
    if updated_fields:
        history.save(update_fields=updated_fields)
        
        # Record the date updates in a new history event
        from core.services.history.initialization import add_history_event
        
        updated_fields_str = ', '.join(updated_fields)
        event_details = f"Updated history dates: {updated_fields_str}"
        add_history_event(history, "date_update", event_details)
    
    return history

def set_entity_deadline(entity, deadline, table_name=None):
    """
    Set or update the deadline for an entity
    
    Args:
        entity: Entity object with history_id attribute
        deadline (datetime): New deadline date
        table_name (str, optional): Table name, if different from entity's class
        
    Returns:
        dict: Result with history and entity
        
    Raises:
        ValueError: If entity has no history_id
    """
    if not hasattr(entity, 'history_id') or not entity.history_id:
        raise ValueError(f"Entity {entity} has no history_id")
    
    # Get table name if not provided
    if not table_name:
        table_name = entity.__class__.__name__.lower()
    
    # Get current history record
    from core.services.history.initialization import get_history
    history = get_history(entity, table_name)
    
    # Get current deadline for event recording
    old_deadline = history.deadline if history else None
    
    # Update deadline
    updated_history = update_history_dates(entity.history_id, deadline=deadline)
    
    # Record specific event based on entity type
    if table_name == 'phase':
        from core.services.history.phase import record_phase_deadline_change
        record_phase_deadline_change(entity, old_deadline, deadline)
    elif table_name == 'output':
        from core.services.history.output import record_output_deadline_change
        record_output_deadline_change(entity, old_deadline, deadline)
    else:
        # Generic deadline change event
        from core.services.history.initialization import add_history_event
        event_details = f"{table_name.capitalize()} deadline updated"
        add_history_event(updated_history, "deadline_change", event_details)
    
    return {
        'history': updated_history,
        'entity': entity
    }

def get_entity_deadline(entity, table_name=None):
    """
    Get deadline for an entity
    
    Args:
        entity: Entity object with history_id attribute
        table_name (str, optional): Table name, if different from entity's class
        
    Returns:
        datetime or None: Current deadline or None if not set
        
    Raises:
        ValueError: If entity has no history_id
    """
    if not hasattr(entity, 'history_id') or not entity.history_id:
        raise ValueError(f"Entity {entity} has no history_id")
    
    # Get table name if not provided
    if not table_name:
        table_name = entity.__class__.__name__.lower()
    
    # Get current history record
    from core.services.history.initialization import get_history
    history = get_history(entity, table_name)
    
    return history.deadline if history else None

@transaction.atomic
def bulk_update_entity_deadlines(entity_ids, deadline, entity_class, table_name=None):
    """
    Update deadlines for multiple entities at once
    
    Args:
        entity_ids (list): List of entity IDs
        deadline (datetime): Deadline to set
        entity_class (class): Entity model class
        table_name (str, optional): Table name
        
    Returns:
        dict: Results with count and updated entities
    """
    if not table_name:
        table_name = entity_class.__name__.lower()
    
    entities = entity_class.objects.filter(id__in=entity_ids)
    updated = 0
    failed = 0
    updated_entities = []
    
    for entity in entities:
        try:
            result = set_entity_deadline(entity, deadline, table_name)
            updated += 1
            updated_entities.append(result['entity'].id)
        except Exception:
            failed += 1
    
    return {
        'updated_count': updated,
        'failed_count': failed,
        'total': len(entity_ids),
        'updated_entities': updated_entities
    }
```

#----------------------------------------------------------------------------------------------------

# core\services\history\initialization.py =========================================

core\services\history\initialization.py:
```python
import uuid
import json
from core.models import History
from django.utils import timezone

def generate_history_id(table_name):
    """
    Generate a unique history ID for a new record
    """
    return f"{uuid.uuid4().hex}{table_name}"

def initialize_history(title, event_type, event_details, table_name, history_id=None):
    """
    Initialize a history record with events stored as JSON
    
    Args:
        title (str): History title
        event_type (str): Type of event (create, update, delete, etc.)
        event_details (str): Details about the event
        table_name (str): Name of the related table
        history_id (str, optional): History ID if already generated
        
    Returns:
        History: Created history record
    """
    if not history_id:
        history_id = generate_history_id(table_name)
    
    # Create initial event as a list with one item
    now = timezone.now().isoformat()
    initial_event = [{
        "type": event_type,
        "details": event_details,
        "timestamp": now
    }]
    
    # Store events as JSON string
    history = History.objects.create(
        id=history_id,
        title=title,
        event=json.dumps(initial_event),
        table_name=table_name,
        started_at=timezone.now() if event_type == 'create' else None
    )
    
    return history

def add_history_event(history, event_type, event_details):
    """
    Add a new event to an existing history record
    
    Args:
        history (History): Existing history record
        event_type (str): Type of event (create, update, delete, etc.)
        event_details (str): Details about the event
        
    Returns:
        History: Updated history record
    """
    # Parse existing events
    try:
        existing_events = json.loads(history.event)
    except (json.JSONDecodeError, TypeError):
        # If existing event isn't valid JSON, start a new event list
        existing_events = []
    
    # Ensure existing_events is a list
    if not isinstance(existing_events, list):
        existing_events = []
    
    # Create new event
    now = timezone.now()
    new_event = {
        "type": event_type,
        "details": event_details,
        "timestamp": now.isoformat()
    }
    
    # Add new event to the list
    existing_events.append(new_event)
    
    # Update history record
    history.event = json.dumps(existing_events)
    
    # Update appropriate timestamp fields based on event type
    if event_type == 'create' and not history.started_at:
        history.started_at = now
    elif event_type == 'update':
        history.updated_at = now
    elif event_type in ['complete', 'approve', 'finalize']:
        history.finished_at = now
    elif event_type == 'delete':
        history.finished_at = now
    
    # Save history with updated fields
    update_fields = ['event']
    if event_type == 'create' and not history.started_at:
        update_fields.append('started_at')
    if history.updated_at:
        update_fields.append('updated_at')
    if history.finished_at:
        update_fields.append('finished_at')
    
    history.save(update_fields=update_fields)
    
    return history

def get_history(model_instance):
    """
    Get existing history record for a model instance
    
    Args:
        model_instance: Model instance with history_id attribute
        
    Returns:
        History or None: The history record if found, None otherwise
    """
    # Check if model has history_id
    if not hasattr(model_instance, 'history_id') or not model_instance.history_id:
        return None
    
    # Try to get existing history
    try:
        return History.objects.get(id=model_instance.history_id)
    except History.DoesNotExist:
        return None

def ensure_history_id(model_instance):
    """
    Ensure the model instance has a history_id
    
    Args:
        model_instance: Model instance 
        
    Returns:
        str: The history_id (existing or newly created)
    """
    if not hasattr(model_instance, 'history_id') or not model_instance.history_id:
        model_instance.history_id = generate_history_id(model_instance._meta.model_name)
        model_instance.save(update_fields=['history_id'])
    
    return model_instance.history_id

```

#----------------------------------------------------------------------------------------------------

# core\services\history\output.py =================================================

core\services\history\output.py:
```python
# Output history tracking
from core.models import Output
from django.utils import timezone
from core.services.history.initialization import (
    get_history, initialize_history, add_history_event, ensure_history_id
)

def record_output_creation(output):
    """
    Record output creation in history
    
    Args:
        output (Output): Created output
        
    Returns:
        History: Created history record
    """
    # Ensure output has a history_id
    ensure_history_id(output)
    
    # Initialize a new history record
    history = initialize_history(
        title=f"{output.template.name} for Phase {output.phase_id}",
        event_type="create",
        event_details=f"Output created based on template {output.template.id}",
        table_name='output',
        history_id=output.history_id
    )
    
    return history

def record_output_update(output, updated_fields):
    """
    Record output update in history
    
    Args:
        output (Output): Updated output
        updated_fields (list): List of fields that were updated
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(output)
    
    if not history:
        return None
        
    # Make sure title stays updated
    history.title = f"{output.template.name} for Phase {output.phase_id}"
    history.save(update_fields=['title'])
    
    # Add update event
    event_details = f"Output updated: {', '.join(updated_fields)}"
    
    return add_history_event(history, "update", event_details)

def record_output_status_change(output, old_status, new_status):
    """
    Record output status change in history
    
    Args:
        output (Output): Output object
        old_status (str): Previous status
        new_status (str): New status
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(output)
    
    if not history:
        return None
        
    # Make sure title stays updated
    history.title = f"{output.template.name} for Phase {output.phase_id}"
    history.save(update_fields=['title'])
    
    # Add status change event
    event_details = f"Output status changed from {old_status} to {new_status}"
    
    # Determine event type based on the new status
    event_type = "status_change"
    if new_status.lower() in ['completed', 'approved', 'finalized']:
        event_type = "complete"
    elif new_status.lower() in ['in_progress', 'started']:
        event_type = "start"
    elif new_status.lower() in ['review', 'under_review']:
        event_type = "review"
    
    return add_history_event(history, event_type, event_details)

def record_output_document_upload(output, document):
    """
    Record document upload for an output
    
    Args:
        output (Output): Output object
        document (Document): Uploaded document
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(output)
    
    if not history:
        return None
        
    # Make sure title stays updated
    history.title = f"{output.template.name} for Phase {output.phase_id}"
    history.save(update_fields=['title'])
    
    # Add document upload event
    event_details = f"Document '{document.name}' (version {document.version}) uploaded"
    
    return add_history_event(history, "document_upload", event_details)

def record_output_responsibility_change(output, old_user_id, new_user_id):
    """
    Record responsibility change for an output
    
    Args:
        output (Output): Output object
        old_user_id: ID of previous responsible user (can be None)
        new_user_id: ID of new responsible user (can be None)
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(output)
    
    if not history:
        return None
        
    # Make sure title stays updated
    history.title = f"{output.template.name} for Phase {output.phase_id}"
    history.save(update_fields=['title'])
    
    # Format user IDs for display
    old_username = "None" if not old_user_id else f"User {old_user_id}"
    new_username = "None" if not new_user_id else f"User {new_user_id}"
    
    # Determine event type and details
    if old_user_id is None and new_user_id is not None:
        event_type = "assign_responsible"
        event_details = f"Responsibility assigned to {new_username}"
    elif old_user_id is not None and new_user_id is None:
        event_type = "remove_responsible"
        event_details = f"Responsibility removed from {old_username}"
    else:
        event_type = "change_responsible"
        event_details = f"Responsibility changed from {old_username} to {new_username}"
    
    return add_history_event(history, event_type, event_details)

def record_output_deletion(output):
    """
    Record output deletion in history
    
    Args:
        output (Output): Output being deleted
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(output)
    
    if not history:
        return None
        
    # Make sure title stays updated
    history.title = f"{output.template.name} for Phase {output.phase_id}"
    history.save(update_fields=['title'])
    
    # Add deletion event
    event_details = f"Output deleted with ID {output.id}"
    
    return add_history_event(history, "delete", event_details)

def record_output_review(output, review_status, reviewer_id=None, comments=None):
    """
    Record output review in history
    
    Args:
        output (Output): Output object
        review_status (str): Review status
        reviewer_id (int, optional): ID of the reviewer
        comments (str, optional): Review comments
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(output)
    
    if not history:
        return None
        
    # Make sure title stays updated
    history.title = f"{output.template.name} for Phase {output.phase_id}"
    history.save(update_fields=['title'])
    
    # Create event details
    reviewer_info = f" by User {reviewer_id}" if reviewer_id else ""
    event_details = f"Output reviewed{reviewer_info} with status: {review_status}"
    if comments:
        event_details += f". Comments: {comments}"
    
    # Determine event type based on review status
    event_type = "review"
    if review_status.lower() in ['approved', 'accepted']:
        event_type = "approve"
    elif review_status.lower() in ['rejected', 'denied']:
        event_type = "reject"
    elif review_status.lower() in ['completed']:
        event_type = "complete"
    
    return add_history_event(history, event_type, event_details)

def record_output_deadline_change(output, old_deadline, new_deadline):
    """
    Record output deadline change in history
    
    Args:
        output (Output): Output object
        old_deadline: Previous deadline (datetime)
        new_deadline: New deadline (datetime)
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(output)
    
    if not history:
        return None
        
    # Make sure title stays updated
    history.title = f"{output.template.name} for Phase {output.phase_id}"
    
    # Update history deadline field
    history.deadline = new_deadline
    history.save(update_fields=['title', 'deadline'])
    
    # Format deadlines for display
    old_date = old_deadline.strftime("%Y-%m-%d") if old_deadline else "None"
    new_date = new_deadline.strftime("%Y-%m-%d") if new_deadline else "None"
    
    # Add deadline change event
    event_details = f"Output deadline changed from {old_date} to {new_date}"
    
    return add_history_event(history, "deadline_change", event_details)

def get_output_history(output_id):
    """
    Get history record for an output
    
    Args:
        output_id: Output ID
        
    Returns:
        History or None: Output history record if found, None otherwise
    """
    try:
        output = Output.objects.get(id=output_id)
        return get_history(output)
    except Output.DoesNotExist:
        return None

```

#----------------------------------------------------------------------------------------------------

# core\services\history\person.py =================================================

core\services\history\person.py:
```python
from core.models import Person
from django.utils import timezone
from core.services.history.initialization import (
    get_history, initialize_history, add_history_event, ensure_history_id
)

def record_person_creation(person):
    """
    Record person creation in history
    
    Args:
        person: Person object
        
    Returns:
        History: Created history record
    """
    # Ensure person has a history_id
    ensure_history_id(person)
    
    # Initialize a new history record
    history = initialize_history(
        title=f"{person.first_name} {person.last_name}",
        event_type="create",
        event_details=f"Person created with ID {person.id}",
        table_name='person',
        history_id=person.history_id
    )
    
    return history

def record_person_update(person, updated_fields):
    """
    Record person update in history
    
    Args:
        person: Person object
        updated_fields: List of updated field names
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(person)
    
    if not history:
        return None
    
    # Make sure title stays updated with current name
    history.title = f"{person.first_name} {person.last_name}"
    history.save(update_fields=['title'])
    
    # Add update event
    event_details = f"Person updated. Fields changed: {', '.join(updated_fields)}"
    
    return add_history_event(history, "update", event_details)

def record_person_name_change(person, old_first_name, old_last_name, new_first_name, new_last_name):
    """
    Record person name change in history
    
    Args:
        person: Person object
        old_first_name: Previous first name
        old_last_name: Previous last name
        new_first_name: New first name
        new_last_name: New last name
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(person)
    
    if not history:
        return None
    
    # Update the title to reflect the new name
    history.title = f"{new_first_name} {new_last_name}"
    history.save(update_fields=['title'])
    
    # Add name change event
    old_full_name = f"{old_first_name} {old_last_name}"
    new_full_name = f"{new_first_name} {new_last_name}"
    event_details = f"Person name changed from '{old_full_name}' to '{new_full_name}'"
    
    return add_history_event(history, "name_change", event_details)

def record_person_team_change(person, old_team_id, new_team_id):
    """
    Record person team change in history
    
    Args:
        person: Person object
        old_team_id: ID of previous team (None if added to team)
        new_team_id: ID of new team (None if removed from team)
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(person)
    
    if not history:
        return None
    
    # Determine event type and details based on the change
    if old_team_id is None and new_team_id is not None:
        event_type = "team_assignment"
        event_details = f"Person added to team with ID {new_team_id}"
    elif old_team_id is not None and new_team_id is None:
        event_type = "team_removal"
        event_details = f"Person removed from team with ID {old_team_id}"
    else:
        event_type = "team_transfer"
        event_details = f"Person moved from team with ID {old_team_id} to team with ID {new_team_id}"
    
    return add_history_event(history, event_type, event_details)

def record_person_department_change(person, old_department_id, new_department_id):
    """
    Record person department change in history
    
    Args:
        person: Person object
        old_department_id: ID of previous department (None if first assignment)
        new_department_id: ID of new department (None if removed from department)
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(person)
    
    if not history:
        return None
    
    # Determine event type and details based on the change
    if old_department_id is None and new_department_id is not None:
        event_type = "department_assignment"
        event_details = f"Person assigned to department with ID {new_department_id}"
    elif old_department_id is not None and new_department_id is None:
        event_type = "department_removal"
        event_details = f"Person removed from department with ID {old_department_id}"
    else:
        event_type = "department_transfer"
        event_details = f"Person moved from department with ID {old_department_id} to department with ID {new_department_id}"
    
    return add_history_event(history, event_type, event_details)

def record_person_role_change(person, old_role, new_role):
    """
    Record person role change in history
    
    Args:
        person: Person object
        old_role: Previous role
        new_role: New role
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(person)
    
    if not history:
        return None
    
    # Add role change event
    event_details = f"Person role changed from '{old_role}' to '{new_role}'"
    
    return add_history_event(history, "role_change", event_details)

def record_person_contact_info_change(person, field_name, old_value, new_value):
    """
    Record person contact information change in history
    
    Args:
        person: Person object
        field_name: Name of the contact field (email, phone, etc.)
        old_value: Previous value
        new_value: New value
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(person)
    
    if not history:
        return None
    
    # Add contact info change event
    event_details = f"Person {field_name} changed from '{old_value}' to '{new_value}'"
    
    return add_history_event(history, f"{field_name}_change", event_details)

def record_person_status_change(person, old_status, new_status):
    """
    Record person status change in history
    
    Args:
        person: Person object
        old_status: Previous status
        new_status: New status
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(person)
    
    if not history:
        return None
    
    # Add status change event
    event_details = f"Person status changed from '{old_status}' to '{new_status}'"
    
    # Determine event type based on status
    event_type = "status_change"
    if new_status.lower() in ['active']:
        event_type = "activate"
    elif new_status.lower() in ['inactive', 'on_leave']:
        event_type = "deactivate"
    elif new_status.lower() in ['retired', 'terminated']:
        event_type = "terminate"
    
    return add_history_event(history, event_type, event_details)

def record_person_deletion(person):
    """
    Record person deletion in history
    
    Args:
        person: Person object
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(person)
    
    if not history:
        return None
    
    # Add deletion event
    event_details = f"Person deleted with ID {person.id}"
    
    return add_history_event(history, "delete", event_details)

def get_person_history(person_id):
    """
    Get history record for a person
    
    Args:
        person_id (int): Person ID
    
    Returns:
        History or None: Person history record if found, None otherwise
    """
    try:
        person = Person.objects.get(id=person_id)
        return get_history(person)
    except Person.DoesNotExist:
        return None

```

#----------------------------------------------------------------------------------------------------

# core\services\history\phase.py ==================================================

core\services\history\phase.py:
```python
# Phase history tracking
from core.models import Phase
from django.utils import timezone
import uuid
import json
from core.services.history.initialization import (
    get_history, initialize_history, add_history_event, ensure_history_id
)

def record_phase_creation(phase):
    """
    Record phase creation in history
    
    Args:
        phase (Phase): Created phase
        
    Returns:
        History: Created history record
    """
    from core.services.history.initialization import initialize_history
    
    history = initialize_history(
        title=phase.template.name,  # FIXED
        event_type="create",
        event_details=f"Phase created for PPAP {phase.ppap_id}",
        table_name='phase',
        history_id=phase.history_id
    )
    
    return history

def record_phase_update(phase, updated_fields=None):
    """
    Record phase update in history
    
    Args:
        phase (Phase): Updated phase
        updated_fields (list, optional): List of updated fields
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(phase)
    
    if not history:
        return None
    
    # Make sure title stays updated
    history.title = f"{phase.template.name} for PPAP {phase.ppap_id}"
    history.save(update_fields=['title'])
    
    # Add update event
    if updated_fields:
        event_details = f"Phase updated. Fields changed: {', '.join(updated_fields)}"
    else:
        event_details = "Phase updated."
    
    return add_history_event(history, "update", event_details)

def record_phase_status_change(phase, old_status, new_status):
    """
    Record phase status change in history
    
    Args:
        phase (Phase): Phase object
        old_status (str): Previous status
        new_status (str): New status
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(phase)
    
    if not history:
        return None
    
    # Add status change event
    event_details = f"Phase status changed from '{old_status}' to '{new_status}'"
    
    # Determine event type based on the new status
    event_type = "status_change"
    if new_status.lower() in ['completed', 'approved', 'finalized']:
        event_type = "complete"
    elif new_status.lower() in ['in_progress', 'started']:
        event_type = "start"
    elif new_status.lower() == 'not started':
        event_type = "reset"
    elif new_status.lower() in ['review', 'under_review']:
        event_type = "review"
    
    return add_history_event(history, event_type, event_details)

def record_phase_responsible_change(phase, old_responsible_id, new_responsible_id):
    """
    Record phase responsible person change in history
    
    Args:
        phase (Phase): Phase object
        old_responsible_id: ID of previous responsible person (can be None)
        new_responsible_id: ID of new responsible person (can be None)
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(phase)
    
    if not history:
        return None
    
    # Format user IDs for display
    old_username = "None" if old_responsible_id is None else f"User {old_responsible_id}"
    new_username = "None" if new_responsible_id is None else f"User {new_responsible_id}"
    
    # Determine event type and details
    if old_responsible_id is None and new_responsible_id is not None:
        event_type = "assign_responsible"
        event_details = f"Responsibility assigned to {new_username}"
    elif old_responsible_id is not None and new_responsible_id is None:
        event_type = "remove_responsible"
        event_details = f"Responsibility removed from {old_username}"
    else:
        event_type = "change_responsible"
        event_details = f"Responsibility changed from {old_username} to {new_username}"
    
    return add_history_event(history, event_type, event_details)

def record_phase_output_addition(phase, output):
    """
    Record addition of output to phase
    
    Args:
        phase (Phase): Phase object
        output: Output added to phase
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(phase)
    
    if not history:
        return None
    
    # Add output addition event
    event_details = f"Output '{output.template.name}' (ID: {output.id}) added to phase"
    
    return add_history_event(history, "output_add", event_details)

def record_phase_output_completion(phase, output):
    """
    Record completion of output in phase
    
    Args:
        phase (Phase): Phase object
        output: Completed output
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(phase)
    
    if not history:
        return None
    
    # Add output completion event
    event_details = f"Output '{output.template.name}' (ID: {output.id}) completed"
    
    return add_history_event(history, "output_complete", event_details)

def record_phase_deadline_change(phase, old_deadline, new_deadline):
    """
    Record phase deadline change
    
    Args:
        phase (Phase): Phase object
        old_deadline: Previous deadline (datetime)
        new_deadline: New deadline (datetime)
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(phase)
    
    if not history:
        return None
    
    # Update history deadline field
    history.deadline = new_deadline
    
    # Format deadlines for display
    old_date = old_deadline.strftime("%Y-%m-%d") if old_deadline else "None"
    new_date = new_deadline.strftime("%Y-%m-%d") if new_deadline else "None"
    
    # Add deadline change event
    event_details = f"Phase deadline changed from {old_date} to {new_date}"
    
    # Save the history with the deadline update
    history.save(update_fields=['deadline'])
    
    return add_history_event(history, "deadline_change", event_details)

def record_phase_review(phase, review_status, reviewer_id=None, comments=None):
    """
    Record phase review in history
    
    Args:
        phase (Phase): Phase object
        review_status (str): Review status
        reviewer_id (int, optional): ID of the reviewer
        comments (str, optional): Review comments
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(phase)
    
    if not history:
        return None
    
    # Create event details
    reviewer_info = f" by User {reviewer_id}" if reviewer_id else ""
    event_details = f"Phase reviewed{reviewer_info} with status: {review_status}"
    if comments:
        event_details += f". Comments: {comments}"
    
    # Determine event type based on review status
    event_type = "review"
    if review_status.lower() in ['approved', 'accepted']:
        event_type = "approve"
    elif review_status.lower() in ['rejected', 'denied']:
        event_type = "reject"
    elif review_status.lower() in ['completed']:
        event_type = "complete"
    
    return add_history_event(history, event_type, event_details)

def record_phase_deletion(phase):
    """
    Record phase deletion in history
    
    Args:
        phase (Phase): Phase being deleted
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(phase)
    
    if not history:
        return None
    
    # Add deletion event
    event_details = f"Phase deleted with ID {phase.id}"
    
    return add_history_event(history, "delete", event_details)

def get_phase_history(phase_id):
    """
    Get history record for a phase
    
    Args:
        phase_id: Phase ID
        
    Returns:
        History or None: Phase history record if found, None otherwise
    """
    try:
        phase = Phase.objects.get(id=phase_id)
        return get_history(phase)
    except Phase.DoesNotExist:
        return None

def record_phase_outputs_progress(phase, total_outputs, completed_outputs):
    """
    Record progress of outputs completion in a phase
    
    Args:
        phase (Phase): Phase object
        total_outputs (int): Total number of outputs in the phase
        completed_outputs (int): Number of completed outputs
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(phase)
    
    if not history:
        return None
    
    # Calculate completion percentage
    completion_percentage = int((completed_outputs / total_outputs) * 100) if total_outputs > 0 else 0
    
    # Add progress event
    event_details = f"Phase progress: {completed_outputs}/{total_outputs} outputs completed ({completion_percentage}%)"
    
    return add_history_event(history, "progress_update", event_details)

```

#----------------------------------------------------------------------------------------------------

# core\services\history\ppap.py ===================================================

core\services\history\ppap.py:
```python
# PPAP history tracking
from core.models import PPAP
from django.utils import timezone
from core.services.history.initialization import (
    get_history, initialize_history, add_history_event, ensure_history_id
)

def record_ppap_creation(ppap):
    """
    Record PPAP creation in history
    
    Args:
        ppap (PPAP): Created PPAP
        
    Returns:
        History: Created history record
    """
    # Ensure PPAP has a history_id
    ensure_history_id(ppap)
    
    # Initialize a new history record
    history = initialize_history(
        title=f"PPAP for Project {ppap.project_id}",
        event_type="create",
        event_details=f"PPAP created with level {ppap.level}",
        table_name='ppap',
        history_id=ppap.history_id
    )
    
    return history

def record_ppap_update(ppap, updated_fields):
    """
    Record PPAP update in history
    
    Args:
        ppap (PPAP): Updated PPAP
        updated_fields (list): List of updated fields
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(ppap)
    
    if not history:
        return None
    
    # Make sure title stays updated
    history.title = f"PPAP for Project {ppap.project_id}"
    history.save(update_fields=['title'])
    
    # Add update event
    event_details = f"PPAP updated: {', '.join(updated_fields)}"
    
    return add_history_event(history, "update", event_details)

def record_ppap_level_change(ppap, old_level, new_level):
    """
    Record PPAP level change in history
    
    Args:
        ppap (PPAP): PPAP object
        old_level (int): Previous PPAP level
        new_level (int): New PPAP level
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(ppap)
    
    if not history:
        return None
    
    # Add level change event
    event_details = f"PPAP level changed from {old_level} to {new_level}"
    
    return add_history_event(history, "level_change", event_details)

def record_ppap_status_change(ppap, old_status, new_status):
    """
    Record PPAP status change in history
    
    Args:
        ppap (PPAP): PPAP object
        old_status (str): Previous status
        new_status (str): New status
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(ppap)
    
    if not history:
        return None
    
    # Add status change event
    event_details = f"PPAP status changed from '{old_status}' to '{new_status}'"
    
    # Determine event type based on the new status
    event_type = "status_change"
    if new_status.lower() in ['completed', 'approved', 'finalized']:
        event_type = "complete"
    elif new_status.lower() in ['in_progress', 'started']:
        event_type = "start"
    elif new_status.lower() in ['review', 'under_review']:
        event_type = "review"
    
    return add_history_event(history, event_type, event_details)

def record_ppap_phase_completion(ppap, phase):
    """
    Record completion of a phase in PPAP
    
    Args:
        ppap (PPAP): PPAP object
        phase: Completed phase
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(ppap)
    
    if not history:
        return None
    
    # Add phase completion event
    event_details = f"Phase '{phase.template.name}' (ID: {phase.id}) completed"
    
    return add_history_event(history, "phase_complete", event_details)

def record_ppap_customer_submission(ppap, submission_date=None):
    """
    Record PPAP submission to customer
    
    Args:
        ppap (PPAP): PPAP object
        submission_date (datetime, optional): Date of submission (defaults to now)
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(ppap)
    
    if not history:
        return None
    
    # Use provided date or default to now
    if submission_date is None:
        submission_date = timezone.now()
    
    # Format date for display
    formatted_date = submission_date.strftime("%Y-%m-%d")
    
    # Add submission event
    event_details = f"PPAP submitted to customer on {formatted_date}"
    
    return add_history_event(history, "customer_submission", event_details)

def record_ppap_customer_decision(ppap, decision, comments=None):
    """
    Record customer decision on PPAP
    
    Args:
        ppap (PPAP): PPAP object
        decision (str): Customer decision (approved, rejected, etc.)
        comments (str, optional): Customer comments
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(ppap)
    
    if not history:
        return None
    
    # Add customer decision event
    event_details = f"Customer decision: {decision}"
    if comments:
        event_details += f". Comments: {comments}"
    
    # Determine event type based on decision
    event_type = "customer_decision"
    if decision.lower() in ['approved', 'accepted']:
        event_type = "approve"
    elif decision.lower() in ['rejected', 'denied']:
        event_type = "reject"
    elif decision.lower() in ['conditional', 'interim']:
        event_type = "conditional_approve"
    
    return add_history_event(history, event_type, event_details)

def record_ppap_deadline_change(ppap, old_deadline, new_deadline):
    """
    Record PPAP deadline change
    
    Args:
        ppap (PPAP): PPAP object
        old_deadline (datetime): Previous deadline
        new_deadline (datetime): New deadline
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(ppap)
    
    if not history:
        return None
    
    # Update history deadline field
    history.deadline = new_deadline
    
    # Format deadlines for display
    old_date = old_deadline.strftime("%Y-%m-%d") if old_deadline else "None"
    new_date = new_deadline.strftime("%Y-%m-%d") if new_deadline else "None"
    
    # Add deadline change event
    event_details = f"PPAP deadline changed from {old_date} to {new_date}"
    
    # Save the history with the deadline update
    history.save(update_fields=['deadline'])
    
    return add_history_event(history, "deadline_change", event_details)

def record_ppap_deletion(ppap):
    """
    Record PPAP deletion in history
    
    Args:
        ppap (PPAP): PPAP being deleted
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(ppap)
    
    if not history:
        return None
    
    # Add deletion event
    event_details = f"PPAP deleted with ID {ppap.id}"
    
    return add_history_event(history, "delete", event_details)

def get_ppap_history(ppap_id):
    """
    Get history record for a PPAP
    
    Args:
        ppap_id: PPAP ID
        
    Returns:
        History or None: PPAP history record if found, None otherwise
    """
    try:
        ppap = PPAP.objects.get(id=ppap_id)
        return get_history(ppap)
    except PPAP.DoesNotExist:
        return None

def record_ppap_progress(ppap, total_phases, completed_phases):
    """
    Record progress of phases completion in a PPAP
    
    Args:
        ppap (PPAP): PPAP object
        total_phases (int): Total number of phases
        completed_phases (int): Number of completed phases
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(ppap)
    
    if not history:
        return None
    
    # Calculate completion percentage
    completion_percentage = int((completed_phases / total_phases) * 100) if total_phases > 0 else 0
    
    # Add progress event
    event_details = f"PPAP progress: {completed_phases}/{total_phases} phases completed ({completion_percentage}%)"
    
    return add_history_event(history, "progress_update", event_details)

```

#----------------------------------------------------------------------------------------------------

# core\services\history\project.py ================================================

core\services\history\project.py:
```python
# Project history tracking
from core.models import Project
from django.utils import timezone
from core.services.history.initialization import (
    get_history, initialize_history, add_history_event, ensure_history_id
)

def record_project_creation(project):
    """
    Record project creation in history
    
    Args:
        project (Project): Created project
        
    Returns:
        History: Created history record
    """
    # Ensure project has a history_id
    ensure_history_id(project)
    
    # Initialize a new history record
    history = initialize_history(
        title=project.name,
        event_type="create",
        event_details=f"Project created with ID {project.id}",
        table_name='project',
        history_id=project.history_id
    )
    
    return history

def record_project_update(project, updated_fields):
    """
    Record project update in history
    
    Args:
        project (Project): Updated project
        updated_fields (list): List of updated fields
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(project)
    
    if not history:
        return None
    
    # Make sure title stays updated
    history.title = project.name
    history.save(update_fields=['title'])
    
    # Add update event
    event_details = f"Project updated: {', '.join(updated_fields)}"
    
    return add_history_event(history, "update", event_details)

def record_project_name_change(project, old_name, new_name):
    """
    Record project name change in history
    
    Args:
        project (Project): Project object
        old_name (str): Previous project name
        new_name (str): New project name
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(project)
    
    if not history:
        return None
    
    # Update the title to reflect the new name
    history.title = new_name
    history.save(update_fields=['title'])
    
    # Add name change event
    event_details = f"Project name changed from '{old_name}' to '{new_name}'"
    
    return add_history_event(history, "name_change", event_details)

def record_project_status_change(project, old_status, new_status):
    """
    Record project status change in history
    
    Args:
        project (Project): Project object
        old_status (str): Previous status
        new_status (str): New status
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(project)
    
    if not history:
        return None
    
    # Add status change event
    event_details = f"Project status changed from '{old_status}' to '{new_status}'"
    
    # Determine event type based on status
    event_type = "status_change"
    if new_status.lower() in ['active', 'started']:
        event_type = "activate"
    elif new_status.lower() in ['on_hold', 'paused']:
        event_type = "pause"
    elif new_status.lower() in ['completed', 'finished']:
        event_type = "complete"
    elif new_status.lower() in ['canceled']:
        event_type = "cancel"
    
    return add_history_event(history, event_type, event_details)

def record_project_customer_change(project, old_customer_id, new_customer_id):
    """
    Record project customer change in history
    
    Args:
        project (Project): Project object
        old_customer_id: ID of previous customer
        new_customer_id: ID of new customer
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(project)
    
    if not history:
        return None
    
    # Add customer change event
    event_details = f"Project customer changed from ID {old_customer_id} to ID {new_customer_id}"
    
    return add_history_event(history, "customer_change", event_details)

def record_project_team_member_addition(project, user_id, role=None):
    """
    Record addition of team member to project
    
    Args:
        project (Project): Project object
        user_id: ID of added user
        role (str, optional): Role of the team member
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(project)
    
    if not history:
        return None
    
    # Add team member addition event
    role_info = f" as {role}" if role else ""
    event_details = f"User {user_id} added to project{role_info}"
    
    return add_history_event(history, "team_member_add", event_details)

def record_project_team_member_removal(project, user_id):
    """
    Record removal of team member from project
    
    Args:
        project (Project): Project object
        user_id: ID of removed user
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(project)
    
    if not history:
        return None
    
    # Add team member removal event
    event_details = f"User {user_id} removed from project"
    
    return add_history_event(history, "team_member_remove", event_details)

def record_project_ppap_creation(project, ppap_id):
    """
    Record PPAP creation for project
    
    Args:
        project (Project): Project object
        ppap_id: ID of created PPAP
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(project)
    
    if not history:
        return None
    
    # Add PPAP creation event
    event_details = f"PPAP created with ID {ppap_id} for project"
    
    return add_history_event(history, "ppap_create", event_details)

def record_project_deadline_change(project, old_deadline, new_deadline):
    """
    Record project deadline change
    
    Args:
        project (Project): Project object
        old_deadline (datetime): Previous deadline
        new_deadline (datetime): New deadline
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(project)
    
    if not history:
        return None
    
    # Update history deadline field
    history.deadline = new_deadline
    
    # Format deadlines for display
    old_date = old_deadline.strftime("%Y-%m-%d") if old_deadline else "None"
    new_date = new_deadline.strftime("%Y-%m-%d") if new_deadline else "None"
    
    # Add deadline change event
    event_details = f"Project deadline changed from {old_date} to {new_date}"
    
    # Save the history with the deadline update
    history.save(update_fields=['deadline'])
    
    return add_history_event(history, "deadline_change", event_details)

def record_project_deletion(project):
    """
    Record project deletion in history
    
    Args:
        project (Project): Project being deleted
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(project)
    
    if not history:
        return None
    
    # Add deletion event
    event_details = f"Project deleted with ID {project.id}"
    
    return add_history_event(history, "delete", event_details)

def get_project_history(project_id):
    """
    Get history record for a project
    
    Args:
        project_id: Project ID
        
    Returns:
        History or None: Project history record if found, None otherwise
    """
    try:
        project = Project.objects.get(id=project_id)
        return get_history(project)
    except Project.DoesNotExist:
        return None

```

#----------------------------------------------------------------------------------------------------

# core\services\history\team.py ===================================================

core\services\history\team.py:
```python
from core.models import Team
from django.utils import timezone
from core.services.history.initialization import (
    get_history, initialize_history, add_history_event, ensure_history_id
)

def record_team_creation(team):
    """
    Record team creation in history
    
    Args:
        team: Team object
        
    Returns:
        History: Created history record
    """
    # Ensure team has a history_id
    ensure_history_id(team)
    
    # Initialize a new history record
    history = initialize_history(
        title=team.name,
        event_type="create",
        event_details=f"Team created with ID {team.id}",
        table_name='team',
        history_id=team.history_id
    )
    
    return history

def record_team_update(team, updated_fields):
    """
    Record team update in history
    
    Args:
        team: Team object
        updated_fields: List of updated field names
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(team)
    
    if not history:
        return None
    
    # Make sure title stays updated
    history.title = team.name
    history.save(update_fields=['title'])
    
    # Add update event
    event_details = f"Team updated. Fields changed: {', '.join(updated_fields)}"
    
    return add_history_event(history, "update", event_details)

def record_team_name_change(team, old_name, new_name):
    """
    Record team name change in history
    
    Args:
        team: Team object
        old_name: Previous team name
        new_name: New team name
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(team)
    
    if not history:
        return None
    
    # Update the title to reflect the new name
    history.title = new_name
    history.save(update_fields=['title'])
    
    # Add name change event
    event_details = f"Team name changed from '{old_name}' to '{new_name}'"
    
    return add_history_event(history, "name_change", event_details)

def record_team_member_addition(team, person_id):
    """
    Record team member addition in history
    
    Args:
        team: Team object
        person_id: ID of person added to team
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(team)
    
    if not history:
        return None
    
    # Add member addition event
    event_details = f"Person with ID {person_id} added to team"
    
    return add_history_event(history, "member_add", event_details)

def record_team_member_removal(team, person_id):
    """
    Record team member removal in history
    
    Args:
        team: Team object
        person_id: ID of person removed from team
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(team)
    
    if not history:
        return None
    
    # Add member removal event
    event_details = f"Person with ID {person_id} removed from team"
    
    return add_history_event(history, "member_remove", event_details)

def record_team_lead_change(team, old_lead_id, new_lead_id):
    """
    Record team lead change in history
    
    Args:
        team: Team object
        old_lead_id: ID of previous team lead (can be None)
        new_lead_id: ID of new team lead (can be None)
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(team)
    
    if not history:
        return None
    
    # Determine event details based on the change
    if old_lead_id is None and new_lead_id is not None:
        event_details = f"Team lead assigned: Person {new_lead_id}"
        event_type = "lead_assign"
    elif old_lead_id is not None and new_lead_id is None:
        event_details = f"Team lead removed: Person {old_lead_id}"
        event_type = "lead_remove"
    else:
        event_details = f"Team lead changed from Person {old_lead_id} to Person {new_lead_id}"
        event_type = "lead_change"
    
    return add_history_event(history, event_type, event_details)

def record_team_department_assignment(team, department_id):
    """
    Record team assignment to department in history
    
    Args:
        team: Team object
        department_id: Department ID
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(team)
    
    if not history:
        return None
    
    # Add department assignment event
    event_details = f"Team assigned to Department {department_id}"
    
    return add_history_event(history, "department_assign", event_details)

def record_team_department_removal(team, department_id):
    """
    Record team removal from department in history
    
    Args:
        team: Team object
        department_id: Department ID
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(team)
    
    if not history:
        return None
    
    # Add department removal event
    event_details = f"Team removed from Department {department_id}"
    
    return add_history_event(history, "department_remove", event_details)

def record_team_deletion(team):
    """
    Record team deletion in history
    
    Args:
        team: Team object
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(team)
    
    if not history:
        return None
    
    # Add deletion event
    event_details = f"Team deleted with ID {team.id}"
    
    return add_history_event(history, "delete", event_details)

def get_team_history(team_id):
    """
    Get history record for a team
    
    Args:
        team_id (int): Team ID
    
    Returns:
        History or None: Team history record if found, None otherwise
    """
    try:
        team = Team.objects.get(id=team_id)
        return get_history(team)
    except Team.DoesNotExist:
        return None

```

#----------------------------------------------------------------------------------------------------

# core\services\history\user.py ===================================================

core\services\history\user.py:
```python
# User history tracking
from core.models import User
from django.utils import timezone
from core.services.history.initialization import (
    get_history, initialize_history, add_history_event, ensure_history_id
)

def record_user_creation(user):
    """
    Record user creation in history
    
    Args:
        user (User): Created user
        
    Returns:
        History: Created history record
    """
    # Ensure user has a history_id
    ensure_history_id(user)
    
    # Initialize a new history record
    history = initialize_history(
        title=user.username,
        event_type="create",
        event_details=f"User created with ID {user.id}",
        table_name='user',
        history_id=user.history_id
    )
    
    return history

def record_user_update(user, updated_fields):
    """
    Record user update in history
    
    Args:
        user (User): Updated user
        updated_fields (list): List of updated fields
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(user)
    
    if not history:
        return None
    
    # Make sure title stays updated
    history.title = user.username
    history.save(update_fields=['title'])
    
    # Add update event
    event_details = f"User updated: {', '.join(updated_fields)}"
    
    return add_history_event(history, "update", event_details)

def record_user_login(user):
    """
    Record user login in history
    
    Args:
        user (User): User who logged in
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(user)
    
    if not history:
        return None
    
    # Add login event
    event_details = f"User logged in at {user.last_login}"
    
    return add_history_event(history, "login", event_details)

def record_user_logout(user):
    """
    Record user logout in history
    
    Args:
        user (User): User who logged out
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(user)
    
    if not history:
        return None
    
    # Add logout event
    event_details = f"User logged out at {timezone.now()}"
    
    return add_history_event(history, "logout", event_details)

def record_user_password_change(user):
    """
    Record user password change in history
    
    Args:
        user (User): User who changed password
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(user)
    
    if not history:
        return None
    
    # Add password change event
    event_details = "User password changed"
    
    return add_history_event(history, "password_change", event_details)

def record_user_role_change(user, old_role, new_role):
    """
    Record user role change in history
    
    Args:
        user (User): User whose role changed
        old_role (str): Previous role
        new_role (str): New role
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(user)
    
    if not history:
        return None
    
    # Add role change event
    event_details = f"User role changed from '{old_role}' to '{new_role}'"
    
    return add_history_event(history, "role_change", event_details)

def record_user_email_change(user, old_email, new_email):
    """
    Record user email change in history
    
    Args:
        user (User): User whose email changed
        old_email (str): Previous email
        new_email (str): New email
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(user)
    
    if not history:
        return None
    
    # Add email change event
    event_details = f"User email changed from '{old_email}' to '{new_email}'"
    
    return add_history_event(history, "email_change", event_details)

def record_user_name_change(user, old_name, new_name):
    """
    Record user name change in history
    
    Args:
        user (User): User whose name changed
        old_name (str): Previous display name
        new_name (str): New display name
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(user)
    
    if not history:
        return None
    
    # Add name change event
    event_details = f"User name changed from '{old_name}' to '{new_name}'"
    
    return add_history_event(history, "name_change", event_details)

def record_user_deletion(user):
    """
    Record user deletion in history
    
    Args:
        user (User): User being deleted
        
    Returns:
        History: Updated history record or None if no history exists
    """
    # Get existing history record
    history = get_history(user)
    
    if not history:
        return None
    
    # Add deletion event
    event_details = f"User deleted with ID {user.id}"
    
    return add_history_event(history, "delete", event_details)

def get_user_history(user_id):
    """
    Get history record for a user
    
    Args:
        user_id: User ID
        
    Returns:
        History or None: User history record if found, None otherwise
    """
    try:
        user = User.objects.get(id=user_id)
        return get_history(user)
    except User.DoesNotExist:
        return None

```

#----------------------------------------------------------------------------------------------------

# core\services\logic\__init__.py =================================================

core\services\logic\__init__.py:
```python
# Logic services

```

#----------------------------------------------------------------------------------------------------

# core\services\logic\api.py ======================================================

core\services\logic\api.py:
```python
# Define all API here
from core.services.logic.level import (
    filter_outputs_by_level,
    get_visible_outputs_for_user,
    get_dashboard_items_by_level
)
from core.services.logic.permission import (
    assign_permission,
    check_permission,
    get_user_permissions
)
from core.services.logic.status import (
    change_project_status,
    change_ppap_status,
    change_phase_status,
    change_output_status
)
from core.services.logic.todo import (
    create_todo,
    assign_todos_for_phase,
    get_user_todos,
    get_pending_todos
)
from core.services.logic.authorization import (
    check_user_authorization,
    check_output_permission,
    get_user_authorization_details
)

# Export all functions for use in views
__all__ = [
    'filter_outputs_by_level',
    'get_visible_outputs_for_user',
    'get_dashboard_items_by_level',
    'assign_permission',
    'check_permission',
    'get_user_permissions',
    'change_project_status',
    'change_ppap_status',
    'change_phase_status',
    'change_output_status',
    'create_todo',
    'assign_todos_for_phase',
    'get_user_todos',
    'get_pending_todos',
    'check_user_authorization',
    'check_output_permission',
    'get_user_authorization_details'
]

```

#----------------------------------------------------------------------------------------------------

# core\services\logic\authorization.py ============================================

core\services\logic\authorization.py:
```python
# Authorization logic
from core.models import User, Authorization, Project, PPAP, Phase, Output

def check_user_authorization(user_id, action, entity_type, entity_id=None):
    """
    Check if a user is authorized to perform an action on an entity
    
    Actions: create, read, update, delete
    Entity types: project, ppap, phase, output, document, user, client, team
    """
    user = User.objects.get(id=user_id)
    authorization = user.authorization.name
    
    # Admin can do anything
    if authorization == 'admin':
        return True
    
    # Create users can create/read/update/delete most entities
    if authorization == 'create':
        # Create users cannot delete admin users
        if action == 'delete' and entity_type == 'user' and entity_id:
            target_user = User.objects.get(id=entity_id)
            if target_user.authorization.name == 'admin':
                return False
        
        return True
    
    # Edit users have limited permissions
    if authorization == 'edit':
        # Edit users can read most entities
        if action == 'read':
            # For outputs, check specific permissions
            if entity_type == 'output' and entity_id:
                return check_output_permission(user_id, entity_id, 'r')
            
            # For documents, check output permission
            if entity_type == 'document' and entity_id:
                from core.models import Document
                document = Document.objects.get(id=entity_id)
                return check_output_permission(user_id, document.output_id, 'r')
            
            return True
        
        # Edit users can update outputs they are responsible for
        if action == 'update':
            if entity_type == 'output' and entity_id:
                return check_output_permission(user_id, entity_id, 'e')
            
            if entity_type == 'document' and entity_id:
                from core.models import Document
                document = Document.objects.get(id=entity_id)
                return check_output_permission(user_id, document.output_id, 'e')
            
            if entity_type == 'phase' and entity_id:
                phase = Phase.objects.get(id=entity_id)
                return phase.responsible_id == user_id
            
            # Edit users cannot update other entity types
            return False
        
        # Edit users can create documents for outputs they are responsible for
        if action == 'create' and entity_type == 'document':
            # entity_id here is the output_id
            if entity_id:
                return check_output_permission(user_id, entity_id, 'e')
            
            return False
        
        # Edit users cannot delete or create other entity types
        return False
    
    # Default: not authorized
    return False

def check_output_permission(user_id, output_id, required_permission='r'):
    """
    Check if a user has the required permission for an output
    """
    from core.services.logic.permission import check_permission
    return check_permission(user_id, output_id, required_permission)

def get_user_authorization_details(user_id):
    """
    Get detailed authorization information for a user
    """
    user = User.objects.get(id=user_id)
    authorization = user.authorization.name
    
    # Get permissions based on authorization level
    permissions = {
        'admin': {
            'can_create': ['project', 'ppap', 'phase', 'output', 'document', 'user', 'client', 'team'],
            'can_read': ['project', 'ppap', 'phase', 'output', 'document', 'user', 'client', 'team'],
            'can_update': ['project', 'ppap', 'phase', 'output', 'document', 'user', 'client', 'team'],
            'can_delete': ['project', 'ppap', 'phase', 'output', 'document', 'user', 'client', 'team']
        },
        'create': {
            'can_create': ['project', 'ppap', 'phase', 'output', 'document', 'user', 'client', 'team'],
            'can_read': ['project', 'ppap', 'phase', 'output', 'document', 'user', 'client', 'team'],
            'can_update': ['project', 'ppap', 'phase', 'output', 'document', 'user', 'client', 'team'],
            'can_delete': ['project', 'ppap', 'phase', 'output', 'document', 'user', 'client', 'team']
        },
        'edit': {
            'can_create': ['document'],
            'can_read': ['project', 'ppap', 'phase', 'output', 'document', 'user', 'client', 'team'],
            'can_update': [],  # Will be populated with specific outputs
            'can_delete': []
        }
    }
    
    # For edit users, get specific output permissions
    if authorization == 'edit':
        from core.models import Todo
        todos = Todo.objects.filter(user_id=user_id)
        
        for todo in todos:
            if todo.permission.name == 'e':
                if 'output' not in permissions['edit']['can_update']:
                    permissions['edit']['can_update'].append('output')
                
                if 'document' not in permissions['edit']['can_update']:
                    permissions['edit']['can_update'].append('document')
        
        # Check if user is responsible for any phases
        responsible_phases = Phase.objects.filter(responsible_id=user_id)
        if responsible_phases.exists() and 'phase' not in permissions['edit']['can_update']:
            permissions['edit']['can_update'].append('phase')
    
    return {
        'user_id': user_id,
        'username': user.username,
        'authorization_level': authorization,
        'permissions': permissions[authorization]
    }

```

#----------------------------------------------------------------------------------------------------

# core\services\logic\level.py ====================================================

core\services\logic\level.py:
```python
# Define level logic to only display to the user what he needs base on the level
from core.models import PPAP, Phase, Output, PPAPElement

def filter_outputs_by_level(ppap_level):
    """
    Filter outputs based on PPAP level
    """
    # Get PPAP elements for this level
    elements = PPAPElement.objects.filter(level__contains=str(ppap_level))
    
    # Get output templates for these elements
    output_templates = []
    for element in elements:
        templates = element.output_templates.all()
        output_templates.extend(templates)
    
    return output_templates

def get_visible_outputs_for_user(user, ppap_id):
    """
    Get outputs visible to a user based on PPAP level and permissions
    """
    ppap = PPAP.objects.get(id=ppap_id)
    level = ppap.level
    
    # Get all phases for this PPAP
    phases = Phase.objects.filter(ppap_id=ppap_id)
    
    visible_outputs = []
    
    # Check user's authorization level
    authorization = user.authorization.name
    
    # Admin and create users can see everything
    if authorization in ['admin', 'create']:
        for phase in phases:
            outputs = Output.objects.filter(phase=phase)
            visible_outputs.extend(outputs)
        return visible_outputs
    
    # For edit users, check specific permissions
    for phase in phases:
        # Get todos for this user
        todos = user.todos.filter(output__phase=phase)
        
        # Get outputs where user has edit permission
        edit_output_ids = todos.filter(permission__name='e').values_list('output_id', flat=True)
        edit_outputs = Output.objects.filter(id__in=edit_output_ids)
        visible_outputs.extend(edit_outputs)
        
        # Get outputs in the same phase where user has read permission
        read_output_ids = todos.filter(permission__name='r').values_list('output_id', flat=True)
        read_outputs = Output.objects.filter(id__in=read_output_ids)
        visible_outputs.extend(read_outputs)
        
        # If user has any permission in this phase, they can see all outputs in the phase
        if todos.exists():
            phase_outputs = Output.objects.filter(phase=phase)
            visible_outputs.extend(phase_outputs)
    
    # Remove duplicates
    visible_outputs = list(set(visible_outputs))
    
    return visible_outputs

def get_dashboard_items_by_level(user, ppap_level=None):
    """
    Get dashboard items filtered by PPAP level
    """
    # Get user's authorization level
    authorization = user.authorization.name
    
    # Admin and create users can see everything
    if authorization in ['admin', 'create']:
        if ppap_level:
            # Filter by PPAP level
            ppaPs = PPAP.objects.filter(level=ppap_level)
        else:
            # Show all PPAPs
            ppaPs = PPAP.objects.all()
    else:
        # For edit users, show only PPAPs where they have assigned outputs
        if ppap_level:
            # Filter by PPAP level and user's todos
            output_ids = user.todos.values_list('output_id', flat=True)
            outputs = Output.objects.filter(id__in=output_ids)
            phase_ids = outputs.values_list('phase_id', flat=True)
            phases = Phase.objects.filter(id__in=phase_ids)
            ppap_ids = phases.values_list('ppap_id', flat=True)
            ppaPs = PPAP.objects.filter(id__in=ppap_ids, level=ppap_level)
        else:
            # Show all PPAPs where user has assigned outputs
            output_ids = user.todos.values_list('output_id', flat=True)
            outputs = Output.objects.filter(id__in=output_ids)
            phase_ids = outputs.values_list('phase_id', flat=True)
            phases = Phase.objects.filter(id__in=phase_ids)
            ppap_ids = phases.values_list('ppap_id', flat=True)
            ppaPs = PPAP.objects.filter(id__in=ppap_ids)
    
    # Get projects for these PPAPs
    projects = []
    for ppap in ppaPs:
        project = ppap.project
        projects.append({
            'id': project.id,
            'name': project.name,
            'status': project.status,
            'ppap_level': ppap.level,
            'ppap_status': ppap.status,
            'client': project.client.name,
            'team': project.team.name
        })
    
    return projects

```

#----------------------------------------------------------------------------------------------------

# core\services\logic\permission.py ===============================================

core\services\logic\permission.py:
```python
# Permission logic
from core.models import User, Permission, Todo, Output

def assign_permission(user_id, output_id, permission_type):
    """
    Assign permission to a user for an output
    """
    user = User.objects.get(id=user_id)
    output = Output.objects.get(id=output_id)
    permission = Permission.objects.get(name=permission_type)
    
    # Check if todo already exists
    todo, created = Todo.objects.get_or_create(
        user=user,
        output=output,
        defaults={'permission': permission}
    )
    
    # Update permission if todo already exists
    if not created:
        todo.permission = permission
        todo.save()
    
    return todo

def check_permission(user_id, output_id, required_permission='r'):
    """
    Check if a user has the required permission for an output
    """
    try:
        todo = Todo.objects.get(user_id=user_id, output_id=output_id)
        
        # 'e' permission includes 'r' permission
        if required_permission == 'r' and todo.permission.name in ['r', 'e']:
            return True
        
        if required_permission == 'e' and todo.permission.name == 'e':
            return True
        
        return False
    except Todo.DoesNotExist:
        # Check if user has admin or create authorization
        user = User.objects.get(id=user_id)
        if user.authorization.name in ['admin', 'create']:
            return True
        
        # Check if user is responsible for the phase
        output = Output.objects.get(id=output_id)
        phase = output.phase
        if phase.responsible_id == user_id:
            return True
        
        return False

def get_user_permissions(user_id):
    """
    Get all permissions for a user
    """
    user = User.objects.get(id=user_id)
    
    # Check authorization level
    authorization = user.authorization.name
    
    if authorization in ['admin', 'create']:
        # Admin and create users have all permissions
        return {
            'global_permission': authorization,
            'output_permissions': []  # No need to list individual permissions
        }
    
    # Get todos for this user
    todos = Todo.objects.filter(user_id=user_id)
    
    output_permissions = []
    for todo in todos:
        output_permissions.append({
            'output_id': todo.output_id,
            'output_name': todo.output.template.name,
            'phase_id': todo.output.phase_id,
            'phase_name': todo.output.phase.template.name,
            'permission': todo.permission.name
        })
    
    return {
        'global_permission': authorization,
        'output_permissions': output_permissions
    }

```

#----------------------------------------------------------------------------------------------------

# core\services\logic\status.py ===================================================

core\services\logic\status.py:
```python
# Status changes logic (workflow to change status (we will stup the logic later)
from core.models import Project, PPAP, Phase, Output
from core.services.history.api import (
    record_project_update,
    record_ppap_update,
    record_phase_status_change,
    record_output_status_change
)

def change_project_status(project_id, new_status, user_id):
    """
    Change project status with workflow validation
    """
    project = Project.objects.get(id=project_id)
    old_status = project.status
    
    # Validate status transition
    valid_transitions = {
        'Planning': ['In Progress', 'On Hold', 'Cancelled'],
        'In Progress': ['Completed', 'On Hold', 'Cancelled'],
        'On Hold': ['Planning', 'In Progress', 'Cancelled'],
        'Completed': ['Archived'],
        'Cancelled': ['Archived'],
        'Archived': []
    }
    
    if new_status not in valid_transitions.get(old_status, []):
        raise ValueError(f"Invalid status transition from {old_status} to {new_status}")
    
    # Update status
    project.status = new_status
    project.save()
    
    # Record status change
    record_project_update(project, ['status'])
    
    return project

def change_ppap_status(ppap_id, new_status, user_id):
    """
    Change PPAP status with workflow validation
    """
    ppap = PPAP.objects.get(id=ppap_id)
    old_status = ppap.status
    
    # Validate status transition
    valid_transitions = {
        'Not Started': ['In Progress', 'Cancelled'],
        'In Progress': ['Completed', 'On Hold', 'Cancelled'],
        'On Hold': ['In Progress', 'Cancelled'],
        'Completed': ['Approved', 'Rejected'],
        'Approved': [],
        'Rejected': ['In Progress'],
        'Cancelled': []
    }
    
    if new_status not in valid_transitions.get(old_status, []):
        raise ValueError(f"Invalid status transition from {old_status} to {new_status}")
    
    # Update status
    ppap.status = new_status
    ppap.save()
    
    # Record status change
    record_ppap_update(ppap, ['status'])
    
    return ppap

def change_phase_status(phase_id, new_status, user_id):
    """
    Change phase status with workflow validation
    """
    phase = Phase.objects.get(id=phase_id)
    old_status = phase.status
    
    # Validate status transition
    valid_transitions = {
        'Not Started': ['In Progress', 'Cancelled'],
        'In Progress': ['Completed', 'On Hold', 'Cancelled'],
        'On Hold': ['In Progress', 'Cancelled'],
        'Completed': ['Approved', 'Rejected'],
        'Approved': [],
        'Rejected': ['In Progress'],
        'Cancelled': []
    }
    
    if new_status not in valid_transitions.get(old_status, []):
        raise ValueError(f"Invalid status transition from {old_status} to {new_status}")
    
    # Update status
    phase.status = new_status
    phase.save()
    
    # Record status change
    record_phase_status_change(phase, old_status, new_status)
    
    # Update PPAP status if needed
    if new_status == 'Completed':
        from core.services.phase.functions import update_ppap_status_from_phase
        update_ppap_status_from_phase(phase)
    
    return phase

def change_output_status(output_id, new_status, user_id):
    """
    Change output status with workflow validation
    """
    output = Output.objects.get(id=output_id)
    old_status = output.status
    
    # Validate status transition
    valid_transitions = {
        'Not Started': ['In Progress', 'Cancelled'],
        'In Progress': ['Completed', 'On Hold', 'Cancelled'],
        'On Hold': ['In Progress', 'Cancelled'],
        'Completed': ['Approved', 'Rejected'],
        'Approved': [],
        'Rejected': ['In Progress'],
        'Cancelled': [],
        'Deprecated': []
    }
    
    if new_status not in valid_transitions.get(old_status, []):
        raise ValueError(f"Invalid status transition from {old_status} to {new_status}")
    
    # Update status
    output.status = new_status
    output.save()
    
    # Record status change
    record_output_status_change(output, old_status, new_status)
    
    # Update phase status if needed
    if new_status == 'Completed':
        from core.services.output.functions import update_phase_status_from_output
        update_phase_status_from_output(output)
    
    return output

```

#----------------------------------------------------------------------------------------------------

# core\services\logic\todo.py =====================================================

core\services\logic\todo.py:
```python
# To do logic
from core.models import Todo, User, Output, Permission
from django.db.models import Q

def create_todo(user_id, output_id, permission_name):
    """
    Create a todo for a user
    """
    user = User.objects.get(id=user_id)
    output = Output.objects.get(id=output_id)
    permission = Permission.objects.get(name=permission_name)
    
    todo = Todo.objects.create(
        user=user,
        output=output,
        permission=permission
    )
    
    return todo

def assign_todos_for_phase(phase_id, responsible_id):
    """
    Assign todos for all outputs in a phase to a responsible user
    """
    from core.models import Phase, Output
    
    phase = Phase.objects.get(id=phase_id)
    outputs = Output.objects.filter(phase=phase)
    
    # Get edit permission
    edit_permission = Permission.objects.get(name='e')
    
    todos = []
    for output in outputs:
        todo, created = Todo.objects.get_or_create(
            user_id=responsible_id,
            output=output,
            defaults={'permission': edit_permission}
        )
        todos.append(todo)
    
    # Update phase responsible
    phase.responsible_id = responsible_id
    phase.save()
    
    return todos

def get_user_todos(user_id):
    """
    Get all todos for a user
    """
    todos = Todo.objects.filter(user_id=user_id)
    
    todo_list = []
    for todo in todos:
        output = todo.output
        phase = output.phase
        ppap = phase.ppap
        project = ppap.project
        
        todo_list.append({
            'id': todo.id,
            'output_id': output.id,
            'output_name': output.template.name,
            'phase_id': phase.id,
            'phase_name': phase.template.name,
            'project_id': project.id,
            'project_name': project.name,
            'permission': todo.permission.name,
            'status': output.status
        })
    
    return todo_list

def get_pending_todos(user_id):
    """
    Get pending todos for a user (outputs that are not completed)
    """
    todos = Todo.objects.filter(
        user_id=user_id,
        output__status__in=['Not Started', 'In Progress', 'On Hold', 'Rejected']
    )
    
    todo_list = []
    for todo in todos:
        output = todo.output
        phase = output.phase
        ppap = phase.ppap
        project = ppap.project
        
        todo_list.append({
            'id': todo.id,
            'output_id': output.id,
            'output_name': output.template.name,
            'phase_id': phase.id,
            'phase_name': phase.template.name,
            'project_id': project.id,
            'project_name': project.name,
            'permission': todo.permission.name,
            'status': output.status
        })
    
    return todo_list

```

#----------------------------------------------------------------------------------------------------

# core\services\output\__init__.py ================================================

core\services\output\__init__.py:
```python
# Output services

```

#----------------------------------------------------------------------------------------------------

# core\services\output\api.py =====================================================

core\services\output\api.py:
```python
# Define all API here
import uuid
from core.services.output.initialization import initialize_outputs
from core.services.output.functions import (
    update_output,
    update_phase_status_from_output,
    add_document_to_output,
    get_output_details
)

# Export all functions for use in views
__all__ = [
    'initialize_outputs',
    'update_output',
    'update_phase_status_from_output',
    'add_document_to_output',
    'get_output_details'
]

```

#----------------------------------------------------------------------------------------------------

# core\services\output\functions.py ===============================================

core\services\output\functions.py:
```python
# Define project possible action and services
from django.db import transaction
from core.models import Output, Document
from core.services.history.api import (
    record_output_update,
    record_output_status_change
)

@transaction.atomic
def update_output(output_id, data):
    """
    Update output details
    """
    output = Output.objects.get(id=output_id)
    
    # Check for status change
    old_status = output.status
    new_status = data.get('status', old_status)
    
    # Update fields
    updated_fields = []
    for field, value in data.items():
        if hasattr(output, field) and getattr(output, field) != value:
            setattr(output, field, value)
            updated_fields.append(field)
    
    if updated_fields:
        output.save()
        record_output_update(output, updated_fields)
    
    # Handle status change
    if 'status' in updated_fields and old_status != new_status:
        record_output_status_change(output, old_status, new_status)
        
        # Update phase status if needed
        update_phase_status_from_output(output)
    
    return output

def update_phase_status_from_output(output):
    """
    Update phase status based on output status changes
    """
    phase = output.phase
    
    # Get all outputs for this phase
    outputs = phase.outputs.all()
    
    # Check if all outputs are completed
    all_completed = all(o.status == 'Completed' for o in outputs)
    
    if all_completed and phase.status != 'Completed':
        phase.status = 'Completed'
        phase.save()
        
        # Record phase completion in history
        from core.services.history.initialization import initialize_history
        initialize_history(
            title=f"{phase.template.name}",
            event=f"Phase marked as Completed as all outputs are completed",
            table_name='phase',
            history_id=phase.history_id
        )
        
        # Update PPAP status
        from core.services.phase.functions import update_ppap_status_from_phase
        update_ppap_status_from_phase(phase)
    
    # Check if any output is in progress
    any_in_progress = any(o.status == 'In Progress' for o in outputs)
    
    if any_in_progress and phase.status == 'Not Started':
        phase.status = 'In Progress'
        phase.save()
        
        # Record phase status change in history
        from core.services.history.initialization import initialize_history
        initialize_history(
            title=f"{phase.template.name}",
            event=f"Phase marked as In Progress as at least one output is in progress",
            table_name='phase',
            history_id=phase.history_id
        )

@transaction.atomic
def add_document_to_output(output_id, document_data, uploader_id):
    """
    Add a document to an output
    """
    output = Output.objects.get(id=output_id)
    
    # Create document
    document = Document.objects.create(
        name=document_data['name'],
        description=document_data.get('description', ''),
        file_path=document_data['file_path'],
        file_type=document_data['file_type'],
        file_size=document_data['file_size'],
        uploader_id=uploader_id,
        output=output,
        version=document_data.get('version', '1.0'),
        status=document_data.get('status', 'Draft'),
    )
    
    # Record document creation in history
    from core.services.history.initialization import initialize_history
    initialize_history(
        title=document.name,
        event=f"Document uploaded for Output {output_id}",
        table_name='document',
        history_id=document.history_id
    )
    
    return document

def get_output_details(output_id):
    """
    Get comprehensive output details including all documents
    """
    output = Output.objects.get(id=output_id)
    
    # Get documents
    documents = output.documents.all()
    
    document_details = []
    for doc in documents:
        document_details.append({
            'id': doc.id,
            'name': doc.name,
            'description': doc.description,
            'file_path': doc.file_path,
            'file_type': doc.file_type,
            'file_size': doc.file_size,
            'uploader': doc.uploader.username if doc.uploader else None,
            'version': doc.version,
            'status': doc.status
        })
    
    # Compile output details
    output_details = {
        'id': output.id,
        'name': output.template.name,
        'description': output.description,
        'status': output.status,
        'responsible': output.user.username if output.user else None,
        'phase_id': output.phase_id,
        'documents': document_details
    }
    
    return output_details

```

#----------------------------------------------------------------------------------------------------

# core\services\output\initialization.py ==========================================

core\services\output\initialization.py:
```python
import uuid
from django.db import transaction
from core.models import Output, OutputTemplate, PPAPElement
from core.services.history.initialization import initialize_history

@transaction.atomic
def initialize_outputs(phase_id, ppap_level, preserve_existing=False):
    """
    Initialize outputs for a phase based on templates and PPAP level
    """
    from core.models import Phase
    
    phase = Phase.objects.get(id=phase_id)
    phase_template = phase.template
    
    # Get output templates for this phase template
    output_templates = OutputTemplate.objects.filter(phase=phase_template)
    
    # Filter templates based on PPAP level
    filtered_templates = []
    for template in output_templates:
        ppap_element = template.ppap_element
        levels = ppap_element.level.split(',')
        if 'custom' in levels or str(ppap_level) in levels:
            filtered_templates.append(template)
    
    outputs = []
    
    # If preserving existing, get existing output templates
    existing_template_ids = []
    if preserve_existing:
        existing_template_ids = list(phase.outputs.values_list('template_id', flat=True))
    
    for template in filtered_templates:
        # Skip if already exists and preserving
        if preserve_existing and template.id in existing_template_ids:
            continue
        
        # Create output record without specifying history_id
        # Let the model's save method handle history_id generation
        output = Output.objects.create(
            template=template,
            phase=phase,
            status='Not Started'
        )
        
        # Initialize history record with the model-generated history_id
        initialize_history(
            title=f"{template.name} for Phase {phase.template.name}",  # FIXED
            event_type="create",
            event_details=f"Output created based on template {template.id}",
            table_name='output',
            history_id=output.history_id
        )
        
        outputs.append(output)
    
    return outputs

```

#----------------------------------------------------------------------------------------------------

# core\services\person\__init__.py ================================================

core\services\person\__init__.py:
```python
# Person services

```

#----------------------------------------------------------------------------------------------------

# core\services\person\api.py =====================================================

core\services\person\api.py:
```python
"""
Person API service
"""
from rest_framework.response import Response
from rest_framework import status
from core.models import Person, Team, Department, Contact
from core.serializers.person_serializer import PersonSerializer
from core.services.person.functions import (
    update_person,
    update_person_department,
    add_person_to_team,
    remove_person_from_team,
    check_person_dependencies
)
from core.services.history.person import (
    record_person_creation,
    record_person_deletion,
)
from core.services.history.contact import record_contact_creation

# Person service API
from core.services.person.initialization import initialize_person
from core.services.person.functions import (
    get_person_by_id,
    get_persons_by_team,
    get_persons_by_department,
    get_users,
    update_person,
    change_person_department,
    add_person_to_team,
    remove_person_from_team,
    delete_person,
    get_person_assignments
)

# Export all functions for use in views
__all__ = [
    # Initialization
    'initialize_person',
    
    # Functions
    'get_person_by_id',
    'get_persons_by_team',
    'get_persons_by_department',
    'get_users',
    'update_person',
    'change_person_department',
    'add_person_to_team',
    'remove_person_from_team',
    'delete_person',
    'get_person_assignments'
]

def api_create_person(request):
    """
    API endpoint to create a person
    
    Args:
        request: HTTP request with person data
        
    Returns:
        Response: HTTP response
    """
    first_name = request.data.get('first_name')
    last_name = request.data.get('last_name')
    team_ids = request.data.get('team_ids', [])
    department_id = request.data.get('department_id')
    is_user = request.data.get('is_user', False)
    contact_data = request.data.get('contact', {})
    
    if not all([first_name, last_name]):
        return Response(
            {"error": "Missing required fields: first_name, last_name"},
            status=status.HTTP_400_BAD_REQUEST
        )
    
    try:
        # Create person
        person = Person.objects.create(
            first_name=first_name,
            last_name=last_name,
            is_user=is_user
        )
        
        # Add to teams if provided
        if team_ids:
            teams = Team.objects.filter(id__in=team_ids)
            person.teams.set(teams)
        
        # Set department if provided
        if department_id:
            try:
                department = Department.objects.get(id=department_id)
                person.department = department
                person.save()
            except Department.DoesNotExist:
                pass
        
        # Create contact
        if contact_data:
            Contact.objects.create(
                id=person.contact_id,
                address=contact_data.get('address', ''),
                email=contact_data.get('email', ''),
                phone=contact_data.get('phone', ''),
                type='person'
            )
       
        
        serializer = PersonSerializer(person)
        return Response(serializer.data, status=status.HTTP_201_CREATED)
    except Exception as e:
        return Response(
            {"error": str(e)},
            status=status.HTTP_400_BAD_REQUEST
        )

def api_update_person(request, person_id):
    """
    API endpoint to update a person
    
    Args:
        request: HTTP request with person data
        person_id (int): Person ID
        
    Returns:
        Response: HTTP response
    """
    try:
        person = Person.objects.get(id=person_id)
    except Person.DoesNotExist:
        return Response(
            {"error": f"Person with ID {person_id} not found"},
            status=status.HTTP_404_NOT_FOUND
        )
    
    first_name = request.data.get('first_name', person.first_name)
    last_name = request.data.get('last_name', person.last_name)
    is_user = request.data.get('is_user', person.is_user)
    
    # Update person
    updated_person = update_person(person_id, first_name, last_name, is_user)
    
    # Handle department change
    if 'department_id' in request.data:
        department_id = request.data.get('department_id')
        update_person_department(person_id, department_id)
    
    # Handle teams if provided
    if 'team_ids' in request.data:
        team_ids = request.data.get('team_ids', [])
        current_teams = set(person.teams.values_list('id', flat=True))
        new_teams = set(int(t) for t in team_ids)
        
        # Add new teams
        for team_id in new_teams - current_teams:
            add_person_to_team(person_id, team_id)
        
        # Remove teams
        for team_id in current_teams - new_teams:
            remove_person_from_team(person_id, team_id)
    
    serializer = PersonSerializer(person)
    return Response(serializer.data)

def api_delete_person(request, person_id):
    """
    API endpoint to delete a person
    
    Args:
        request: HTTP request
        person_id (int): Person ID
        
    Returns:
        Response: HTTP response
    """
    try:
        person = Person.objects.get(id=person_id)
    except Person.DoesNotExist:
        return Response(
            {"error": f"Person with ID {person_id} not found"},
            status=status.HTTP_404_NOT_FOUND
        )
    
    # Check dependencies
    dependencies = check_person_dependencies(person_id)
    
    # Record deletion in history
    record_person_deletion(person)
    
    # Delete associated contact if exists
    try:
        contact = Contact.objects.get(id=person.contact_id)
        contact.delete()
    except Contact.DoesNotExist:
        pass
    
    # Delete the person
    person.delete()
    
    return Response(status=status.HTTP_204_NO_CONTENT)

def api_get_person(request, person_id):
    """
    API endpoint to get a person
    
    Args:
        request: HTTP request
        person_id (int): Person ID
        
    Returns:
        Response: HTTP response
    """
    try:
        person = Person.objects.get(id=person_id)
        serializer = PersonSerializer(person)
        return Response(serializer.data)
    except Person.DoesNotExist:
        return Response(
            {"error": f"Person with ID {person_id} not found"},
            status=status.HTTP_404_NOT_FOUND
        )

def api_list_persons(request):
    """
    API endpoint to list all persons
    
    Args:
        request: HTTP request
        
    Returns:
        Response: HTTP response
    """
    persons = Person.objects.all()
    
    # Apply filters if provided
    name_filter = request.query_params.get('name', None)
    if name_filter:
        persons = persons.filter(
            first_name__icontains=name_filter
        ) | persons.filter(
            last_name__icontains=name_filter
        )
    
    team_filter = request.query_params.get('team_id', None)
    if team_filter:
        persons = persons.filter(teams__id=team_filter)
    
    department_filter = request.query_params.get('department_id', None)
    if department_filter:
        persons = persons.filter(department_id=department_filter)
    
    is_user_filter = request.query_params.get('is_user', None)
    if is_user_filter is not None:
        is_user_bool = is_user_filter.lower() == 'true'
        persons = persons.filter(is_user=is_user_bool)
    
    serializer = PersonSerializer(persons, many=True)
    return Response(serializer.data)

def api_add_person_to_team(request, person_id):
    """
    API endpoint to add a person to a team
    
    Args:
        request: HTTP request
        person_id (int): Person ID
        
    Returns:
        Response: HTTP response
    """
    team_id = request.data.get('team_id')
    
    if not team_id:
        return Response(
            {"error": "Missing required field: team_id"},
            status=status.HTTP_400_BAD_REQUEST
        )
    
    success = add_person_to_team(person_id, team_id)
    
    if success:
        return Response({"status": "Added to team successfully"})
    else:
        return Response(
            {"error": "Failed to add person to team"},
            status=status.HTTP_400_BAD_REQUEST
        )

def api_remove_person_from_team(request, person_id):
    """
    API endpoint to remove a person from a team
    
    Args:
        request: HTTP request
        person_id (int): Person ID
        
    Returns:
        Response: HTTP response
    """
    team_id = request.data.get('team_id')
    
    if not team_id:
        return Response(
            {"error": "Missing required field: team_id"},
            status=status.HTTP_400_BAD_REQUEST
        )
    
    success = remove_person_from_team(person_id, team_id)
    
    if success:
        return Response({"status": "Removed from team successfully"})
    else:
        return Response(
            {"error": "Failed to remove person from team"},
            status=status.HTTP_400_BAD_REQUEST
        )

```

#----------------------------------------------------------------------------------------------------

# core\services\person\functions.py ===============================================

core\services\person\functions.py:
```python
from core.models import Person, Team, Department, Output
from core.services.history.person import (
    record_person_creation,
    record_person_update,
    record_person_team_change,
    record_person_department_change,
    record_person_deletion
)

def get_person_by_id(person_id):
    """
    Get person by ID
    
    Args:
        person_id (int): Person ID
    
    Returns:
        Person: The person object
    """
    return Person.objects.get(id=person_id)

def get_persons_by_team(team_id):
    """
    Get persons in a specific team
    
    Args:
        team_id (int): Team ID
    
    Returns:
        QuerySet: Persons in the specified team
    """
    team = Team.objects.get(id=team_id)
    return team.members.all()

def get_persons_by_department(department_id):
    """
    Get persons in a specific department
    
    Args:
        department_id (int): Department ID
    
    Returns:
        QuerySet: Persons in the specified department
    """
    return Person.objects.filter(department_id=department_id)

def get_users():
    """
    Get all persons who are users
    
    Returns:
        QuerySet: Persons with is_user=True
    """
    return Person.objects.filter(is_user=True)

def update_person(person, first_name=None, last_name=None, is_user=None):
    """
    Update person information
    
    Args:
        person: Person object
        first_name (str): New first name (if None, keep existing)
        last_name (str): New last name (if None, keep existing)
        is_user (bool): New is_user status (if None, keep existing)
    
    Returns:
        Person: The updated person
    """
    updated_fields = []
    
    if first_name is not None and first_name != person.first_name:
        person.first_name = first_name
        updated_fields.append('first_name')
    
    if last_name is not None and last_name != person.last_name:
        person.last_name = last_name
        updated_fields.append('last_name')
    
    if is_user is not None and is_user != person.is_user:
        person.is_user = is_user
        updated_fields.append('is_user')
    
    if updated_fields:
        person.save()
        record_person_update(person, updated_fields)
    
    return person

def change_person_department(person, department):
    """
    Change a person's department
    
    Args:
        person: Person object
        department: Department object
    
    Returns:
        Person: The updated person
    """
    old_department_id = person.department.id if person.department else None
    new_department_id = department.id if department else None
    
    if old_department_id != new_department_id:
        person.department = department
        person.save()
        record_person_department_change(person, old_department_id, new_department_id)
    
    return person

def add_person_to_team(person, team):
    """
    Add a person to a team
    
    Args:
        person: Person object
        team: Team object
    
    Returns:
        bool: True if added, False if already a member
    """
    if team not in person.teams.all():
        person.teams.add(team)
        record_person_team_change(person, None, team.id)
        return True
    return False

def remove_person_from_team(person, team):
    """
    Remove a person from a team
    
    Args:
        person: Person object
        team: Team object
    
    Returns:
        bool: True if removed, False if not a member
    """
    if team in person.teams.all():
        person.teams.remove(team)
        record_person_team_change(person, team.id, None)
        return True
    return False

def delete_person(person):
    """
    Delete a person
    
    Args:
        person: Person object
    """
    # Check for outputs assigned to this person
    outputs_count = Output.objects.filter(responsible=person).count()
    if outputs_count > 0:
        raise ValueError(f"Cannot delete person. They are responsible for {outputs_count} outputs.")
    
    record_person_deletion(person)
    
    # Remove from all teams
    for team in person.teams.all():
        person.teams.remove(team)
    
    person.delete()

def get_person_assignments(person_id):
    """
    Get all outputs assigned to a person
    
    Args:
        person_id (int): Person ID
    
    Returns:
        QuerySet: Outputs assigned to the person
    """
    return Output.objects.filter(responsible_id=person_id)

```

#----------------------------------------------------------------------------------------------------

# core\services\person\initialization.py ==========================================

core\services\person\initialization.py:
```python
from core.models import Person
import uuid

def initialize_person(first_name, last_name, is_user=False, department=None):
    """
    Initialize a new person
    
    Args:
        first_name (str): Person's first name
        last_name (str): Person's last name
        is_user (bool): Whether this person is a user
        department: Department object
    
    Returns:
        Person: The created person
    """
    person = Person.objects.create(
        first_name=first_name,
        last_name=last_name,
        is_user=is_user,
        department=department,
    )
    
    return person

```

#----------------------------------------------------------------------------------------------------

# core\services\phase\__init__.py =================================================

core\services\phase\__init__.py:
```python
# Phase services

```

#----------------------------------------------------------------------------------------------------

# core\services\phase\api.py ======================================================

core\services\phase\api.py:
```python
# Define all API here
from core.services.phase.initialization import initialize_phases
from core.services.phase.functions import (
    update_phase,
    update_ppap_status_from_phase,
    get_phase_details
)

# Export all functions for use in views
__all__ = [
    'initialize_phases',
    'update_phase',
    'update_ppap_status_from_phase',
    'get_phase_details'
]

```

#----------------------------------------------------------------------------------------------------

# core\services\phase\functions.py ================================================

core\services\phase\functions.py:
```python
# Define project possible action and services
from django.db import transaction
from core.models import Phase, Output
from core.services.history.api import (
    record_phase_update,
    record_phase_status_change
)

@transaction.atomic
def update_phase(phase_id, data):
    """
    Update phase details
    """
    phase = Phase.objects.get(id=phase_id)
    
    # Check for status change
    old_status = phase.status
    new_status = data.get('status', old_status)
    
    # Update fields
    updated_fields = []
    for field, value in data.items():
        if hasattr(phase, field) and getattr(phase, field) != value:
            setattr(phase, field, value)
            updated_fields.append(field)
    
    if updated_fields:
        phase.save()
        record_phase_update(phase, updated_fields)
    
    # Handle status change
    if 'status' in updated_fields and old_status != new_status:
        record_phase_status_change(phase, old_status, new_status)
        
        # Update PPAP status if needed
        update_ppap_status_from_phase(phase)
    
    return phase

def update_ppap_status_from_phase(phase):
    """
    Update PPAP status based on phase status changes
    """
    ppap = phase.ppap
    
    # Get all phases for this PPAP
    phases = ppap.phases.all()
    
    # Check if all phases are completed
    all_completed = all(p.status == 'Completed' for p in phases)
    
    if all_completed and ppap.status != 'Completed':
        ppap.status = 'Completed'
        ppap.save()
        
        # Record PPAP completion in history
        from core.services.history.initialization import initialize_history
        initialize_history(
            title=f"PPAP for Project {ppap.project_id}",
            event=f"PPAP marked as Completed as all phases are completed",
            table_name='ppap',
            history_id=ppap.history_id
        )
    
    # Check if any phase is in progress
    any_in_progress = any(p.status == 'In Progress' for p in phases)
    
    if any_in_progress and ppap.status == 'Not Started':
        ppap.status = 'In Progress'
        ppap.save()
        
        # Record PPAP status change in history
        from core.services.history.initialization import initialize_history
        initialize_history(
            title=f"PPAP for Project {ppap.project_id}",
            event=f"PPAP marked as In Progress as at least one phase is in progress",
            table_name='ppap',
            history_id=ppap.history_id
        )

def get_phase_details(phase_id):
    """
    Get comprehensive phase details including all outputs
    """
    phase = Phase.objects.get(id=phase_id)
    
    # Get outputs
    outputs = phase.outputs.all()
    
    output_details = []
    for output in outputs:
        documents = output.documents.all()
        
        output_details.append({
            'id': output.id,
            'name': output.template.name,
            'description': output.description,
            'status': output.status,
            'responsible': output.user.username if output.user else None,
            'documents': [
                {
                    'id': doc.id,
                    'name': doc.name,
                    'version': doc.version,
                    'status': doc.status
                } for doc in documents
            ]
        })
    
    # Compile phase details
    phase_details = {
        'id': phase.id,
        'name': phase.template.name,
        'status': phase.status,
        'responsible': phase.responsible.username if phase.responsible else None,
        'ppap_id': phase.ppap_id,
        'outputs': output_details
    }
    
    return phase_details

```

#----------------------------------------------------------------------------------------------------

# core\services\phase\initialization.py ===========================================

core\services\phase\initialization.py:
```python
import uuid
from django.db import transaction
from core.models import Phase, PhaseTemplate
from core.services.history.initialization import initialize_history
from core.services.output.initialization import initialize_outputs
from core.services.history.phase import record_phase_creation, record_phase_update

@transaction.atomic
def initialize_phases(ppap_id, ppap_level):
    """
    Initialize phases for a PPAP based on templates
    """
    # Get phase templates appropriate for this PPAP level
    phase_templates = PhaseTemplate.objects.all().order_by('order')
    
    phases = []
    
    for template in phase_templates:        
        # Create phase record
        phase = Phase.objects.create(
            template=template,
            ppap_id=ppap_id,
            status='Not Started',
        )
        
        # Record creation in history
        record_phase_creation(phase)
        
        # Initialize outputs
        initialize_outputs(phase.id, ppap_level)
        
        phases.append(phase)
    
    return phases

```

#----------------------------------------------------------------------------------------------------

# core\services\ppap\__init__.py ==================================================

core\services\ppap\__init__.py:
```python
# PPAP services

```

#----------------------------------------------------------------------------------------------------

# core\services\ppap\api.py =======================================================

core\services\ppap\api.py:
```python
# Define all API here
from core.services.ppap.initialization import initialize_ppap
from core.services.ppap.functions import (
    update_ppap,
    update_outputs_for_level_change,
    get_ppap_details
)

# Export all functions for use in views
__all__ = [
    'initialize_ppap',
    'update_ppap',
    'update_outputs_for_level_change',
    'get_ppap_details'
]

```

#----------------------------------------------------------------------------------------------------

# core\services\ppap\functions.py =================================================

core\services\ppap\functions.py:
```python
# Define project possible action and services
from django.db import transaction
from core.models import PPAP, Phase, Output
from core.services.history.api import (
    record_ppap_update,
    record_ppap_level_change
)
from core.services.output.initialization import initialize_outputs

@transaction.atomic
def update_ppap(ppap_id, data):
    """
    Update PPAP details
    """
    ppap = PPAP.objects.get(id=ppap_id)
    
    # Check for level change
    old_level = ppap.level
    new_level = data.get('level', old_level)
    
    # Update fields
    updated_fields = []
    for field, value in data.items():
        if hasattr(ppap, field) and getattr(ppap, field) != value:
            setattr(ppap, field, value)
            updated_fields.append(field)
    
    if updated_fields:
        ppap.save()
        record_ppap_update(ppap, updated_fields)
    
    # Handle level change
    if 'level' in updated_fields and old_level != new_level:
        record_ppap_level_change(ppap, old_level, new_level)
        
        # Update outputs based on new level
        update_outputs_for_level_change(ppap, new_level)
    
    return ppap

@transaction.atomic
def update_outputs_for_level_change(ppap, new_level):
    """
    Update outputs when PPAP level changes
    """
    # Get all phases for this PPAP
    phases = ppap.phases.all()
    
    for phase in phases:
        # Get existing outputs
        existing_outputs = phase.outputs.all()
        
        # Initialize new outputs based on new level
        initialize_outputs(phase.id, new_level, preserve_existing=True)
        
        # Mark outputs that are no longer required as 'Deprecated'
        for output in existing_outputs:
            ppap_element = output.template.ppap_element
            levels = ppap_element.level.split(',')
            
            if 'custom' not in levels and str(new_level) not in levels:
                output.status = 'Deprecated'
                output.save()

def get_ppap_details(ppap_id):
    """
    Get comprehensive PPAP details including all phases and outputs
    """
    ppap = PPAP.objects.get(id=ppap_id)
    
    # Get phases
    phases = ppap.phases.all().order_by('template__order')
    
    # Get outputs for each phase
    phase_details = []
    for phase in phases:
        outputs = phase.outputs.all()
        
        output_details = []
        for output in outputs:
            documents = output.documents.all()
            
            output_details.append({
                'id': output.id,
                'name': output.template.name,
                'description': output.description,
                'status': output.status,
                'responsible': output.user.username if output.user else None,
                'documents': [
                    {
                        'id': doc.id,
                        'name': doc.name,
                        'version': doc.version,
                        'status': doc.status
                    } for doc in documents
                ]
            })
        
        phase_details.append({
            'id': phase.id,
            'name': phase.template.name,
            'status': phase.status,
            'responsible': phase.responsible.username if phase.responsible else None,
            'outputs': output_details
        })
    
    # Compile PPAP details
    ppap_details = {
        'id': ppap.id,
        'project_id': ppap.project_id,
        'level': ppap.level,
        'status': ppap.status,
        'review': ppap.review,
        'phases': phase_details
    }
    
    return ppap_details

```

#----------------------------------------------------------------------------------------------------

# core\services\ppap\initialization.py ============================================

core\services\ppap\initialization.py:
```python
import uuid
from django.db import transaction
from core.models import PPAP, Phase, Output
from core.services.history.initialization import initialize_history
from core.services.phase.initialization import initialize_phases
from core.services.history.ppap import record_ppap_creation

@transaction.atomic
def initialize_ppap(project_id, level):
    """
    Initialize a new PPAP record with phases and outputs
    """
    # Get the Project instance first
    from core.models import Project
    project = Project.objects.get(id=project_id)
    
    # Create PPAP record without setting history_id
    ppap = PPAP.objects.create(
        project=project,  # Use the project instance, not the ID
        level=level,
        status='Not Started',
    )
    
    # Initialize history record using the model-generated history_id
    record_ppap_creation(ppap)
    
    # Initialize phases based on PPAP level
    initialize_phases(ppap.id, level)
    
    return ppap

```

#----------------------------------------------------------------------------------------------------

# core\services\ppap_element\__init__.py ==========================================

core\services\ppap_element\__init__.py:
```python
# PPAP Element services
```

#----------------------------------------------------------------------------------------------------

# core\services\ppap_element\api.py ===============================================

core\services\ppap_element\api.py:
```python
from core.services.ppap_element.functions import (
    get_ppap_element_by_id,
    get_ppap_elements_by_level,
    create_ppap_element,
    update_ppap_element,
    delete_ppap_element,
    get_all_ppap_elements
)

__all__ = [
    'get_ppap_element_by_id',
    'get_ppap_elements_by_level',
    'create_ppap_element',
    'update_ppap_element',
    'delete_ppap_element',
    'get_all_ppap_elements'
]
```

#----------------------------------------------------------------------------------------------------

# core\services\ppap_element\functions.py =========================================

core\services\ppap_element\functions.py:
```python
from django.db import transaction
from core.models import PPAPElement

def get_ppap_element_by_id(element_id):
    """
    Get a PPAP element by ID
    
    Args:
        element_id (int): Element ID
        
    Returns:
        PPAPElement: The element object
        
    Raises:
        PPAPElement.DoesNotExist: If element not found
    """
    return PPAPElement.objects.get(id=element_id)

def get_ppap_elements_by_level(level):
    """
    Get PPAP elements for a specific level
    
    Args:
        level (int or str): PPAP level (1-5 or 'custom')
        
    Returns:
        QuerySet: PPAP elements for the given level
    """
    # Convert level to string for comparison
    level_str = str(level)
    
    # Find elements where the level string contains the requested level
    elements = PPAPElement.objects.all()
    
    # Filter in Python since we need to check if level is in a comma-separated list
    return [e for e in elements if level_str in e.level.split(',') or 'custom' in e.level.split(',')]

def create_ppap_element(name, level):
    """
    Create a new PPAP element
    
    Args:
        name (str): Element name
        level (str): Comma-separated list of applicable levels
        
    Returns:
        PPAPElement: Created element
    """
    return PPAPElement.objects.create(
        name=name,
        level=level
    )

def update_ppap_element(element_id, name=None, level=None):
    """
    Update a PPAP element
    
    Args:
        element_id (int): Element ID
        name (str, optional): New name
        level (str, optional): New level
        
    Returns:
        PPAPElement: Updated element
    """
    element = get_ppap_element_by_id(element_id)
    
    if name is not None:
        element.name = name
    
    if level is not None:
        element.level = level
    
    element.save()
    return element

@transaction.atomic
def delete_ppap_element(element_id):
    """
    Delete a PPAP element
    
    Args:
        element_id (int): Element ID
        
    Returns:
        bool: True if deleted, False otherwise
        
    Note:
        This will fail if the element is in use by any output templates.
    """
    try:
        element = get_ppap_element_by_id(element_id)
        element.delete()
        return True
    except Exception:
        return False

def get_all_ppap_elements():
    """
    Get all PPAP elements
    
    Returns:
        QuerySet: All PPAP elements
    """
    return PPAPElement.objects.all()
```

#----------------------------------------------------------------------------------------------------

# core\services\ppap_element\seeder.py ============================================

core\services\ppap_element\seeder.py:
```python
from django.db import transaction
from core.models import PPAPElement

@transaction.atomic
def seed_standard_ppap_elements():
    """
    Seed standard PPAP elements according to AIAG standards
    
    Returns:
        list: Created PPAP elements
    """
    # Define standard PPAP elements
    standard_elements = [
        {'name': 'Design Records', 'level': '1,2,3,4,5'},
        {'name': 'Engineering Change Documents', 'level': '1,2,3,4,5'},
        {'name': 'Customer Engineering Approval', 'level': '1,2,3,4,5'},
        {'name': 'Design FMEA', 'level': '2,3,4,5'},
        {'name': 'Process Flow Diagrams', 'level': '2,3,4,5'},
        {'name': 'Process FMEA', 'level': '2,3,4,5'},
        {'name': 'Control Plan', 'level': '2,3,4,5'},
        {'name': 'Measurement System Analysis Studies', 'level': '3,4,5'},
        {'name': 'Dimensional Results', 'level': '3,4,5'},
        {'name': 'Material, Performance Test Results', 'level': '3,4,5'},
        {'name': 'Initial Process Studies', 'level': '3,4,5'},
        {'name': 'Qualified Laboratory Documentation', 'level': '4,5'},
        {'name': 'Appearance Approval Report', 'level': '4,5'},
        {'name': 'Sample Production Parts', 'level': '4,5'},
        {'name': 'Master Sample', 'level': '4,5'},
        {'name': 'Checking Aids', 'level': '5'},
        {'name': 'Records of Compliance', 'level': '5'},
        {'name': 'Customer-Specific Requirements', 'level': '5'},
        {'name': 'Part Submission Warrant', 'level': '1,2,3,4,5'},
    ]
    
    created_elements = []
    
    for element_data in standard_elements:
        element, created = PPAPElement.objects.get_or_create(
            name=element_data['name'],
            defaults={'level': element_data['level']}
        )
        
        if not created:
            # Update the level if the element already existed
            element.level = element_data['level']
            element.save()
            
        created_elements.append(element)
        
    return created_elements
```

#----------------------------------------------------------------------------------------------------

# core\services\project\__init__.py ===============================================

core\services\project\__init__.py:
```python
# Project services

```

#----------------------------------------------------------------------------------------------------

# core\services\project\api.py ====================================================

core\services\project\api.py:
```python
# Define all API here
from core.services.project.initialization import initialize_project, initialize_fastquery
from core.services.project.functions import (
    update_project,
    delete_project,
    archive_project,
    get_project_details
)

# Export all functions for use in views
__all__ = [
    'initialize_project',
    'initialize_fastquery',
    'update_project',
    'delete_project',
    'archive_project',
    'get_project_details'
]

```

#----------------------------------------------------------------------------------------------------

# core\services\project\functions.py ==============================================

core\services\project\functions.py:
```python
# Define project possible action and services
from django.db import transaction
from core.models import Project, PPAP, Phase, Output, Document, History
from core.services.history.api import (
    record_project_update,
    record_project_deletion
)

@transaction.atomic
def update_project(project_id, data):
    """
    Update project details
    """
    project = Project.objects.get(id=project_id)
    
    # Update fields
    updated_fields = []
    for field, value in data.items():
        if hasattr(project, field) and getattr(project, field) != value:
            setattr(project, field, value)
            updated_fields.append(field)
    
    if updated_fields:
        project.save()
        record_project_update(project, updated_fields)
    
    return project

@transaction.atomic
def delete_project(project_id):
    """
    Delete a project and all related records
    """
    project = Project.objects.get(id=project_id)
    
    # Record deletion in history
    record_project_deletion(project)
    
    # Delete project (will cascade to related records)
    project.delete()
    
    return True

@transaction.atomic
def archive_project(project_id):
    """
    Archive a project instead of deleting it
    """
    project = Project.objects.get(id=project_id)
    project.status = 'Archived'
    project.save()
    
    record_project_update(project, ['status'])
    
    return project

def get_project_details(project_id):
    """
    Get comprehensive project details including all related records
    """
    project = Project.objects.get(id=project_id)
    
    # Get PPAP details
    ppap = project.ppap
    
    # Get phases
    phases = []
    if ppap:
        phases = ppap.phases.all().order_by('template__order')
    
    # Get outputs for each phase
    phase_details = []
    for phase in phases:
        outputs = phase.outputs.all()
        
        output_details = []
        for output in outputs:
            documents = output.documents.all()
            
            output_details.append({
                'id': output.id,
                'name': output.template.name,
                'description': output.description,
                'status': output.status,
                'responsible': output.user.username if output.user else None,
                'documents': [
                    {
                        'id': doc.id,
                        'name': doc.name,
                        'version': doc.version,
                        'status': doc.status
                    } for doc in documents
                ]
            })
        
        phase_details.append({
            'id': phase.id,
            'name': phase.template.name,
            'status': phase.status,
            'responsible': phase.responsible.username if phase.responsible else None,
            'outputs': output_details
        })
    
    # Get history records
    history_records = History.objects.filter(id=project.history_id)
    
    # Compile project details
    project_details = {
        'id': project.id,
        'name': project.name,
        'description': project.description,
        'status': project.status,
        'client': {
            'id': project.client.id,
            'name': project.client.name
        },
        'team': {
            'id': project.team.id,
            'name': project.team.name
        },
        'ppap': {
            'id': ppap.id,
            'level': ppap.level,
            'status': ppap.status,
            'review': ppap.review
        } if ppap else None,
        'phases': phase_details,
        'history': [
            {
                'event': record.event,
                'created_at': record.created_at
            } for record in history_records
        ]
    }
    
    return project_details

```

#----------------------------------------------------------------------------------------------------

# core\services\project\initialization.py =========================================

core\services\project\initialization.py:
```python
import uuid
from django.db import transaction
from core.models import Project, PPAP, FastQuery
from core.services.history.initialization import initialize_history
from core.services.ppap.initialization import initialize_ppap
from core.services.history.project import record_project_creation

@transaction.atomic
def initialize_project(name, description, client_id, team_id, ppap_level=3):
    """
    Initialize a new project with all related records
    """
    # Generate history ID
    history_id = f"{uuid.uuid4().hex}project"
    
    # Create project record
    project = Project.objects.create(
        name=name,
        description=description,
        client_id=client_id,
        team_id=team_id,
        status='Planning',
    )
    
    record_project_creation(project)
    
    # Initialize PPAP
    ppap = initialize_ppap(project.id, ppap_level)
    
    # Update project with PPAP ID
    project.ppap = ppap
    project.save()
    
    # Initialize FastQuery
    initialize_fastquery(project.id)
    
    return project

def initialize_fastquery(project_id):
    """
    Initialize a FastQuery record for a project
    """
    project = Project.objects.get(id=project_id)
    ppap = project.ppap
    
    # Collect all related IDs
    index = {
        'project_id': project.id,
        'ppap_id': ppap.id,
        'phase_ids': list(ppap.phases.values_list('id', flat=True)),
        'output_ids': []
    }
    
    # Add output IDs
    for phase in ppap.phases.all():
        output_ids = list(phase.outputs.values_list('id', flat=True))
        index['output_ids'].extend(output_ids)
    
    # Create FastQuery record
    fastquery = FastQuery.objects.create(
        project=project,
        index=index
    )
    
    return fastquery

```

#----------------------------------------------------------------------------------------------------

# core\services\team\__init__.py ==================================================

core\services\team\__init__.py:
```python
# Team services

```

#----------------------------------------------------------------------------------------------------

# core\services\team\api.py =======================================================

core\services\team\api.py:
```python
"""
Team API - Provides consistent interface to team functionality
"""
from rest_framework.response import Response
from rest_framework import status
from core.models import Team, Person, Department
from core.serializers.team_serializer import TeamSerializer
from core.services.team.functions import (
    get_team_by_id,
    get_teams_by_department,
    get_teams_by_project,
    update_team as update_team_func,
    add_team_member,
    remove_team_member,
    delete_team as delete_team_func,
    get_team_members as get_members_func,
    get_team_projects as get_projects_func,
    check_team_dependencies
)
from core.services.history.team import (
    record_team_creation,
    record_team_update,
    record_team_name_change,
    record_team_member_addition,
    record_team_member_removal,
    record_team_deletion
)

def initialize_team(name, description=None, department=None):
    """
    Initialize a new team
    
    Args:
        name (str): Team name
        description (str, optional): Team description
        department (Department, optional): Associated department
        
    Returns:
        Team: The created team
    """
    # Create new team
    team = Team.objects.create(
        name=name,
        description=description
    )
    
    # Record in history
    record_team_creation(team)
    
    # Associate with department if provided
    if department:
        # Handle department relation if needed
        pass
        
    return team

def update_team(team, name=None, description=None, department=None):
    """
    Update team information
    
    Args:
        team: Team object
        name (str, optional): New team name
        description (str, optional): New team description
        department (Department, optional): New department association
        
    Returns:
        Team: The updated team
    """
    return update_team_func(team, name, description)

def delete_team(team):
    """
    Delete a team
    
    Args:
        team: Team object
    """
    return delete_team_func(team)

# Export all functions for use in views
__all__ = [
    # Initialization
    'initialize_team',
    
    # Functions
    'get_team_by_id',
    'get_teams_by_department',
    'get_teams_by_project',
    'update_team',
    'add_team_member',
    'remove_team_member',
    'delete_team',
    'get_team_members',
    'get_team_projects',
    
    # API endpoints
    'api_create_team',
    'api_update_team',
    'api_delete_team',
    'api_get_team',
    'api_list_teams',
    'api_add_team_member',
    'api_remove_team_member'
]

def get_team_members(team_id):
    """
    Get all members of a team - wrapper for the function
    """
    return get_members_func(team_id)

def get_team_projects(team_id):
    """
    Get all projects associated with a team - wrapper for the function
    """
    return get_projects_func(team_id)

def api_create_team(request):
    """
    API endpoint to create a team
    
    Args:
        request: HTTP request with team data
        
    Returns:
        Response: HTTP response
    """
    name = request.data.get('name')
    description = request.data.get('description', '')
    members = request.data.get('members', [])
    
    if not name:
        return Response(
            {"error": "Missing required field: name"},
            status=status.HTTP_400_BAD_REQUEST
        )
    
    try:
        # Create team
        team = initialize_team(name=name, description=description)
        
        # Add members if provided
        if members:
            for member_id in members:
                try:
                    person = Person.objects.get(id=member_id)
                    add_team_member(team, person)
                except Person.DoesNotExist:
                    pass
        
        serializer = TeamSerializer(team)
        return Response(serializer.data, status=status.HTTP_201_CREATED)
    except Exception as e:
        return Response(
            {"error": str(e)},
            status=status.HTTP_400_BAD_REQUEST
        )

def api_update_team(request, team_id):
    """
    API endpoint to update a team
    
    Args:
        request: HTTP request with team data
        team_id (int): Team ID
        
    Returns:
        Response: HTTP response
    """
    try:
        team = Team.objects.get(id=team_id)
    except Team.DoesNotExist:
        return Response(
            {"error": f"Team with ID {team_id} not found"},
            status=status.HTTP_404_NOT_FOUND
        )
    
    name = request.data.get('name', team.name)
    description = request.data.get('description', team.description)
    members = request.data.get('members', None)
    
    # Update team
    updated_team = update_team(team, name, description)
    
    # Update members if provided
    if members is not None:
        current_members = set(team.members.values_list('id', flat=True))
        new_members = set(int(m) for m in members)
        
        # Add new members
        for member_id in new_members - current_members:
            try:
                person = Person.objects.get(id=member_id)
                add_team_member(team, person)
            except Person.DoesNotExist:
                pass
        
        # Remove members
        for member_id in current_members - new_members:
            try:
                person = Person.objects.get(id=member_id)
                remove_team_member(team, person)
            except Person.DoesNotExist:
                pass
    
    serializer = TeamSerializer(team)
    return Response(serializer.data)

def api_delete_team(request, team_id):
    """
    API endpoint to delete a team
    
    Args:
        request: HTTP request
        team_id (int): Team ID
        
    Returns:
        Response: HTTP response
    """
    try:
        team = Team.objects.get(id=team_id)
    except Team.DoesNotExist:
        return Response(
            {"error": f"Team with ID {team_id} not found"},
            status=status.HTTP_404_NOT_FOUND
        )
    
    # Check dependencies
    dependencies = check_team_dependencies(team_id)
    
    try:
        # Delete the team
        delete_team(team)
        return Response(status=status.HTTP_204_NO_CONTENT)
    except Exception as e:
        return Response(
            {"error": str(e)},
            status=status.HTTP_400_BAD_REQUEST
        )

def api_get_team(request, team_id):
    """
    API endpoint to get a team
    
    Args:
        request: HTTP request
        team_id (int): Team ID
        
    Returns:
        Response: HTTP response
    """
    try:
        team = Team.objects.get(id=team_id)
        serializer = TeamSerializer(team)
        return Response(serializer.data)
    except Team.DoesNotExist:
        return Response(
            {"error": f"Team with ID {team_id} not found"},
            status=status.HTTP_404_NOT_FOUND
        )

def api_list_teams(request):
    """
    API endpoint to list all teams
    
    Args:
        request: HTTP request
        
    Returns:
        Response: HTTP response
    """
    teams = Team.objects.all()
    
    # Apply filters if provided
    name_filter = request.query_params.get('name', None)
    if name_filter:
        teams = teams.filter(name__icontains=name_filter)
    
    serializer = TeamSerializer(teams, many=True)
    return Response(serializer.data)

def api_add_team_member(request, team_id):
    """
    API endpoint to add a member to a team
    
    Args:
        request: HTTP request
        team_id (int): Team ID
        
    Returns:
        Response: HTTP response
    """
    person_id = request.data.get('person_id')
    
    if not person_id:
        return Response(
            {"error": "Missing required field: person_id"},
            status=status.HTTP_400_BAD_REQUEST
        )
    
    try:
        team = Team.objects.get(id=team_id)
        person = Person.objects.get(id=person_id)
        success = add_team_member(team, person)
        
        if success:
            return Response({"status": "Member added successfully"})
        else:
            return Response(
                {"error": "Person is already a member of this team"},
                status=status.HTTP_400_BAD_REQUEST
            )
    except Team.DoesNotExist:
        return Response(
            {"error": f"Team with ID {team_id} not found"},
            status=status.HTTP_404_NOT_FOUND
        )
    except Person.DoesNotExist:
        return Response(
            {"error": f"Person with ID {person_id} not found"},
            status=status.HTTP_404_NOT_FOUND
        )

def api_remove_team_member(request, team_id):
    """
    API endpoint to remove a member from a team
    
    Args:
        request: HTTP request
        team_id (int): Team ID
        
    Returns:
        Response: HTTP response
    """
    person_id = request.data.get('person_id')
    
    if not person_id:
        return Response(
            {"error": "Missing required field: person_id"},
            status=status.HTTP_400_BAD_REQUEST
        )
    
    try:
        team = Team.objects.get(id=team_id)
        person = Person.objects.get(id=person_id)
        success = remove_team_member(team, person)
        
        if success:
            return Response({"status": "Member removed successfully"})
        else:
            return Response(
                {"error": "Person is not a member of this team"},
                status=status.HTTP_400_BAD_REQUEST
            )
    except Team.DoesNotExist:
        return Response(
            {"error": f"Team with ID {team_id} not found"},
            status=status.HTTP_404_NOT_FOUND
        )
    except Person.DoesNotExist:
        return Response(
            {"error": f"Person with ID {person_id} not found"},
            status=status.HTTP_404_NOT_FOUND
        )

```

#----------------------------------------------------------------------------------------------------

# core\services\team\functions.py =================================================

core\services\team\functions.py:
```python
from core.models import Team, Person, Project
from core.services.history.team import (
    record_team_creation,
    record_team_update,
    record_team_member_addition,
    record_team_member_removal,
    record_team_deletion
)

def get_team_by_id(team_id):
    """
    Get team by ID
    
    Args:
        team_id (int): Team ID
    
    Returns:
        Team: The team object
    """
    return Team.objects.get(id=team_id)

def get_teams_by_department(department_id):
    """
    Get teams that have members from a specific department
    
    Args:
        department_id (int): Department ID
    
    Returns:
        list: Teams with members from the specified department
    """
    # Get persons in the department
    persons = Person.objects.filter(department_id=department_id)
    
    # Get unique teams these persons belong to
    teams = set()
    for person in persons:
        for team in person.teams.all():
            teams.add(team)
    
    return list(teams)

def get_teams_by_project(project_id):
    """
    Get teams associated with a project
    
    Args:
        project_id (int): Project ID
    
    Returns:
        QuerySet: Teams associated with the project
    """
    try:
        project = Project.objects.get(id=project_id)
        return project.teams.all()
    except Project.DoesNotExist:
        return Team.objects.none()

def update_team(team, name=None, description=None):
    """
    Update team information
    
    Args:
        team: Team object
        name (str): New name (if None, keep existing)
        description (str): New description (if None, keep existing)
    
    Returns:
        Team: The updated team
    """
    updated_fields = []
    
    if name is not None and name != team.name:
        team.name = name
        updated_fields.append('name')
    
    if description is not None and description != team.description:
        team.description = description
        updated_fields.append('description')
    
    if updated_fields:
        team.save()
        record_team_update(team, updated_fields)
    
    return team

def add_team_member(team, person):
    """
    Add a person to a team
    
    Args:
        team: Team object
        person: Person object
    
    Returns:
        bool: True if added, False if already a member
    """
    if team not in person.teams.all():
        person.teams.add(team)
        record_team_member_addition(team, person.id)
        return True
    return False

def remove_team_member(team, person):
    """
    Remove a person from a team
    
    Args:
        team: Team object
        person: Person object
    
    Returns:
        bool: True if removed, False if not a member
    """
    if team in person.teams.all():
        person.teams.remove(team)
        record_team_member_removal(team, person.id)
        return True
    return False

def delete_team(team):
    """
    Delete a team
    
    Args:
        team: Team object
    """
    # Check for projects using this team
    projects_count = Project.objects.filter(teams=team).count()
    if projects_count > 0:
        raise ValueError(f"Cannot delete team. It is associated with {projects_count} projects.")
    
    # Remove team from all persons
    for person in team.members.all():
        person.teams.remove(team)
    
    record_team_deletion(team)
    team.delete()

def get_team_members(team_id):
    """
    Get all members of a team
    
    Args:
        team_id (int): Team ID
    
    Returns:
        QuerySet: Persons in the team
    """
    team = Team.objects.get(id=team_id)
    return team.members.all()

def get_team_projects(team_id):
    """
    Get all projects associated with a team
    
    Args:
        team_id (int): Team ID
    
    Returns:
        QuerySet: Projects associated with the team
    """
    team = Team.objects.get(id=team_id)
    return Project.objects.filter(teams=team)

def check_team_dependencies(team_id):
    """
    Check if a team has dependencies that would prevent deletion
    
    Args:
        team_id (int): Team ID
        
    Returns:
        dict: Dictionary of dependencies
    """
    try:
        team = Team.objects.get(id=team_id)
        projects = Project.objects.filter(teams=team)
        
        dependencies = {
            'projects': [{'id': p.id, 'name': p.name} for p in projects],
            'members_count': team.members.count()
        }
        
        return dependencies
    except Team.DoesNotExist:
        return {'error': 'Team not found'}

```

#----------------------------------------------------------------------------------------------------

# core\services\team\initialization.py ============================================

core\services\team\initialization.py:
```python
from core.models import Team
import uuid

def initialize_team(name, description=''):
    """
    Initialize a new team
    
    Args:
        name (str): Team name
        description (str): Team description
    
    Returns:
        Team: The created team
    """
    # Generate unique history ID
    history_id = f"{uuid.uuid4().hex}team"
    
    team = Team.objects.create(
        name=name,
        description=description,
        history_id=history_id
    )
    
    return team

```

#----------------------------------------------------------------------------------------------------

# core\services\template\__init__.py ==============================================

core\services\template\__init__.py:
```python
# Template service module

```

#----------------------------------------------------------------------------------------------------

# core\services\template\api.py ===================================================

core\services\template\api.py:
```python
from core.models import PhaseTemplate, OutputTemplate
from core.services.template.initialization import (
    initialize_phase_template,
    initialize_output_template
)
from core.services.template.functions import (
    get_phase_template_by_id,
    get_output_template_by_id,
    get_phase_templates_by_level,
    get_output_templates_by_phase,
    get_output_templates_by_element,
    update_phase_template_name,
    update_phase_template_description,
    update_phase_template_order,
    update_phase_template_ppap_levels,
    update_output_template_name,
    update_output_template_configuration,
    update_output_template_phase,
    clone_phase_template,
    clone_output_template,
    delete_phase_template,
    delete_output_template
)

__all__ = [
    'initialize_phase_template',
    'initialize_output_template',
    'get_phase_template_by_id',
    # ... other functions ...
]

def update_phase_template(template, name=None, description=None, order=None, ppap_levels=None):
    """
    Update phase template
    
    Args:
        template (PhaseTemplate): Template to update
        name (str, optional): New name
        description (str, optional): New description
        order (int, optional): New order
        ppap_levels (list, optional): New PPAP levels
        
    Returns:
        PhaseTemplate: Updated template
    """
    if name is not None:
        update_phase_template_name(template, name)
    
    if description is not None:
        update_phase_template_description(template, description)
    
    if order is not None:
        update_phase_template_order(template, order)
    
    if ppap_levels is not None:
        update_phase_template_ppap_levels(template, ppap_levels)
    
    return template

def update_output_template(template, name=None, configuration=None):
    """
    Update output template
    
    Args:
        template (OutputTemplate): Template to update
        name (str, optional): New name
        configuration (dict, optional): New configuration
        
    Returns:
        OutputTemplate: Updated template
    """
    if name is not None:
        update_output_template_name(template, name)
    
    if configuration is not None:
        update_output_template_configuration(template, configuration)
    
    return template

def delete_phase_template(template):
    """
    Delete phase template
    
    Args:
        template (PhaseTemplate): Template to delete
        
    Raises:
        ValueError: If template has dependencies
    """
    # Check if template has output templates
    if OutputTemplate.objects.filter(phase_template=template).exists():
        raise ValueError("Cannot delete template with dependencies")
    
    template.delete()

def delete_output_template(template):
    """
    Delete output template
    
    Args:
        template (OutputTemplate): Template to delete
    """
    template.delete()

```

#----------------------------------------------------------------------------------------------------

# core\services\template\functions.py =============================================

core\services\template\functions.py:
```python
from core.models import PhaseTemplate, OutputTemplate




def get_phase_template_by_id(template_id):
    """
    Get phase template by ID
    
    Args:
        template_id (int): Template ID
        
    Returns:
        PhaseTemplate: The template object
        
    Raises:
        PhaseTemplate.DoesNotExist: If template not found
    """
    return PhaseTemplate.objects.get(id=template_id)

def get_output_template_by_id(template_id):
    """
    Get output template by ID
    
    Args:
        template_id (int): Template ID
        
    Returns:
        OutputTemplate: The template object
        
    Raises:
        OutputTemplate.DoesNotExist: If template not found
    """
    return OutputTemplate.objects.get(id=template_id)

def get_phase_templates_by_level(level):
    """
    Get phase templates by PPAP level
    
    Args:
        level (int): PPAP level
        
    Returns:
        QuerySet: Templates for the given level
    """
    return PhaseTemplate.objects.filter(ppap_levels__contains=[level]).order_by('order')

def get_output_templates_by_phase(phase_id):
    """
    Get output templates by phase template
    
    Args:
        phase_id (int): Phase template ID
        
    Returns:
        QuerySet: Templates for the given phase
    """
    return OutputTemplate.objects.filter(phase_template_id=phase_id)

def get_output_templates_by_element(element_id):
    """
    Get output templates by PPAP element
    
    Args:
        element_id (int): PPAP element ID
        
    Returns:
        QuerySet: Templates for the given element
    """
    return OutputTemplate.objects.filter(ppap_element_id=element_id)

def update_phase_template_name(template, name):
    """
    Update phase template name
    
    Args:
        template (PhaseTemplate): Template to update
        name (str): New name
        
    Returns:
        PhaseTemplate: Updated template
    """
    old_name = template.name
    template.name = name
    template.save()
    
    # Record history
    
    return template

def update_phase_template_description(template, description):
    """
    Update phase template description
    
    Args:
        template (PhaseTemplate): Template to update
        description (str): New description
        
    Returns:
        PhaseTemplate: Updated template
    """
    template.description = description
    template.save()
    
    # Record history
    
    return template

def update_phase_template_order(template, order):
    """
    Update phase template order
    
    Args:
        template (PhaseTemplate): Template to update
        order (int): New order
        
    Returns:
        PhaseTemplate: Updated template
    """
    old_order = template.order
    template.order = order
    template.save()
    
    # Record history
    
    return template

def update_phase_template_ppap_levels(template, ppap_levels):
    """
    Update phase template PPAP levels
    
    Args:
        template (PhaseTemplate): Template to update
        ppap_levels (list): New PPAP levels
        
    Returns:
        PhaseTemplate: Updated template
    """
    template.ppap_levels = ppap_levels
    template.save()
    
    # Record history
    
    return template

def update_output_template_name(template, name):
    """
    Update output template name
    
    Args:
        template (OutputTemplate): Template to update
        name (str): New name
        
    Returns:
        OutputTemplate: Updated template
    """
    old_name = template.name
    template.name = name
    template.save()
    
    # Record history
    
    return template

def update_output_template_configuration(template, configuration):
    """
    Update output template configuration
    
    Args:
        template (OutputTemplate): Template to update
        configuration (dict): New configuration
        
    Returns:
        OutputTemplate: Updated template
    """
    old_config = template.configuration
    template.configuration = configuration
    template.save()
    
    # Record history
    
    return template

def update_output_template_phase(template, phase_template_id):
    """
    Update output template phase
    
    Args:
        template (OutputTemplate): Template to update
        phase_template_id (int): New phase template ID
        
    Returns:
        OutputTemplate: Updated template
    """
    old_phase_id = template.phase_template.id if template.phase_template else None
    
    # Get the phase template
    phase_template = get_phase_template_by_id(phase_template_id)
    
    # Update the template
    template.phase_template = phase_template
    template.save()
    
    # Record history
    
    return template

def clone_phase_template(template_id, new_name=None):
    """
    Clone a phase template
    
    Args:
        template_id (int): Template ID to clone
        new_name (str, optional): Name for the cloned template
        
    Returns:
        PhaseTemplate: The cloned template
    """
    original = get_phase_template_by_id(template_id)
    
    # Create new template
    clone = PhaseTemplate.objects.create(
        name=new_name or f"Copy of {original.name}",
        description=original.description,
        order=original.order,
        ppap_levels=original.ppap_levels
    )
    
    # Record history
    
    return clone

def clone_output_template(template_id, new_name=None):
    """
    Clone an output template
    
    Args:
        template_id (int): Template ID to clone
        new_name (str, optional): Name for the cloned template
        
    Returns:
        OutputTemplate: The cloned template
    """
    original = get_output_template_by_id(template_id)
    
    # Create new template
    clone = OutputTemplate.objects.create(
        name=new_name or f"Copy of {original.name}",
        phase_template=original.phase_template,
        ppap_element=original.ppap_element,
        configuration=original.configuration
    )
    
    # Record history
    
    return clone

def create_phase_template(name, description=None, order=None, ppap_levels=None):
    """
    Create a new phase template
    
    Args:
        name (str): Template name
        description (str, optional): Template description
        order (int, optional): Template order
        ppap_levels (list, optional): PPAP levels
        
    Returns:
        PhaseTemplate: Created template
    """
    from core.services.template.initialization import initialize_phase_template
    return initialize_phase_template(
        name=name,
        description=description or "",
        order=order or 0,
        ppap_levels=ppap_levels
    )

def create_output_template(name, phase_template_id, ppap_element_id=None, configuration=None):
    """
    Create a new output template
    
    Args:
        name (str): Template name
        phase_template_id (int): Phase template ID
        ppap_element_id (int, optional): PPAP element ID
        configuration (dict, optional): Template configuration
        
    Returns:
        OutputTemplate: Created template
    """
    # Get related objects
    phase_template = get_phase_template_by_id(phase_template_id)
    
    ppap_element = None
    if ppap_element_id:
        from core.models import PPAPElement
        ppap_element = PPAPElement.objects.get(id=ppap_element_id)
    
    from core.services.template.initialization import initialize_output_template
    return initialize_output_template(
        name=name,
        phase_template=phase_template,
        ppap_element=ppap_element,
        configuration=configuration
    )

def delete_phase_template(template_id):
    """
    Delete a phase template
    
    Args:
        template_id (int): Template ID to delete
        
    Returns:
        bool: True if deleted, False otherwise
    """
    try:
        template = get_phase_template_by_id(template_id)
        
        # Record history before deletion
        
        # Delete the template
        template.delete()
        return True
    except Exception:
        return False

def delete_output_template(template_id):
    """
    Delete an output template
    
    Args:
        template_id (int): Template ID to delete
        
    Returns:
        bool: True if deleted, False otherwise
    """
    try:
        template = get_output_template_by_id(template_id)
        
        # Record history before deletion
        
        # Delete the template
        template.delete()
        return True
    except Exception:
        return False

```

#----------------------------------------------------------------------------------------------------

# core\services\template\initialization.py ========================================

core\services\template\initialization.py:
```python
from core.models import PhaseTemplate, OutputTemplate

def initialize_phase_template(name, description='', order=0, ppap_levels=None):
    """
    Initialize a new phase template
    
    Args:
        name (str): Template name
        description (str, optional): Template description
        order (int, optional): Template order
        ppap_levels (list, optional): PPAP levels
        
    Returns:
        PhaseTemplate: The created template
    """
    template = PhaseTemplate.objects.create(
        name=name,
        description=description,
        order=order
    )
    
    # Set PPAP levels if provided
    if ppap_levels:
        template.ppap_levels = ppap_levels
        template.save()
    
    # Record in history
    
    return template

def initialize_output_template(name, phase_template, ppap_element, configuration=None):
    """
    Initialize a new output template
    
    Args:
        name (str): Template name
        phase_template (PhaseTemplate): Associated phase template
        ppap_element (PPAPElement): Associated PPAP element
        configuration (dict, optional): Template configuration
        
    Returns:
        OutputTemplate: The created template
    """
    template = OutputTemplate.objects.create(
        name=name,
        phase=phase_template,  # Changed from phase_template to phase
        ppap_element=ppap_element,
        configuration=configuration or {}
    )
    
    return template

```

#----------------------------------------------------------------------------------------------------

# core\services\timeline\__init__.py ==============================================

core\services\timeline\__init__.py:
```python
# Timeline services

```

#----------------------------------------------------------------------------------------------------

# core\services\timeline\api.py ===================================================

core\services\timeline\api.py:
```python
# Define all API here
from core.services.timeline.functions import (
    set_project_timeline,
    set_phase_timeline,
    update_timeline_progress,
    get_timeline_overview
)

# Export all functions for use in views
__all__ = [
    'set_project_timeline',
    'set_phase_timeline',
    'update_timeline_progress',
    'get_timeline_overview'
]

```

#----------------------------------------------------------------------------------------------------

# core\services\timeline\functions.py =============================================

core\services\timeline\functions.py:
```python
from datetime import datetime, timedelta
from django.db import transaction
from core.models import Project, PPAP, Phase, Output, History

def set_project_timeline(project_id, deadline):
    """
    Set project timeline with deadline and calculate phase deadlines
    """
    project = Project.objects.get(id=project_id)
    ppap = project.ppap
    
    # Update history record with deadline
    history = History.objects.get(id=project.history_id)
    history.deadline = deadline
    history.save()
    
    # Calculate phase deadlines
    phases = Phase.objects.filter(ppap=ppap).order_by('template__order')
    total_phases = phases.count()
    
    if total_phases > 0:
        # Calculate time per phase
        now = datetime.now()
        total_days = (deadline - now).days
        days_per_phase = max(1, total_days // total_phases)
        
        # Set phase deadlines
        current_deadline = now
        for i, phase in enumerate(phases):
            # Last phase gets the project deadline
            if i == total_phases - 1:
                phase_deadline = deadline
            else:
                # Add days for this phase
                current_deadline += timedelta(days=days_per_phase)
                phase_deadline = current_deadline
            
            # Update phase history with deadline
            phase_history = History.objects.get(id=phase.history_id)
            phase_history.deadline = phase_deadline
            phase_history.save()
            
            # Calculate output deadlines within this phase
            set_phase_timeline(phase.id, phase_deadline)
    
    return True

def set_phase_timeline(phase_id, deadline):
    """
    Set phase timeline with deadline and calculate output deadlines
    """
    phase = Phase.objects.get(id=phase_id)
    
    # Update history record with deadline
    history = History.objects.get(id=phase.history_id)
    history.deadline = deadline
    history.save()
    
    # Calculate output deadlines
    outputs = Output.objects.filter(phase=phase)
    total_outputs = outputs.count()
    
    if total_outputs > 0:
        # Calculate time per output
        now = datetime.now()
        total_days = (deadline - now).days
        days_per_output = max(1, total_days // total_outputs)
        
        # Set output deadlines
        current_deadline = now
        for i, output in enumerate(outputs):
            # Last output gets the phase deadline
            if i == total_outputs - 1:
                output_deadline = deadline
            else:
                # Add days for this output
                current_deadline += timedelta(days=days_per_output)
                output_deadline = current_deadline
            
            # Update output history with deadline
            output_history = History.objects.get(id=output.history_id)
            output_history.deadline = output_deadline
            output_history.save()
    
    return True

def update_timeline_progress(entity_type, entity_id, status):
    """
    Update timeline progress based on status changes
    """
    now = datetime.now()
    
    if entity_type == 'project':
        project = Project.objects.get(id=entity_id)
        history = History.objects.get(id=project.history_id)
        
        if status == 'In Progress' and not history.started_at:
            history.started_at = now
        elif status in ['Completed', 'Archived']:
            history.finished_at = now
        
        history.save()
    
    elif entity_type == 'ppap':
        ppap = PPAP.objects.get(id=entity_id)
        history = History.objects.get(id=ppap.history_id)
        
        if status == 'In Progress' and not history.started_at:
            history.started_at = now
        elif status in ['Completed', 'Approved']:
            history.finished_at = now
        
        history.save()
    
    elif entity_type == 'phase':
        phase = Phase.objects.get(id=entity_id)
        history = History.objects.get(id=phase.history_id)
        
        if status == 'In Progress' and not history.started_at:
            history.started_at = now
        elif status in ['Completed', 'Approved']:
            history.finished_at = now
        
        history.save()
    
    elif entity_type == 'output':
        output = Output.objects.get(id=entity_id)
        history = History.objects.get(id=output.history_id)
        
        if status == 'In Progress' and not history.started_at:
            history.started_at = now
        elif status in ['Completed', 'Approved']:
            history.finished_at = now
        
        history.save()
    
    return True

def get_timeline_overview(project_id):
    """
    Get timeline overview for a project
    """
    project = Project.objects.get(id=project_id)
    ppap = project.ppap
    
    # Get project timeline
    project_history = History.objects.get(id=project.history_id)
    project_timeline = {
        'started_at': project_history.started_at,
        'deadline': project_history.deadline,
        'finished_at': project_history.finished_at,
        'status': project.status
    }
    
    # Get phase timelines
    phases = Phase.objects.filter(ppap=ppap).order_by('template__order')
    phase_timelines = []
    
    for phase in phases:
        phase_history = History.objects.get(id=phase.history_id)
        phase_timelines.append({
            'id': phase.id,
            'name': phase.template.name,
            'started_at': phase_history.started_at,
            'deadline': phase_history.deadline,
            'finished_at': phase_history.finished_at,
            'status': phase.status
        })
    
    # Get output timelines
    output_timelines = []
    for phase in phases:
        outputs = Output.objects.filter(phase=phase)
        for output in outputs:
            output_history = History.objects.get(id=output.history_id)
            output_timelines.append({
                'id': output.id,
                'name': output.template.name,
                'phase_id': phase.id,
                'phase_name': phase.template.name,
                'started_at': output_history.started_at,
                'deadline': output_history.deadline,
                'finished_at': output_history.finished_at,
                'status': output.status
            })
    
    return {
        'project': project_timeline,
        'phases': phase_timelines,
        'outputs': output_timelines
    }

```

#----------------------------------------------------------------------------------------------------

# core\services\todo\__init__.py ==================================================

core\services\todo\__init__.py:
```python
# Todo service module

```

#----------------------------------------------------------------------------------------------------

# core\services\todo\api.py =======================================================

core\services\todo\api.py:
```python
from core.models import Todo
from core.services.todo.initialization import initialize_todo
from core.services.todo.functions import (
    get_todo_by_id,
    get_todos_by_person,
    get_todos_by_output,
    get_todos_by_status,
    update_todo_title,
    update_todo_description,
    update_todo_priority,
    update_todo_status,
    update_todo_assigned_to
)

def update_todo(todo, title=None, description=None, priority=None):
    """
    Update todo
    
    Args:
        todo (Todo): Todo to update
        title (str, optional): New title
        description (str, optional): New description
        priority (str, optional): New priority
        
    Returns:
        Todo: Updated todo
    """
    if title is not None:
        update_todo_title(todo, title)
    
    if description is not None:
        update_todo_description(todo, description)
    
    if priority is not None:
        update_todo_priority(todo, priority)
    
    return todo

def change_todo_status(todo, status):
    """
    Change todo status
    
    Args:
        todo (Todo): Todo to update
        status (str): New status
        
    Returns:
        Todo: Updated todo
    """
    return update_todo_status(todo, status)

def reassign_todo(todo, person):
    """
    Reassign todo to another person
    
    Args:
        todo (Todo): Todo to update
        person (Person): New assigned person
        
    Returns:
        Todo: Updated todo
    """
    return update_todo_assigned_to(todo, person)

def delete_todo(todo):
    """
    Delete todo
    
    Args:
        todo (Todo): Todo to delete
    """
    todo.delete()

```

#----------------------------------------------------------------------------------------------------

# core\services\todo\functions.py =================================================

core\services\todo\functions.py:
```python
from core.models import Todo, Person, Output
from django.utils import timezone

def get_todo_by_id(todo_id):
    """
    Get todo by ID
    
    Args:
        todo_id (int): Todo ID
        
    Returns:
        Todo: The todo object
        
    Raises:
        Todo.DoesNotExist: If todo not found
    """
    return Todo.objects.get(id=todo_id)

def get_todos_by_person(person_id):
    """
    Get todos by assigned person
    
    Args:
        person_id (int): Person ID
        
    Returns:
        QuerySet: Todos assigned to the person
    """
    return Todo.objects.filter(assigned_to_id=person_id)

def get_todos_by_output(output_id):
    """
    Get todos by output
    
    Args:
        output_id (int): Output ID
        
    Returns:
        QuerySet: Todos for the given output
    """
    return Todo.objects.filter(output_id=output_id)

def get_todos_by_status(status):
    """
    Get todos by status
    
    Args:
        status (str): Todo status
        
    Returns:
        QuerySet: Todos with the given status
    """
    return Todo.objects.filter(status=status)

def update_todo_title(todo, title):
    """
    Update todo title
    
    Args:
        todo (Todo): Todo to update
        title (str): New title
        
    Returns:
        Todo: Updated todo
    """
    todo.title = title
    todo.save()
    return todo

def update_todo_description(todo, description):
    """
    Update todo description
    
    Args:
        todo (Todo): Todo to update
        description (str): New description
        
    Returns:
        Todo: Updated todo
    """
    todo.description = description
    todo.save()
    return todo

def update_todo_priority(todo, priority):
    """
    Update todo priority
    
    Args:
        todo (Todo): Todo to update
        priority (str): New priority
        
    Returns:
        Todo: Updated todo
    """
    todo.priority = priority
    todo.save()
    return todo

def update_todo_status(todo, status):
    """
    Update todo status
    
    Args:
        todo (Todo): Todo to update
        status (str): New status
        
    Returns:
        Todo: Updated todo
    """
    todo.status = status
    
    # Set completion date if status is 'completed'
    if status == 'completed':
        todo.completed_at = timezone.now()
    else:
        todo.completed_at = None
    
    todo.save()
    return todo

def update_todo_assigned_to(todo, assigned_to):
    """
    Update todo assigned person
    
    Args:
        todo (Todo): Todo to update
        assigned_to (Person): New assigned person
        
    Returns:
        Todo: Updated todo
    """
    todo.assigned_to = assigned_to
    todo.save()
    return todo

def delete_todo(todo):
    """
    Delete a todo
    
    Args:
        todo: Todo object
    """
    todo.delete()

```

#----------------------------------------------------------------------------------------------------

# core\services\todo\initialization.py ============================================

core\services\todo\initialization.py:
```python
from core.models import Todo

def initialize_todo(title, assigned_to, description='', output=None, priority='medium'):
    """
    Initialize a new todo
    
    Args:
        title (str): Todo title
        assigned_to (Person): Person assigned to the todo
        description (str, optional): Todo description
        output (Output, optional): Associated output
        priority (str, optional): Todo priority (low, medium, high)
        
    Returns:
        Todo: The created todo
    """
    todo = Todo.objects.create(
        title=title,
        description=description,
        assigned_to=assigned_to,
        output=output,
        priority=priority,
        status='pending'
    )
    
    return todo

```

#----------------------------------------------------------------------------------------------------

# core\urls.py ====================================================================

core\urls.py:
```python
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from core.views import (
    project_view, ppap_view, phase_view, output_view, document_view, 
    user_view, client_view, team_view, history_view, api_view, timeline_view,
    person_view, contact_view, department_view, template_view, todo_view,
    ppap_element_view, authorization_view ,auth_api
)

# Set up the REST API router
router = DefaultRouter()
router.register(r'projects', project_view.ProjectViewSet)
router.register(r'ppaps', ppap_view.PPAPViewSet)
router.register(r'phases', phase_view.PhaseViewSet)
router.register(r'outputs', output_view.OutputViewSet)
router.register(r'documents', document_view.DocumentViewSet)
router.register(r'users', user_view.UserViewSet)
router.register(r'clients', client_view.ClientViewSet)
router.register(r'teams', team_view.TeamViewSet)
router.register(r'history', history_view.HistoryViewSet)
router.register(r'timeline', timeline_view.TimelineViewSet, basename='timeline')
router.register(r'persons', person_view.PersonViewSet)
router.register(r'contacts', contact_view.ContactViewSet)
router.register(r'departments', department_view.DepartmentViewSet)
router.register(r'phase-templates', template_view.PhaseTemplateViewSet)
router.register(r'output-templates', template_view.OutputTemplateViewSet)
router.register(r'todos', todo_view.TodoViewSet)
router.register(r'ppap-elements', ppap_element_view.PPAPElementViewSet)
router.register(r'authorizations', authorization_view.AuthorizationViewSet)

# Get a reference to the ViewSet class
timeline_viewset = timeline_view.TimelineViewSet.as_view({
    'post': 'set_project_timeline'
})
phase_timeline_viewset = timeline_view.TimelineViewSet.as_view({
    'post': 'set_phase_timeline'
})
timeline_overview_viewset = timeline_view.TimelineViewSet.as_view({
    'get': 'overview'
})

# Define URL patterns
urlpatterns = [
    # Include all router URLs
    path('', include(router.urls)),
    
    # API testing endpoint
    path('test/', api_view.test_api, name='test_api'),
    
    # Dashboard view
    path('dashboard/', api_view.dashboard_view, name='dashboard'),
    
    # User permissions
    path('user-permissions/', api_view.user_permissions_view, name='user-permissions'),
    
    # Status changes
    path('change-status/', api_view.change_status_view, name='change-status'),
    
    # Permission assignment
    path('assign-permission/', api_view.assign_permission_view, name='assign-permission'),
    
    # Phase responsibility
    path('assign-phase-responsible/', api_view.assign_phase_responsible_view, name='assign-phase-responsible'),
    


    # Authentication endpoints
    path('auth/login/', auth_api.api_login, name='api_login'),
    path('auth/logout/', auth_api.api_logout, name='api_logout'),
    path('auth/user/', auth_api.api_get_user, name='api_get_user'),
]

```

#----------------------------------------------------------------------------------------------------

# core\views.py ===================================================================

core\views.py:
```python
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from django.db import transaction
from core.models import (
    Project, PPAP, Phase, Output, Document, User, Client, Team,
    Person, Contact, Department, History, FastQuery, PhaseTemplate,
    OutputTemplate, PPAPElement, Todo, Permission, Authorization
)
from core.serializers import (
    ProjectSerializer, PPAPSerializer, PhaseSerializer, OutputSerializer,
    DocumentSerializer, UserSerializer, ClientSerializer, TeamSerializer,
    PersonSerializer, ContactSerializer, DepartmentSerializer, HistorySerializer,
    FastQuerySerializer, PhaseTemplateSerializer, OutputTemplateSerializer,
    PPAPElementSerializer, TodoSerializer, PermissionSerializer, AuthorizationSerializer
)
from core.services.project.initialization import initialize_project
from core.services.history.initialization import initialize_history

class ProjectViewSet(viewsets.ModelViewSet):
    queryset = Project.objects.all()
    serializer_class = ProjectSerializer
    
    @transaction.atomic
    def create(self, request, *args, **kwargs):
        # Extract data for project initialization
        name = request.data.get('name')
        description = request.data.get('description', '')
        client_id = request.data.get('client_id')
        team_id = request.data.get('team_id')
        ppap_level = request.data.get('ppap_level', 3)
        
        # Validate required fields
        if not all([name, client_id, team_id]):
            return Response(
                {"error": "Missing required fields: name, client_id, team_id"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # Initialize project with all related records
        try:
            project = initialize_project(name, description, client_id, team_id, ppap_level)
            serializer = self.get_serializer(project)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    @action(detail=True, methods=['get'])
    def history(self, request, pk=None):
        project = self.get_object()
        history_records = History.objects.filter(id=project.history_id)
        serializer = HistorySerializer(history_records, many=True)
        return Response(serializer.data)

class PPAPViewSet(viewsets.ModelViewSet):
    queryset = PPAP.objects.all()
    serializer_class = PPAPSerializer
    
    @action(detail=True, methods=['get'])
    def history(self, request, pk=None):
        ppap = self.get_object()
        history_records = History.objects.filter(id=ppap.history_id)
        serializer = HistorySerializer(history_records, many=True)
        return Response(serializer.data)

class PhaseViewSet(viewsets.ModelViewSet):
    queryset = Phase.objects.all()
    serializer_class = PhaseSerializer
    
    @action(detail=True, methods=['get'])
    def history(self, request, pk=None):
        phase = self.get_object()
        history_records = History.objects.filter(id=phase.history_id)
        serializer = HistorySerializer(history_records, many=True)
        return Response(serializer.data)

class OutputViewSet(viewsets.ModelViewSet):
    queryset = Output.objects.all()
    serializer_class = OutputSerializer
    
    @action(detail=True, methods=['get'])
    def history(self, request, pk=None):
        output = self.get_object()
        history_records = History.objects.filter(id=output.history_id)
        serializer = HistorySerializer(history_records, many=True)
        return Response(serializer.data)
    
    @transaction.atomic
    def update(self, request, *args, **kwargs):
        output = self.get_object()
        serializer = self.get_serializer(output, data=request.data, partial=True)
        
        if serializer.is_valid():
            # Save the output
            output = serializer.save()
            
            # Record the update in history
            initialize_history(
                title=f"{output.template.name}",
                event=f"Output updated: {', '.join(request.data.keys())}",
                table_name='output',
                history_id=output.history_id
            )
            
            # Check if status changed to 'Completed'
            if 'status' in request.data and request.data['status'] == 'Completed':
                # Update phase status if all outputs are completed
                phase = output.phase
                all_outputs_completed = all(o.status == 'Completed' for o in phase.outputs.all())
                
                if all_outputs_completed and phase.status != 'Completed':
                    phase.status = 'Completed'
                    phase.save()
                    
                    # Record phase completion in history
                    initialize_history(
                        title=f"{phase.template.name}",
                        event=f"Phase marked as Completed as all outputs are completed",
                        table_name='phase',
                        history_id=phase.history_id
                    )
                    
                    # Check if all phases are completed to update PPAP status
                    ppap = phase.ppap
                    all_phases_completed = all(p.status == 'Completed' for p in ppap.phases.all())
                    
                    if all_phases_completed and ppap.status != 'Completed':
                        ppap.status = 'Completed'
                        ppap.save()
                        
                        # Record PPAP completion in history
                        initialize_history(
                            title=f"PPAP for Project {ppap.project_id}",
                            event=f"PPAP marked as Completed as all phases are completed",
                            table_name='ppap',
                            history_id=ppap.history_id
                        )
            
            return Response(serializer.data)
        
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

class DocumentViewSet(viewsets.ModelViewSet):
    queryset = Document.objects.all()
    serializer_class = DocumentSerializer
    
    @transaction.atomic
    def create(self, request, *args, **kwargs):
        # Extract data
        name = request.data.get('name')
        description = request.data.get('description', '')
        output_id = request.data.get('output_id')
        file_type = request.data.get('file_type')
        file_content = request.data.get('file_content')  # Base64 encoded content
        
        # Validate required fields
        if not all([name, output_id, file_type, file_content]):
            return Response(
                {"error": "Missing required fields: name, output_id, file_type, file_content"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # TODO: Handle file storage (simplified for this implementation)
        file_path = f"documents/{name}.{file_type}"
        file_size = len(file_content)
        
        # Create document
        try:
            document = Document.objects.create(
                name=name,
                description=description,
                file_path=file_path,
                file_type=file_type,
                file_size=file_size,
                uploader_id=request.user.id,
                output_id=output_id,
                version="1.0",
                status="Draft"
            )
            
            # Record in history
            initialize_history(
                title=name,
                event=f"Document uploaded for Output {output_id}",
                table_name='document',
                history_id=document.history_id
            )
            
            serializer = self.get_serializer(document)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )

class UserViewSet(viewsets.ModelViewSet):
    queryset = User.objects.all()
    serializer_class = UserSerializer
    
    @transaction.atomic
    def create(self, request, *args, **kwargs):
        # Extract user data
        username = request.data.get('username')
        password = request.data.get('password')
        first_name = request.data.get('first_name')
        last_name = request.data.get('last_name')
        email = request.data.get('email')
        department_id = request.data.get('department_id')
        team_id = request.data.get('team_id')
        authorization_id = request.data.get('authorization_id')
        
        # Validate required fields
        if not all([username, password, first_name, last_name, email, authorization_id]):
            return Response(
                {"error": "Missing required fields"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            # Create person record
            person = Person.objects.create(
                first_name=first_name,
                last_name=last_name,
                department_id=department_id,
                team_id=team_id,
                is_user=True
            )
            
            # Create contact record
            contact = Contact.objects.create(
                id=person.contact_id,
                email=email,
                address="",
                phone="",
                type="user"
            )
            
            # Create user
            user = User.objects.create_user(
                username=username,
                password=password,
                person=person,
                authorization_id=authorization_id
            )
            
            # Record in history
            initialize_history(
                title=username,
                event=f"User created with ID {user.id}",
                table_name='user',
                history_id=user.history_id
            )
            
            serializer = self.get_serializer(user)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )

class ClientViewSet(viewsets.ModelViewSet):
    queryset = Client.objects.all()
    serializer_class = ClientSerializer
    
    @transaction.atomic
    def create(self, request, *args, **kwargs):
        # Extract client data
        name = request.data.get('name')
        address = request.data.get('address')
        code = request.data.get('code', {})
        description = request.data.get('description', '')
        contact_data = request.data.get('contact', {})
        
        # Validate required fields
        if not all([name, address]):
            return Response(
                {"error": "Missing required fields: name, address"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            # Create client
            client = Client.objects.create(
                name=name,
                address=address,
                code=code,
                description=description
            )
            
            # Create contact
            contact = Contact.objects.create(
                id=client.contact_id,
                address=contact_data.get('address', address),
                email=contact_data.get('email', ''),
                phone=contact_data.get('phone', ''),
                type='client'
            )
            
            # Record in history
            initialize_history(
                title=name,
                event=f"Client created with ID {client.id}",
                table_name='client',
                history_id=client.history_id
            )
            
            serializer = self.get_serializer(client)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )

class TeamViewSet(viewsets.ModelViewSet):
    queryset = Team.objects.all()
    serializer_class = TeamSerializer
    
    @transaction.atomic
    def create(self, request, *args, **kwargs):
        # Extract team data
        name = request.data.get('name')
        description = request.data.get('description', '')
        members = request.data.get('members', [])
        
        # Validate required fields
        if not name:
            return Response(
                {"error": "Missing required field: name"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            # Create team
            team = Team.objects.create(
                name=name,
                description=description
            )
            
            # Add members if provided
            if members:
                Person.objects.filter(id__in=members).update(team=team)
            
            # Record in history
            initialize_history(
                title=name,
                event=f"Team created with ID {team.id}",
                table_name='team',
                history_id=team.history_id
            )
            
            serializer = self.get_serializer(team)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )

class HistoryViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = History.objects.all()
    serializer_class = HistorySerializer
    
    @action(detail=False, methods=['get'])
    def project(self, request, project_id=None):
        project_id = request.query_params.get('project_id')
        if not project_id:
            return Response(
                {"error": "Missing required parameter: project_id"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            project = Project.objects.get(id=project_id)
            history_records = History.objects.filter(id=project.history_id)
            
            # Get related history records
            if project.ppap:
                ppap_history = History.objects.filter(id=project.ppap.history_id)
                history_records = history_records.union(ppap_history)
                
                # Get phase history
                for phase in project.ppap.phases.all():
                    phase_history = History.objects.filter(id=phase.history_id)
                    history_records = history_records.union(phase_history)
                    
                    # Get output history
                    for output in phase.outputs.all():
                        output_history = History.objects.filter(id=output.history_id)
                        history_records = history_records.union(output_history)
            
            serializer = self.get_serializer(history_records, many=True)
            return Response(serializer.data)
        except Project.DoesNotExist:
            return Response(
                {"error": f"Project with ID {project_id} not found"},
                status=status.HTTP_404_NOT_FOUND
            )
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )

```

#----------------------------------------------------------------------------------------------------

# core\views\__init__.py ==========================================================

core\views\__init__.py:
```python
from core.views.project_view import ProjectViewSet
from core.views.ppap_view import PPAPViewSet
from core.views.phase_view import PhaseViewSet
from core.views.output_view import OutputViewSet
from core.views.document_view import DocumentViewSet
from core.views.user_view import UserViewSet
from core.views.client_view import ClientViewSet
from core.views.team_view import TeamViewSet
from core.views.history_view import HistoryViewSet

```

#----------------------------------------------------------------------------------------------------

# core\views\api_view.py ==========================================================

core\views\api_view.py:
```python
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated, AllowAny
from rest_framework.response import Response
from rest_framework import status
from core.services import (
    history_api,
    project_api,
    ppap_api,
    phase_api,
    output_api,
    logic_api
)

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def dashboard_view(request):
    """
    Get dashboard data for the current user
    """
    user = request.user
    ppap_level = request.query_params.get('level')
    
    if ppap_level:
        try:
            ppap_level = int(ppap_level)
        except ValueError:
            return Response(
                {"error": "Invalid PPAP level"},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    # Get dashboard items filtered by level
    dashboard_items = logic_api.get_dashboard_items_by_level(user, ppap_level)
    
    # Get pending todos for the user
    pending_todos = logic_api.get_pending_todos(user.id)
    
    return Response({
        'projects': dashboard_items,
        'todos': pending_todos
    })

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def user_permissions_view(request):
    """
    Get permissions for the current user
    """
    user = request.user
    
    # Get user permissions
    permissions = logic_api.get_user_permissions(user.id)
    
    # Get user authorization details
    authorization_details = logic_api.get_user_authorization_details(user.id)
    
    return Response({
        'permissions': permissions,
        'authorization': authorization_details
    })

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def change_status_view(request):
    """
    Change status of an entity
    """
    user = request.user
    entity_type = request.data.get('entity_type')
    entity_id = request.data.get('entity_id')
    new_status = request.data.get('status')
    
    if not all([entity_type, entity_id, new_status]):
        return Response(
            {"error": "Missing required fields: entity_type, entity_id, status"},
            status=status.HTTP_400_BAD_REQUEST
        )
    
    try:
        # Check authorization
        if not logic_api.check_user_authorization(user.id, 'update', entity_type, entity_id):
            return Response(
                {"error": "Not authorized to change status"},
                status=status.HTTP_403_FORBIDDEN
            )
        
        # Change status based on entity type
        if entity_type == 'project':
            result = logic_api.change_project_status(entity_id, new_status, user.id)
        elif entity_type == 'ppap':
            result = logic_api.change_ppap_status(entity_id, new_status, user.id)
        elif entity_type == 'phase':
            result = logic_api.change_phase_status(entity_id, new_status, user.id)
        elif entity_type == 'output':
            result = logic_api.change_output_status(entity_id, new_status, user.id)
        else:
            return Response(
                {"error": f"Invalid entity type: {entity_type}"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        return Response({
            "success": True,
            "message": f"{entity_type} status changed to {new_status}"
        })
    except ValueError as e:
        return Response(
            {"error": str(e)},
            status=status.HTTP_400_BAD_REQUEST
        )
    except Exception as e:
        return Response(
            {"error": str(e)},
            status=status.HTTP_500_INTERNAL_SERVER_ERROR
        )

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def assign_permission_view(request):
    """
    Assign permission to a user for an output
    """
    user = request.user
    target_user_id = request.data.get('user_id')
    output_id = request.data.get('output_id')
    permission_type = request.data.get('permission_type')
    
    if not all([target_user_id, output_id, permission_type]):
        return Response(
            {"error": "Missing required fields: user_id, output_id, permission_type"},
            status=status.HTTP_400_BAD_REQUEST
        )
    
    try:
        # Check authorization
        if not logic_api.check_user_authorization(user.id, 'update', 'output', output_id):
            return Response(
                {"error": "Not authorized to assign permissions"},
                status=status.HTTP_403_FORBIDDEN
            )
        
        # Assign permission
        todo = logic_api.assign_permission(target_user_id, output_id, permission_type)
        
        return Response({
            "success": True,
            "message": f"Permission {permission_type} assigned to user {target_user_id} for output {output_id}"
        })
    except Exception as e:
        return Response(
            {"error": str(e)},
            status=status.HTTP_500_INTERNAL_SERVER_ERROR
        )

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def assign_phase_responsible_view(request):
    """
    Assign a responsible user to a phase and create todos
    """
    user = request.user
    phase_id = request.data.get('phase_id')
    responsible_id = request.data.get('responsible_id')
    
    if not all([phase_id, responsible_id]):
        return Response(
            {"error": "Missing required fields: phase_id, responsible_id"},
            status=status.HTTP_400_BAD_REQUEST
        )
    
    try:
        # Check authorization
        if not logic_api.check_user_authorization(user.id, 'update', 'phase', phase_id):
            return Response(
                {"error": "Not authorized to assign phase responsible"},
                status=status.HTTP_403_FORBIDDEN
            )
        
        # Assign todos for phase
        todos = logic_api.assign_todos_for_phase(phase_id, responsible_id)
        
        return Response({
            "success": True,
            "message": f"Responsible user {responsible_id} assigned to phase {phase_id} with {len(todos)} todos"
        })
    except Exception as e:
        return Response(
            {"error": str(e)},
            status=status.HTTP_500_INTERNAL_SERVER_ERROR
        )

@api_view(['GET'])
@permission_classes([AllowAny])  # Allow access without authentication for testing
def test_api(request):
    """
    Test API endpoint to verify the API is working
    """
    return Response({
        "status": "success",
        "message": "API is working correctly",
        "version": "1.0"
    })

```

#----------------------------------------------------------------------------------------------------

# core\views\auth_api.py ==========================================================

core\views\auth_api.py:
```python
# In your Django app views.py or a dedicated auth_api.py
from django.contrib.auth import authenticate, login, logout
from django.http import JsonResponse
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import AllowAny, IsAuthenticated
from rest_framework.response import Response
from rest_framework import status
import jwt
from datetime import datetime, timedelta
from django.conf import settings
from core.models import User, Contact

@api_view(['POST'])
@permission_classes([AllowAny])
def api_login(request):
    """
    API endpoint for user login
    Returns JWT token and user data on successful login
    """
    username = request.data.get('username')
    password = request.data.get('password')
    
    if not username or not password:
        return Response({
            'error': 'Please provide both username and password'
        }, status=status.HTTP_400_BAD_REQUEST)
    
    user = authenticate(username=username, password=password)
    
    if user is not None:
        login(request, user)  # Create session for session-based auth
        
        # Generate JWT token
        payload = {
            'user_id': user.id,
            'username': user.username,
            'exp': datetime.utcnow() + timedelta(days=1)
        }
        token = jwt.encode(payload, settings.SECRET_KEY, algorithm='HS256')
        
        # Create user object to return
        user_data = {
            'id': user.id,
            'username': user.username,
            'is_staff': user.is_staff,
            'is_superuser': user.is_superuser,
        }
        
        # Add person data if available
        if hasattr(user, 'person'):
            user_data['first_name'] = user.person.first_name
            user_data['last_name'] = user.person.last_name
            
            # Try to get email from contact
            try:
                contact = Contact.objects.get(id=user.person.contact_id)
                user_data['email'] = contact.email
            except Contact.DoesNotExist:
                user_data['email'] = ""
        else:
            user_data['first_name'] = ""
            user_data['last_name'] = ""
            user_data['email'] = ""
        
        return Response({
            'token': token,
            'user': user_data
        })
    else:
        return Response({
            'error': 'Invalid credentials'
        }, status=status.HTTP_401_UNAUTHORIZED)

@api_view(['POST'])
def api_logout(request):
    """
    API endpoint for user logout
    """
    logout(request)
    return Response({
        'message': 'Successfully logged out'
    })

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def api_get_user(request):
    """
    API endpoint to get current user data
    """
    user = request.user
    
    if not user.is_authenticated:
        return Response({
            'error': 'Not authenticated'
        }, status=status.HTTP_401_UNAUTHORIZED)
    
    # Create user object to return
    user_data = {
        'id': user.id,
        'username': user.username,
        'is_staff': user.is_staff,
        'is_superuser': user.is_superuser,
    }
    
    # Add person data if available
    if hasattr(user, 'person'):
        user_data['first_name'] = user.person.first_name
        user_data['last_name'] = user.person.last_name
        
        # Try to get email from contact
        try:
            contact = Contact.objects.get(id=user.person.contact_id)
            user_data['email'] = contact.email
        except Contact.DoesNotExist:
            user_data['email'] = ""
    else:
        user_data['first_name'] = ""
        user_data['last_name'] = ""
        user_data['email'] = ""
    
    return Response(user_data)
```

#----------------------------------------------------------------------------------------------------

# core\views\authorization_view.py ================================================

core\views\authorization_view.py:
```python
from rest_framework import viewsets, status
from rest_framework.response import Response
from rest_framework.decorators import action
from rest_framework.permissions import IsAuthenticated
from django.db import transaction

from core.models import Authorization
from core.serializers.authorization_serializer import AuthorizationSerializer
from core.services.authorization.api import (
    get_authorization_by_id,
    get_authorization_by_name,
    create_authorization,
    update_authorization,
    delete_authorization,
    get_all_authorizations,
    assign_user_authorization
)
from core.services.logic.authorization import check_user_authorization

class AuthorizationViewSet(viewsets.ModelViewSet):
    """
    ViewSet for Authorization
    """
    queryset = Authorization.objects.all()
    serializer_class = AuthorizationSerializer
    permission_classes = [IsAuthenticated]
    
    def list(self, request):
        """
        Get all authorizations
        """
        user = request.user
        
        # Check authorization
        if not check_user_authorization(user.id, 'read', 'authorization'):
            return Response(
                {"error": "Not authorized to view authorizations"},
                status=status.HTTP_403_FORBIDDEN
            )
        
        authorizations = get_all_authorizations()
        serializer = self.get_serializer(authorizations, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """
        Get authorization details
        """
        user = request.user
        
        # Check authorization
        if not check_user_authorization(user.id, 'read', 'authorization'):
            return Response(
                {"error": "Not authorized to view authorization details"},
                status=status.HTTP_403_FORBIDDEN
            )
        
        try:
            authorization = get_authorization_by_id(pk)
            serializer = self.get_serializer(authorization)
            return Response(serializer.data)
        except Authorization.DoesNotExist:
            return Response(
                {"error": f"Authorization with ID {pk} not found"},
                status=status.HTTP_404_NOT_FOUND
            )
    
    def create(self, request):
        """
        Create a new authorization
        """
        user = request.user
        
        # Check authorization
        if not check_user_authorization(user.id, 'create', 'authorization'):
            return Response(
                {"error": "Not authorized to create authorizations"},
                status=status.HTTP_403_FORBIDDEN
            )
        
        name = request.data.get('name')
        
        if not name:
            return Response(
                {"error": "Name is required"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            authorization = create_authorization(name)
            serializer = self.get_serializer(authorization)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    def update(self, request, pk=None):
        """
        Update an authorization
        """
        user = request.user
        
        # Check authorization
        if not check_user_authorization(user.id, 'update', 'authorization'):
            return Response(
                {"error": "Not authorized to update authorizations"},
                status=status.HTTP_403_FORBIDDEN
            )
        
        name = request.data.get('name')
        
        try:
            authorization = update_authorization(pk, name)
            serializer = self.get_serializer(authorization)
            return Response(serializer.data)
        except Authorization.DoesNotExist:
            return Response(
                {"error": f"Authorization with ID {pk} not found"},
                status=status.HTTP_404_NOT_FOUND
            )
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    def destroy(self, request, pk=None):
        """
        Delete an authorization
        """
        user = request.user
        
        # Check authorization
        if not check_user_authorization(user.id, 'delete', 'authorization'):
            return Response(
                {"error": "Not authorized to delete authorizations"},
                status=status.HTTP_403_FORBIDDEN
            )
        
        try:
            result = delete_authorization(pk)
            
            if result:
                return Response(status=status.HTTP_204_NO_CONTENT)
            else:
                return Response(
                    {"error": "Cannot delete authorization that is in use"},
                    status=status.HTTP_400_BAD_REQUEST
                )
        except Authorization.DoesNotExist:
            return Response(
                {"error": f"Authorization with ID {pk} not found"},
                status=status.HTTP_404_NOT_FOUND
            )
    
    @action(detail=False, methods=['post'])
    @transaction.atomic
    def assign(self, request):
        """
        Assign authorization to a user
        """
        user = request.user
        user_id = request.data.get('user_id')
        authorization_id = request.data.get('authorization_id')
        
        if not all([user_id, authorization_id]):
            return Response(
                {"error": "Missing required fields: user_id, authorization_id"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # Check authorization
        if not check_user_authorization(user.id, 'update', 'user', user_id):
            return Response(
                {"error": "Not authorized to update user's authorization"},
                status=status.HTTP_403_FORBIDDEN
            )
        
        try:
            updated_user = assign_user_authorization(user_id, authorization_id)
            
            return Response({
                "success": True,
                "message": f"Authorization {authorization_id} assigned to user {user_id}",
                "user_id": updated_user.id,
                "authorization_id": authorization_id
            })
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
```

#----------------------------------------------------------------------------------------------------

# core\views\client_view.py =======================================================

core\views\client_view.py:
```python
from rest_framework import viewsets, status
from rest_framework.response import Response
from rest_framework.decorators import action
from django.db import transaction
from core.models import Client, Contact, Project, Team
from core.serializers.client_serializer import ClientSerializer
from core.serializers.project_serializer import ProjectSerializer
from core.services.client.api import (
    initialize_client,
    update_client,
    delete_client,
    get_client_projects
)
from core.services.history.client import record_client_creation, record_client_update, record_client_deletion

class ClientViewSet(viewsets.ModelViewSet):
    queryset = Client.objects.all()
    serializer_class = ClientSerializer
    
    @transaction.atomic
    def create(self, request, *args, **kwargs):
        # Extract client data
        name = request.data.get('name')
        address = request.data.get('address', '')
        code = request.data.get('code', {})
        description = request.data.get('description', '')
        team_id = request.data.get('team_id')
        contact_data = request.data.get('contact', {})
        
        # Validate required fields
        if not name:
            return Response(
                {"error": "Missing required field: name"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            # Get team if provided
            team = None
            if team_id:
                try:
                    team = Team.objects.get(id=team_id)
                except Team.DoesNotExist:
                    return Response(
                        {"error": f"Team with ID {team_id} not found"},
                        status=status.HTTP_404_NOT_FOUND
                    )
            
            # Create client in a single save operation to avoid ID conflicts
            client = Client()
            client.name = name
            client.address = address
            client.code = code
            client.description = description
            client.team = team
            # Don't set contact_id or history_id - let the model's save method handle it
            client.save()
            
            # Create contact 
            Contact.objects.create(
                id=client.contact_id,
                address=contact_data.get('address', '') or address,
                email=contact_data.get('email', ''),
                phone=contact_data.get('phone', ''),
                type='client'
            )
            
            # Record in history
            record_client_creation(client)
            
            serializer = self.get_serializer(client)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    @transaction.atomic
    def update(self, request, *args, **kwargs):
        client = self.get_object()
        
        # Extract client data
        name = request.data.get('name')
        address = request.data.get('address')
        code = request.data.get('code')
        description = request.data.get('description')
        
        try:
            # Update client
            updated_client = update_client(
                client=client,
                name=name,
                address=address,
                code=code,
                description=description
            )
            
            # Record in history
            
            serializer = self.get_serializer(updated_client)
            return Response(serializer.data)
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    @transaction.atomic
    def destroy(self, request, *args, **kwargs):
        client = self.get_object()
        
        try:
            # Delete client
            delete_client(client)
            
            # Record in history
            record_client_deletion(client)
            
            return Response(status=status.HTTP_204_NO_CONTENT)
        except ValueError as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    @action(detail=True, methods=['get'])
    def projects(self, request, pk=None):
        try:
            projects = get_client_projects(pk)
            serializer = ProjectSerializer(projects, many=True)
            return Response(serializer.data)
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )

```

#----------------------------------------------------------------------------------------------------

# core\views\contact_view.py ======================================================

core\views\contact_view.py:
```python
from rest_framework import viewsets, status
from rest_framework.response import Response
from rest_framework.decorators import action
from django.db import transaction
from core.models import Contact
from core.serializers.contact_serializer import ContactSerializer
from core.services.contact.api import (
    initialize_contact,
    update_contact,
    delete_contact,
    get_person_by_contact,
    get_client_by_contact
)
from core.services.history.contact import record_contact_creation, record_contact_update, record_contact_deletion

class ContactViewSet(viewsets.ModelViewSet):
    queryset = Contact.objects.all()
    serializer_class = ContactSerializer
    
    @transaction.atomic
    def create(self, request, *args, **kwargs):
        # Extract data
        address = request.data.get('address', '')
        email = request.data.get('email', '')
        phone = request.data.get('phone', '')
        contact_type = request.data.get('type', 'unknown')
        
        try:
            # Generate ID for the contact if not provided
            contact_id = request.data.get('id')
            if not contact_id:
                import uuid
                contact_id = f"{uuid.uuid4().hex}contact"
            
            # Create contact
            contact = Contact.objects.create(
                id=contact_id,
                address=address,
                email=email,
                phone=phone,
                type=contact_type
            )
            
            # Record in history
            record_contact_creation(contact)
            
            serializer = self.get_serializer(contact)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    @transaction.atomic
    def update(self, request, *args, **kwargs):
        contact = self.get_object()
        
        # Extract contact data
        address = request.data.get('address')
        email = request.data.get('email')
        phone = request.data.get('phone')
        
        try:
            # Update contact
            updated_contact = update_contact(
                contact=contact,
                address=address,
                email=email,
                phone=phone
            )
            
            # Record in history
            record_contact_update(updated_contact)
            
            serializer = self.get_serializer(updated_contact)
            return Response(serializer.data)
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    @transaction.atomic
    def destroy(self, request, *args, **kwargs):
        contact = self.get_object()
        
        # Check if contact is associated with a person or client
        person = get_person_by_contact(contact.id)
        client = get_client_by_contact(contact.id)
        
        if person or client:
            entity_type = "person" if person else "client"
            entity_id = person.id if person else client.id
            return Response(
                {"error": f"Cannot delete contact. It is associated with a {entity_type} (ID: {entity_id})"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # Delete contact
        delete_contact(contact)
        
        # Record in history
        record_contact_deletion(contact)
        
        return Response(status=status.HTTP_204_NO_CONTENT)
    
    @action(detail=False, methods=['get'])
    def by_type(self, request):
        type = request.query_params.get('type')
        
        if not type:
            return Response(
                {"error": "Missing required parameter: type"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        valid_types = ['person', 'client', 'client_member']
        if type not in valid_types:
            return Response(
                {"error": f"Invalid type. Must be one of: {', '.join(valid_types)}"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        contacts = Contact.objects.filter(type=type)
        serializer = self.get_serializer(contacts, many=True)
        return Response(serializer.data)

```

#----------------------------------------------------------------------------------------------------

# core\views\department_view.py ===================================================

core\views\department_view.py:
```python
from rest_framework import viewsets, status
from rest_framework.response import Response
from rest_framework.decorators import action
from django.db import transaction
from core.models import Department, Person, Team, User
from core.serializers.department_serializer import DepartmentSerializer
from core.serializers.person_serializer import PersonSerializer
from core.serializers.team_serializer import TeamSerializer
from core.services.department.api import (
    initialize_department,
    update_department,
    delete_department,
    get_department_members,
    get_department_teams
)
from core.services.history.department import record_department_creation, record_department_update, record_department_deletion

class DepartmentViewSet(viewsets.ModelViewSet):
    queryset = Department.objects.all()
    serializer_class = DepartmentSerializer
    
    @transaction.atomic
    def create(self, request, *args, **kwargs):
        # Extract data
        name = request.data.get('name')
        responsible_id = request.data.get('responsible_id')
        
        if not name:
            return Response(
                {"error": "Name is required"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            # Create department
            department = Department(name=name)
            
            # Handle responsible assignment
            if responsible_id:
                try:
                    # Get the Person first
                    person = Person.objects.get(id=responsible_id)
                    
                    # Check if this Person is associated with a User
                    if person.is_user:
                        # Get the associated User
                        try:
                            user = User.objects.get(person_id=person.id)
                            department.responsible = user
                        except User.DoesNotExist:
                            return Response(
                                {"error": f"Person with ID {responsible_id} is marked as a user but no User record exists"},
                                status=status.HTTP_400_BAD_REQUEST
                            )
                    else:
                        return Response(
                            {"error": f"Person with ID {responsible_id} is not a user and cannot be assigned as responsible"},
                            status=status.HTTP_400_BAD_REQUEST
                        )
                except Person.DoesNotExist:
                    return Response(
                        {"error": f"Person with ID {responsible_id} not found"},
                        status=status.HTTP_404_NOT_FOUND
                    )
            
            # Save the department
            department.save()
            
            # Record creation in history
            record_department_creation(department)
            
            serializer = self.get_serializer(department)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    @transaction.atomic
    def update(self, request, *args, **kwargs):
        department = self.get_object()
        
        # Extract department data
        name = request.data.get('name')
        responsible_id = request.data.get('responsible_id')
        
        try:
            # Get responsible user if provided
            responsible = None
            if responsible_id:
                try:
                    responsible = Person.objects.get(id=responsible_id, is_user=True)
                except Person.DoesNotExist:
                    return Response(
                        {"error": f"User with ID {responsible_id} not found"},
                        status=status.HTTP_404_NOT_FOUND
                    )
            
            # Update department
            updated_department = update_department(
                department=department,
                name=name,
                responsible=responsible
            )
            
            # Record in history
            record_department_update(department)
            
            serializer = self.get_serializer(updated_department)
            return Response(serializer.data)
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    @transaction.atomic
    def destroy(self, request, *args, **kwargs):
        department = self.get_object()
        
        try:
            # Delete department
            delete_department(department)
            
            # Record in history
            record_department_deletion(department)
            
            return Response(status=status.HTTP_204_NO_CONTENT)
        except ValueError as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    @action(detail=True, methods=['get'])
    def members(self, request, pk=None):
        try:
            members = get_department_members(pk)
            serializer = PersonSerializer(members, many=True)
            return Response(serializer.data)
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    @action(detail=True, methods=['get'])
    def teams(self, request, pk=None):
        try:
            teams = get_department_teams(pk)
            serializer = TeamSerializer(teams, many=True)
            return Response(serializer.data)
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )

```

#----------------------------------------------------------------------------------------------------

# core\views\document_view.py =====================================================

core\views\document_view.py:
```python
from rest_framework import viewsets, status
from rest_framework.response import Response
from rest_framework.decorators import action
from django.db import transaction
from core.models import Document, Output
from core.serializers.document_serializer import DocumentSerializer
from core.services.document.api import (
    initialize_document,
    update_document,
    update_document_file,
    delete_document,
    change_document_output,
    get_documents_by_output,
    get_documents_by_status
)
from core.services.history.document import record_document_creation

class DocumentViewSet(viewsets.ModelViewSet):
    queryset = Document.objects.all()
    serializer_class = DocumentSerializer
    
    @transaction.atomic
    def create(self, request, *args, **kwargs):
        # Extract document data
        name = request.data.get('name')
        file_path = request.data.get('file_path')
        output_id = request.data.get('output_id')
        version = request.data.get('version', 1)
        status_value = request.data.get('status', 'draft')
        
        # Validate required fields
        if not all([name, file_path]):
            return Response(
                {"error": "Missing required fields: name, file_path"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            # Get output if provided
            output = None
            if output_id:
                try:
                    output = Output.objects.get(id=output_id)
                except Output.DoesNotExist:
                    return Response(
                        {"error": f"Output with ID {output_id} not found"},
                        status=status.HTTP_404_NOT_FOUND
                    )
            
            # Create document
            document = initialize_document(
                name=name,
                file_path=file_path,
                output=output,
                version=version,
                status=status_value
            )
            
            # Record in history
            record_document_creation(document)
            
            serializer = self.get_serializer(document)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    @transaction.atomic
    def update(self, request, *args, **kwargs):
        document = self.get_object()
        
        # Extract document data
        name = request.data.get('name')
        status_value = request.data.get('status')
        
        try:
            # Update document
            updated_document = update_document(
                document=document,
                name=name,
                status=status_value
            )
            
            serializer = self.get_serializer(updated_document)
            return Response(serializer.data)
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    @transaction.atomic
    def destroy(self, request, *args, **kwargs):
        document = self.get_object()
        delete_file = request.query_params.get('delete_file', 'true').lower() == 'true'
        
        try:
            # Delete document
            delete_document(document, delete_file=delete_file)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    @action(detail=True, methods=['post'])
    def update_file(self, request, pk=None):
        document = self.get_object()
        new_file_path = request.data.get('file_path')
        
        if not new_file_path:
            return Response(
                {"error": "Missing required field: file_path"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            updated_document = update_document_file(document, new_file_path)
            serializer = self.get_serializer(updated_document)
            return Response(serializer.data)
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    @action(detail=True, methods=['post'])
    def change_output(self, request, pk=None):
        document = self.get_object()
        output_id = request.data.get('output_id')
        
        if not output_id:
            return Response(
                {"error": "Missing required field: output_id"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            output = Output.objects.get(id=output_id)
            updated_document = change_document_output(document, output)
            serializer = self.get_serializer(updated_document)
            return Response(serializer.data)
        except Output.DoesNotExist:
            return Response(
                {"error": f"Output with ID {output_id} not found"},
                status=status.HTTP_404_NOT_FOUND
            )
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    @action(detail=False, methods=['get'])
    def by_output(self, request):
        output_id = request.query_params.get('output_id')
        
        if not output_id:
            return Response(
                {"error": "Missing required parameter: output_id"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            documents = get_documents_by_output(output_id)
            serializer = self.get_serializer(documents, many=True)
            return Response(serializer.data)
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    @action(detail=False, methods=['get'])
    def by_status(self, request):
        status_value = request.query_params.get('status')
        
        if not status_value:
            return Response(
                {"error": "Missing required parameter: status"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            documents = get_documents_by_status(status_value)
            serializer = self.get_serializer(documents, many=True)
            return Response(serializer.data)
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )

```

#----------------------------------------------------------------------------------------------------

# core\views\history_editor_view.py ===============================================

core\views\history_editor_view.py:
```python
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from django.db import transaction
from django.utils import timezone
from datetime import datetime
import uuid

from core.models import Phase, Output, History
from core.services.history.api import (
    update_history_dates,
    set_entity_deadline,
    get_entity_deadline,
    bulk_update_entity_deadlines
)

class HistoryEditorViewSet(viewsets.ViewSet):
    """
    ViewSet for editing history records
    """
    permission_classes = [IsAuthenticated]
    
    @action(detail=False, methods=['post'])
    def update_dates(self, request):
        """
        Update dates for a history record
        """
        history_id = request.data.get('history_id')
        deadline = request.data.get('deadline')
        started_at = request.data.get('started_at')
        completed_at = request.data.get('completed_at')
        
        if not history_id:
            return Response({"error": "history_id is required"}, status=status.HTTP_400_BAD_REQUEST)
        
        # Parse dates if provided
        deadline_date = None
        if deadline:
            try:
                deadline_date = timezone.make_aware(datetime.fromisoformat(deadline.replace('Z', '+00:00')))
            except ValueError:
                return Response({"error": "Invalid deadline format"}, status=status.HTTP_400_BAD_REQUEST)
        
        started_date = None
        if started_at:
            try:
                started_date = timezone.make_aware(datetime.fromisoformat(started_at.replace('Z', '+00:00')))
            except ValueError:
                return Response({"error": "Invalid started_at format"}, status=status.HTTP_400_BAD_REQUEST)
        
        completed_date = None
        if completed_at:
            try:
                completed_date = timezone.make_aware(datetime.fromisoformat(completed_at.replace('Z', '+00:00')))
            except ValueError:
                return Response({"error": "Invalid completed_at format"}, status=status.HTTP_400_BAD_REQUEST)
        
        try:
            # Convert string history_id to UUID
            try:
                history_id_uuid = uuid.UUID(history_id)
            except ValueError:
                return Response({"error": "Invalid history_id format"}, status=status.HTTP_400_BAD_REQUEST)
            
            history = update_history_dates(
                history_id_uuid,
                deadline=deadline_date,
                started_at=started_date,
                completed_at=completed_date
            )
            
            # Create response data
            response_data = {
                "success": True,
                "history_id": str(history.history_id),
                "updated": []
            }
            
            if deadline_date:
                response_data["updated"].append("deadline")
                response_data["deadline"] = deadline_date.isoformat()
            
            if started_date:
                response_data["updated"].append("started_at")
                response_data["started_at"] = started_date.isoformat()
            
            if completed_date:
                response_data["updated"].append("completed_at")
                response_data["completed_at"] = completed_date.isoformat()
                
            return Response(response_data)
            
        except History.DoesNotExist:
            return Response({"error": f"History with ID {history_id} not found"}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    @action(detail=False, methods=['post'])
    def set_deadline(self, request):
        """
        Set deadline for an entity
        """
        entity_type = request.data.get('entity_type')
        entity_id = request.data.get('entity_id')
        deadline = request.data.get('deadline')
        
        if not all([entity_type, entity_id, deadline]):
            return Response({
                "error": "entity_type, entity_id, and deadline are required"
            }, status=status.HTTP_400_BAD_REQUEST)
        
        # Parse deadline
        try:
            deadline_date = timezone.make_aware(datetime.fromisoformat(deadline.replace('Z', '+00:00')))
        except ValueError:
            return Response({"error": "Invalid deadline format"}, status=status.HTTP_400_BAD_REQUEST)
        
        try:
            # Get entity based on type
            entity = None
            if entity_type.lower() == 'phase':
                entity = Phase.objects.get(id=entity_id)
            elif entity_type.lower() == 'output':
                entity = Output.objects.get(id=entity_id)
            else:
                return Response({
                    "error": f"Unsupported entity_type: {entity_type}"
                }, status=status.HTTP_400_BAD_REQUEST)
            
            result = set_entity_deadline(entity, deadline_date, entity_type.lower())
            
            return Response({
                "success": True,
                "entity_type": entity_type,
                "entity_id": entity_id,
                "deadline": deadline_date.isoformat()
            })
            
        except (Phase.DoesNotExist, Output.DoesNotExist):
            return Response({
                "error": f"{entity_type} with ID {entity_id} not found"
            }, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    @action(detail=False, methods=['get'])
    def get_deadline(self, request):
        """
        Get deadline for an entity
        """
        entity_type = request.query_params.get('entity_type')
        entity_id = request.query_params.get('entity_id')
        
        if not all([entity_type, entity_id]):
            return Response({
                "error": "entity_type and entity_id are required"
            }, status=status.HTTP_400_BAD_REQUEST)
        
        try:
            # Get entity based on type
            entity = None
            if entity_type.lower() == 'phase':
                entity = Phase.objects.get(id=entity_id)
            elif entity_type.lower() == 'output':
                entity = Output.objects.get(id=entity_id)
            else:
                return Response({
                    "error": f"Unsupported entity_type: {entity_type}"
                }, status=status.HTTP_400_BAD_REQUEST)
            
            deadline = get_entity_deadline(entity, entity_type.lower())
            
            return Response({
                "entity_type": entity_type,
                "entity_id": entity_id,
                "deadline": deadline.isoformat() if deadline else None,
                "has_deadline": deadline is not None
            })
            
        except (Phase.DoesNotExist, Output.DoesNotExist):
            return Response({
                "error": f"{entity_type} with ID {entity_id} not found"
            }, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    @action(detail=False, methods=['post'])
    @transaction.atomic
    def bulk_set_deadlines(self, request):
        """
        Set deadlines for multiple entities of the same type
        """
        entity_type = request.data.get('entity_type')
        entity_ids = request.data.get('entity_ids')
        deadline = request.data.get('deadline')
        
        if not all([entity_type, entity_ids, deadline]):
            return Response({
                "error": "entity_type, entity_ids, and deadline are required"
            }, status=status.HTTP_400_BAD_REQUEST)
        
        if not isinstance(entity_ids, list):
            return Response({
                "error": "entity_ids must be a list"
            }, status=status.HTTP_400_BAD_REQUEST)
        
        # Parse deadline
        try:
            deadline_date = timezone.make_aware(datetime.fromisoformat(deadline.replace('Z', '+00:00')))
        except ValueError:
            return Response({"error": "Invalid deadline format"}, status=status.HTTP_400_BAD_REQUEST)
        
        try:
            # Get entity class based on type
            entity_class = None
            if entity_type.lower() == 'phase':
                entity_class = Phase
            elif entity_type.lower() == 'output':
                entity_class = Output
            else:
                return Response({
                    "error": f"Unsupported entity_type: {entity_type}"
                }, status=status.HTTP_400_BAD_REQUEST)
            
            result = bulk_update_entity_deadlines(
                entity_ids,
                deadline_date,
                entity_class,
                entity_type.lower()
            )
            
            return Response({
                "success": True,
                "entity_type": entity_type,
                "updated_count": result['updated_count'],
                "failed_count": result['failed_count'],
                "total": result['total'],
                "deadline": deadline_date.isoformat(),
                "updated_entities": result['updated_entities']
            })
            
        except Exception as e:
            return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
```

#----------------------------------------------------------------------------------------------------

# core\views\history_view.py ======================================================

core\views\history_view.py:
```python
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from core.models import History, Project
from core.serializers.history_serializer import HistorySerializer
import json

class HistoryViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = History.objects.all()
    serializer_class = HistorySerializer
    
    @action(detail=True, methods=['get'])
    def events(self, request, pk=None):
        """Get all events for a specific history record"""
        history = self.get_object()
        
        try:
            events = json.loads(history.event)
            return Response(events)
        except (json.JSONDecodeError, TypeError):
            return Response([{
                "type": "unknown",
                "details": history.event or "No details available",
                "timestamp": history.created_at.isoformat() if history.created_at else None
            }])
    
    @action(detail=False, methods=['get'])
    def project(self, request, project_id=None):
        project_id = request.query_params.get('project_id')
        if not project_id:
            return Response(
                {"error": "Missing required parameter: project_id"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            project = Project.objects.get(id=project_id)
            history_records = History.objects.filter(id=project.history_id)
            
            # Get related history records
            if project.ppap:
                ppap_history = History.objects.filter(id=project.ppap.history_id)
                history_records = history_records.union(ppap_history)
                
                # Get phase history
                for phase in project.ppap.phases.all():
                    phase_history = History.objects.filter(id=phase.history_id)
                    history_records = history_records.union(phase_history)
                    
                    # Get output history
                    for output in phase.outputs.all():
                        output_history = History.objects.filter(id=output.history_id)
                        history_records = history_records.union(output_history)
            
            serializer = self.get_serializer(history_records, many=True)
            return Response(serializer.data)
        except Project.DoesNotExist:
            return Response(
                {"error": f"Project with ID {project_id} not found"},
                status=status.HTTP_404_NOT_FOUND
            )
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )

```

#----------------------------------------------------------------------------------------------------

# core\views\output_view.py =======================================================

core\views\output_view.py:
```python
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from django.db import transaction
from core.models import Output, History
from core.serializers.output_serializer import OutputSerializer
from core.serializers.history_serializer import HistorySerializer
from core.services.history.initialization import initialize_history

class OutputViewSet(viewsets.ModelViewSet):
    queryset = Output.objects.all()
    serializer_class = OutputSerializer
    
    @action(detail=True, methods=['get'])
    def history(self, request, pk=None):
        output = self.get_object()
        history_records = History.objects.filter(id=output.history_id)
        serializer = HistorySerializer(history_records, many=True)
        return Response(serializer.data)
    
    @transaction.atomic
    def update(self, request, *args, **kwargs):
        output = self.get_object()
        serializer = self.get_serializer(output, data=request.data, partial=True)
        
        if serializer.is_valid():
            # Save the output
            output = serializer.save()
            
            # Record the update in history
            initialize_history(
                title=f"{output.template.name}",
                event=f"Output updated: {', '.join(request.data.keys())}",
                table_name='output',
                history_id=output.history_id
            )
            
            # Check if status changed to 'Completed'
            if 'status' in request.data and request.data['status'] == 'Completed':
                # Update phase status if all outputs are completed
                phase = output.phase
                all_outputs_completed = all(o.status == 'Completed' for o in phase.outputs.all())
                
                if all_outputs_completed and phase.status != 'Completed':
                    phase.status = 'Completed'
                    phase.save()
                    
                    # Record phase completion in history
                    initialize_history(
                        title=f"{phase.template.name}",
                        event=f"Phase marked as Completed as all outputs are completed",
                        table_name='phase',
                        history_id=phase.history_id
                    )
                    
                    # Check if all phases are completed to update PPAP status
                    ppap = phase.ppap
                    all_phases_completed = all(p.status == 'Completed' for p in ppap.phases.all())
                    
                    if all_phases_completed and ppap.status != 'Completed':
                        ppap.status = 'Completed'
                        ppap.save()
                        
                        # Record PPAP completion in history
                        initialize_history(
                            title=f"PPAP for Project {ppap.project_id}",
                            event=f"PPAP marked as Completed as all phases are completed",
                            table_name='ppap',
                            history_id=ppap.history_id
                        )
            
            return Response(serializer.data)
        
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

```

#----------------------------------------------------------------------------------------------------

# core\views\person_view.py =======================================================

core\views\person_view.py:
```python
from rest_framework import viewsets, status
from rest_framework.response import Response
from rest_framework.decorators import action
from django.db import transaction
from core.models import Person, Team, Department, Contact
from core.serializers.person_serializer import PersonSerializer
from core.services.history.person import (
    record_person_creation, 
    record_person_update, 
    record_person_team_change, 
    record_person_department_change,
    record_person_deletion
)
from core.services.history.contact import record_contact_creation

class PersonViewSet(viewsets.ModelViewSet):
    queryset = Person.objects.all()
    serializer_class = PersonSerializer
    
    @transaction.atomic
    def create(self, request, *args, **kwargs):
        # Extract person data
        first_name = request.data.get('first_name')
        last_name = request.data.get('last_name')
        team_ids = request.data.get('team_ids', [])
        department_id = request.data.get('department_id')
        is_user = request.data.get('is_user', False)
        contact_data = request.data.get('contact', {})
        
        # Validate required fields
        if not all([first_name, last_name]):
            return Response(
                {"error": "Missing required fields: first_name, last_name"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            # Create person
            person = Person.objects.create(
                first_name=first_name,
                last_name=last_name,
                is_user=is_user,
                department_id=department_id
            )
            
            # Add to teams if provided
            if team_ids:
                teams = Team.objects.filter(id__in=team_ids)
                person.teams.set(teams)
            
            # Set department if provided
            if department_id:
                try:
                    department = Department.objects.get(id=department_id)
                    person.department = department
                    person.save()
                except Department.DoesNotExist:
                    pass
            
            # Create contact
            if contact_data:
                contact=Contact.objects.create(
                    id=person.contact_id,
                    address=contact_data.get('address', ''),
                    email=contact_data.get('email', ''),
                    phone=contact_data.get('phone', ''),
                    type='person'
                )
            
            # Record in history
            record_person_creation(person)
            record_contact_creation(contact)
            
            serializer = self.get_serializer(person)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    @transaction.atomic
    def update(self, request, *args, **kwargs):
        person = self.get_object()
        
        # Extract person data
        first_name = request.data.get('first_name', person.first_name)
        last_name = request.data.get('last_name', person.last_name)
        is_user = request.data.get('is_user', person.is_user)
        
        # Track updated fields
        updated_fields = []
        if first_name != person.first_name:
            person.first_name = first_name
            updated_fields.append('first_name')
        
        if last_name != person.last_name:
            person.last_name = last_name
            updated_fields.append('last_name')
        
        if is_user != person.is_user:
            person.is_user = is_user
            updated_fields.append('is_user')
        
        # Handle department change
        if 'department_id' in request.data:
            department_id = request.data.get('department_id')
            old_department_id = person.department.id if person.department else None
            
            if department_id != old_department_id:
                if department_id:
                    try:
                        department = Department.objects.get(id=department_id)
                        person.department = department
                        updated_fields.append('department')
                        record_person_department_change(person, old_department_id, department_id)
                    except Department.DoesNotExist:
                        pass
                else:
                    person.department = None
                    updated_fields.append('department')
                    record_person_department_change(person, old_department_id, None)
        
        # Save person if fields were updated
        if updated_fields:
            person.save()
            record_person_update(person, updated_fields)
        
        # Handle teams if provided
        if 'team_ids' in request.data:
            team_ids = request.data.get('team_ids', [])
            current_teams = set(person.teams.values_list('id', flat=True))
            new_teams = set(int(t) for t in team_ids)
            
            # Record team changes
            for team_id in new_teams - current_teams:
                record_person_team_change(person, None, team_id)
            
            for team_id in current_teams - new_teams:
                record_person_team_change(person, team_id, None)
            
            # Update teams
            person.teams.set(Team.objects.filter(id__in=team_ids))
        
        serializer = self.get_serializer(person)
        return Response(serializer.data)
    
    @transaction.atomic
    def destroy(self, request, *args, **kwargs):
        person = self.get_object()
        
        # Record deletion in history
        record_person_deletion(person)
        
        # Delete associated contact if exists
        try:
            contact = Contact.objects.get(id=person.contact_id)
            contact.delete()
        except Contact.DoesNotExist:
            pass
        
        # Delete the person
        person.delete()
        
        return Response(status=status.HTTP_204_NO_CONTENT)
    
    @action(detail=True, methods=['post'])
    def add_to_team(self, request, pk=None):
        person = self.get_object()
        team_id = request.data.get('team_id')
        
        if not team_id:
            return Response(
                {"error": "Missing required field: team_id"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            team = Team.objects.get(id=team_id)
            if team not in person.teams.all():
                person.teams.add(team)
                record_person_team_change(person, None, team_id)
                return Response({"status": "Added to team successfully"})
            else:
                return Response(
                    {"error": f"Person is already a member of team with ID {team_id}"},
                    status=status.HTTP_400_BAD_REQUEST
                )
        except Team.DoesNotExist:
            return Response(
                {"error": f"Team with ID {team_id} not found"},
                status=status.HTTP_404_NOT_FOUND
            )
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    @action(detail=True, methods=['post'])
    def remove_from_team(self, request, pk=None):
        person = self.get_object()
        team_id = request.data.get('team_id')
        
        if not team_id:
            return Response(
                {"error": "Missing required field: team_id"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            team = Team.objects.get(id=team_id)
            if team in person.teams.all():
                person.teams.remove(team)
                record_person_team_change(person, team_id, None)
                return Response({"status": "Removed from team successfully"})
            else:
                return Response(
                    {"error": f"Person is not a member of team with ID {team_id}"},
                    status=status.HTTP_400_BAD_REQUEST
                )
        except Team.DoesNotExist:
            return Response(
                {"error": f"Team with ID {team_id} not found"},
                status=status.HTTP_404_NOT_FOUND
            )
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )

```

#----------------------------------------------------------------------------------------------------

# core\views\phase_view.py ========================================================

core\views\phase_view.py:
```python
from rest_framework import viewsets
from rest_framework.decorators import action
from rest_framework.response import Response
from core.models import Phase, History
from core.serializers.phase_serializer import PhaseSerializer
from core.serializers.history_serializer import HistorySerializer

class PhaseViewSet(viewsets.ModelViewSet):
    queryset = Phase.objects.all()
    serializer_class = PhaseSerializer
    
    @action(detail=True, methods=['get'])
    def history(self, request, pk=None):
        phase = self.get_object()
        history_records = History.objects.filter(id=phase.history_id)
        serializer = HistorySerializer(history_records, many=True)
        return Response(serializer.data)

```

#----------------------------------------------------------------------------------------------------

# core\views\ppap_element_view.py =================================================

core\views\ppap_element_view.py:
```python
from rest_framework import viewsets, status
from rest_framework.response import Response
from rest_framework.decorators import action
from django.db import transaction

from core.models import PPAPElement
from core.serializers.ppap_element_serializer import PPAPElementSerializer
from core.services.ppap_element.api import (
    get_ppap_elements_by_level,
    get_all_ppap_elements
)
from core.services.ppap_element.seeder import seed_standard_ppap_elements

class PPAPElementViewSet(viewsets.ModelViewSet):
    """
    ViewSet for PPAP Elements
    """
    queryset = PPAPElement.objects.all()
    serializer_class = PPAPElementSerializer

    @action(detail=False, methods=['get'])
    def by_level(self, request):
        """
        Get PPAP elements for a specific level
        """
        level = request.query_params.get('level')
        if not level:
            return Response({"error": "Level parameter is required"}, status=status.HTTP_400_BAD_REQUEST)
            
        elements = get_ppap_elements_by_level(level)
        serializer = self.get_serializer(elements, many=True)
        return Response(serializer.data)
    
    @action(detail=False, methods=['post'])
    @transaction.atomic
    def seed(self, request):
        """
        Seed standard PPAP elements
        """
        elements = seed_standard_ppap_elements()
        serializer = self.get_serializer(elements, many=True)
        return Response({
            "message": f"Successfully seeded {len(elements)} PPAP elements",
            "elements": serializer.data
        })
```

#----------------------------------------------------------------------------------------------------

# core\views\ppap_view.py =========================================================

core\views\ppap_view.py:
```python
from rest_framework import viewsets
from rest_framework.decorators import action
from rest_framework.response import Response
from core.models import PPAP, History
from core.serializers.ppap_serializer import PPAPSerializer
from core.serializers.history_serializer import HistorySerializer

from django.db import transaction
from rest_framework import status

class PPAPViewSet(viewsets.ModelViewSet):
    queryset = PPAP.objects.all()
    serializer_class = PPAPSerializer

    @transaction.atomic
    def create(self, request, *args, **kwargs):
        # Extract data from request
        project_id = request.data.get('project')
        level = request.data.get('level')
        ppap_status = request.data.get('status', 'Not Started')  # Renamed from status to ppap_status

        try:
            # Try to get existing PPAP for this project
            ppap, created = PPAP.objects.get_or_create(
                project_id=project_id,
                defaults={
                    'level': level,
                    'status': ppap_status  # Use the renamed variable
                }
            )

            # If it already existed, update it
            if not created:
                ppap.level = level
                ppap.status = ppap_status  # Use the renamed variable
                ppap.save()

            serializer = self.get_serializer(ppap)
            return Response(serializer.data, status=status.HTTP_201_CREATED if created else status.HTTP_200_OK)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)

    @action(detail=True, methods=['get'])
    def history(self, request, pk=None):
        ppap = self.get_object()
        history_records = History.objects.filter(id=ppap.history_id)
        serializer = HistorySerializer(history_records, many=True)
        return Response(serializer.data)

```

#----------------------------------------------------------------------------------------------------

# core\views\project_view.py ======================================================

core\views\project_view.py:
```python
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from django.db import transaction
from core.models import Project, History
from core.serializers.project_serializer import ProjectSerializer
from core.serializers.history_serializer import HistorySerializer
from core.services.project.initialization import initialize_project

class ProjectViewSet(viewsets.ModelViewSet):
    queryset = Project.objects.all()
    serializer_class = ProjectSerializer
    
    @transaction.atomic
    def create(self, request, *args, **kwargs):
        # Extract data for project initialization
        name = request.data.get('name')
        description = request.data.get('description', '')
        client_id = request.data.get('client_id')
        team_id = request.data.get('team_id')
        ppap_level = request.data.get('ppap_level', 3)
        
        # Validate required fields
        if not all([name, client_id, team_id]):
            return Response(
                {"error": "Missing required fields: name, client_id, team_id"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # Initialize project with all related records
        try:
            project = initialize_project(name, description, client_id, team_id, ppap_level)
            serializer = self.get_serializer(project)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
            
    
    @action(detail=True, methods=['get'])
    def history(self, request, pk=None):
        project = self.get_object()
        history_records = History.objects.filter(id=project.history_id)
        serializer = HistorySerializer(history_records, many=True)
        return Response(serializer.data)

```

#----------------------------------------------------------------------------------------------------

# core\views\team_view.py =========================================================

core\views\team_view.py:
```python
from rest_framework import viewsets, status
from rest_framework.response import Response
from rest_framework.decorators import action
from django.db import transaction
from core.models import Team, Person, Department
from core.serializers.team_serializer import TeamSerializer
from core.serializers.person_serializer import PersonSerializer
from core.services.team.api import (
    initialize_team,
    update_team,
    delete_team,
    add_team_member,
    remove_team_member,
    get_team_members,
    get_team_projects
)

class TeamViewSet(viewsets.ModelViewSet):
    queryset = Team.objects.all()
    serializer_class = TeamSerializer
    
    @transaction.atomic
    def create(self, request, *args, **kwargs):
        # Extract team data
        name = request.data.get('name')
        description = request.data.get('description', '')
        department_id = request.data.get('department_id')
        members = request.data.get('members', [])
        
        # Validate required fields
        if not name:
            return Response(
                {"error": "Missing required field: name"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            # Get department if provided
            department = None
            if department_id:
                try:
                    department = Department.objects.get(id=department_id)
                except Department.DoesNotExist:
                    return Response(
                        {"error": f"Department with ID {department_id} not found"},
                        status=status.HTTP_404_NOT_FOUND
                    )
            
            # Create team
            team = initialize_team(
                name=name,
                description=description,
                department=department
            )
            
            # Add members if provided
            if members:
                persons = Person.objects.filter(id__in=members)
                for person in persons:
                    add_team_member(team, person)
            
            serializer = self.get_serializer(team)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    @transaction.atomic
    def update(self, request, *args, **kwargs):
        team = self.get_object()
        
        # Extract team data
        name = request.data.get('name')
        description = request.data.get('description')
        department_id = request.data.get('department_id')
        
        try:
            # Get department if provided
            department = None
            if department_id:
                try:
                    department = Department.objects.get(id=department_id)
                except Department.DoesNotExist:
                    return Response(
                        {"error": f"Department with ID {department_id} not found"},
                        status=status.HTTP_404_NOT_FOUND
                    )
            
            # Update team
            updated_team = update_team(
                team=team,
                name=name,
                description=description,
                department=department
            )
            
            serializer = self.get_serializer(updated_team)
            return Response(serializer.data)
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    @transaction.atomic
    def destroy(self, request, *args, **kwargs):
        team = self.get_object()
        
        try:
            # Delete team
            delete_team(team)
            
            return Response(status=status.HTTP_204_NO_CONTENT)
        except ValueError as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    @action(detail=True, methods=['get'])
    def members(self, request, pk=None):
        try:
            members = get_team_members(pk)
            serializer = PersonSerializer(members, many=True)
            return Response(serializer.data)
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    @action(detail=True, methods=['post'])
    def add_member(self, request, pk=None):
        team = self.get_object()
        person_id = request.data.get('person_id')
        
        if not person_id:
            return Response(
                {"error": "Missing required field: person_id"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            person = Person.objects.get(id=person_id)
            add_team_member(team, person)
            return Response({"status": "Member added successfully"})
        except Person.DoesNotExist:
            return Response(
                {"error": f"Person with ID {person_id} not found"},
                status=status.HTTP_404_NOT_FOUND
            )
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    @action(detail=True, methods=['post'])
    def remove_member(self, request, pk=None):
        team = self.get_object()
        person_id = request.data.get('person_id')
        
        if not person_id:
            return Response(
                {"error": "Missing required field: person_id"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            person = Person.objects.get(id=person_id)
            remove_team_member(team, person)
            return Response({"status": "Member removed successfully"})
        except Person.DoesNotExist:
            return Response(
                {"error": f"Person with ID {person_id} not found"},
                status=status.HTTP_404_NOT_FOUND
            )
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )

```

#----------------------------------------------------------------------------------------------------

# core\views\template_view.py =====================================================

core\views\template_view.py:
```python
from rest_framework import viewsets, status
from rest_framework.response import Response
from rest_framework.decorators import action
from django.db import transaction
from core.models import PhaseTemplate, OutputTemplate, PPAPElement
from core.serializers.phase_template_serializer import PhaseTemplateSerializer
from core.serializers.output_template_serializer import OutputTemplateSerializer
from core.services.template.api import (
    initialize_phase_template,
    initialize_output_template,
    get_phase_templates_by_level,
    get_output_templates_by_phase,
    get_output_templates_by_element,
    clone_phase_template,
    clone_output_template
)

class PhaseTemplateViewSet(viewsets.ModelViewSet):
    queryset = PhaseTemplate.objects.all().order_by('order')
    serializer_class = PhaseTemplateSerializer
    
    @transaction.atomic
    def create(self, request, *args, **kwargs):
        # Extract template data
        name = request.data.get('name')
        description = request.data.get('description', '')
        order = request.data.get('order')
        ppap_levels = request.data.get('ppap_levels', [])
        
        # Validate required fields
        if not all([name, order is not None]):
            return Response(
                {"error": "Missing required fields: name, order"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            # Create template
            template = initialize_phase_template(
                name=name,
                description=description,
                order=order,
                ppap_levels=ppap_levels
            )
            
            serializer = self.get_serializer(template)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    @action(detail=False, methods=['get'])
    def by_level(self, request):
        level = request.query_params.get('level')
        
        if not level:
            return Response(
                {"error": "Missing required parameter: level"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            level = int(level)
            templates = get_phase_templates_by_level(level)
            serializer = self.get_serializer(templates, many=True)
            return Response(serializer.data)
        except ValueError:
            return Response(
                {"error": "Level must be an integer"},
                status=status.HTTP_400_BAD_REQUEST
            )
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    @action(detail=True, methods=['post'])
    def clone(self, request, pk=None):
        new_name = request.data.get('name')
        
        try:
            cloned_template = clone_phase_template(pk, new_name)
            serializer = self.get_serializer(cloned_template)
            return Response(serializer.data)
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )

class OutputTemplateViewSet(viewsets.ModelViewSet):
    queryset = OutputTemplate.objects.all()
    serializer_class = OutputTemplateSerializer
    
    @transaction.atomic
    def create(self, request, *args, **kwargs):
        # Extract template data
        name = request.data.get('name')
        phase_id = request.data.get('phase_id')
        ppap_element_id = request.data.get('ppap_element_id')
        configuration = request.data.get('configuration', {})
        
        # Validate required fields
        if not all([name, phase_id, ppap_element_id]):
            return Response(
                {"error": "Missing required fields: name, phase_id, ppap_element_id"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            # Get related objects
            phase_template = PhaseTemplate.objects.get(id=phase_id)
            ppap_element = PPAPElement.objects.get(id=ppap_element_id)
            
            # Create template
            template = initialize_output_template(
                name=name,
                phase_template=phase_template,
                ppap_element=ppap_element,
                configuration=configuration
            )
            
            serializer = self.get_serializer(template)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except PhaseTemplate.DoesNotExist:
            return Response(
                {"error": f"Phase template with ID {phase_id} not found"},
                status=status.HTTP_404_NOT_FOUND
            )
        except PPAPElement.DoesNotExist:
            return Response(
                {"error": f"PPAP element with ID {ppap_element_id} not found"},
                status=status.HTTP_404_NOT_FOUND
            )
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    @action(detail=False, methods=['get'])
    def by_phase(self, request):
        phase_id = request.query_params.get('phase_id')
        
        if not phase_id:
            return Response(
                {"error": "Missing required parameter: phase_id"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            templates = get_output_templates_by_phase(phase_id)
            serializer = self.get_serializer(templates, many=True)
            return Response(serializer.data)
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    @action(detail=False, methods=['get'])
    def by_element(self, request):
        element_id = request.query_params.get('element_id')
        
        if not element_id:
            return Response(
                {"error": "Missing required parameter: element_id"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            templates = get_output_templates_by_element(element_id)
            serializer = self.get_serializer(templates, many=True)
            return Response(serializer.data)
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    @action(detail=True, methods=['post'])
    def clone(self, request, pk=None):
        new_name = request.data.get('name')
        
        try:
            cloned_template = clone_output_template(pk, new_name)
            serializer = self.get_serializer(cloned_template)
            return Response(serializer.data)
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )

```

#----------------------------------------------------------------------------------------------------

# core\views\timeline_view.py =====================================================

core\views\timeline_view.py:
```python
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status
from core.services import timeline_api, logic_api
from rest_framework import viewsets
from rest_framework.decorators import action

class TimelineViewSet(viewsets.ViewSet):
    """
    ViewSet for timeline-related operations
    """
    
    @action(detail=False, methods=['post'])
    def set_project_timeline(self, request):
        """
        Set project timeline with deadline
        """
        user = request.user
        project_id = request.data.get('project_id')
        deadline_str = request.data.get('deadline')
        
        if not all([project_id, deadline_str]):
            return Response(
                {"error": "Missing required fields: project_id, deadline"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            # Parse deadline
            from datetime import datetime
            deadline = datetime.fromisoformat(deadline_str.replace('Z', '+00:00'))
            
            # Check authorization
            if not logic_api.check_user_authorization(user.id, 'update', 'project', project_id):
                return Response(
                    {"error": "Not authorized to set project timeline"},
                    status=status.HTTP_403_FORBIDDEN
                )
            
            # Set project timeline
            timeline_api.set_project_timeline(project_id, deadline)
            
            return Response({
                "success": True,
                "message": f"Project timeline set with deadline {deadline_str}"
            })
        except ValueError as e:
            return Response(
                {"error": f"Invalid deadline format: {str(e)}"},
                status=status.HTTP_400_BAD_REQUEST
            )
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )
    
    @action(detail=False, methods=['post'])
    def set_phase_timeline(self, request):
        """
        Set phase timeline with deadline
        """
        user = request.user
        phase_id = request.data.get('phase_id')
        deadline_str = request.data.get('deadline')
        
        if not all([phase_id, deadline_str]):
            return Response(
                {"error": "Missing required fields: phase_id, deadline"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            # Parse deadline
            from datetime import datetime
            deadline = datetime.fromisoformat(deadline_str.replace('Z', '+00:00'))
            
            # Check authorization
            if not logic_api.check_user_authorization(user.id, 'update', 'phase', phase_id):
                return Response(
                    {"error": "Not authorized to set phase timeline"},
                    status=status.HTTP_403_FORBIDDEN
                )
            
            # Set phase timeline
            timeline_api.set_phase_timeline(phase_id, deadline)
            
            return Response({
                "success": True,
                "message": f"Phase timeline set with deadline {deadline_str}"
            })
        except ValueError as e:
            return Response(
                {"error": f"Invalid deadline format: {str(e)}"},
                status=status.HTTP_400_BAD_REQUEST
            )
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )
    
    @action(detail=True, methods=['get'])
    def overview(self, request, pk=None):
        """
        Get timeline overview for a project
        """
        user = request.user
        project_id = pk
        
        try:
            # Check authorization
            if not logic_api.check_user_authorization(user.id, 'read', 'project', project_id):
                return Response(
                    {"error": "Not authorized to view project timeline"},
                    status=status.HTTP_403_FORBIDDEN
                )
            
            # Get timeline overview
            timeline = timeline_api.get_timeline_overview(project_id)
            
            return Response(timeline)
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

```

#----------------------------------------------------------------------------------------------------

# core\views\todo_view.py =========================================================

core\views\todo_view.py:
```python
from rest_framework import viewsets, status
from rest_framework.response import Response
from rest_framework.decorators import action
from django.db import transaction
from core.models import Todo, Person, Output
from core.serializers.todo_serializer import TodoSerializer
from core.services.todo.api import (
    initialize_todo,
    update_todo,
    delete_todo,
    get_todos_by_person,
    get_todos_by_output,
    get_todos_by_status,
    change_todo_status,
    reassign_todo
)

class TodoViewSet(viewsets.ModelViewSet):
    queryset = Todo.objects.all()
    serializer_class = TodoSerializer
    
    @transaction.atomic
    def create(self, request, *args, **kwargs):
        # Extract todo data
        title = request.data.get('title')
        description = request.data.get('description', '')
        assigned_to_id = request.data.get('assigned_to_id')
        output_id = request.data.get('output_id')
        priority = request.data.get('priority', 'medium')
        
        # Validate required fields
        if not all([title, assigned_to_id]):
            return Response(
                {"error": "Missing required fields: title, assigned_to_id"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            # Get assigned person
            assigned_to = Person.objects.get(id=assigned_to_id)
            
            # Get output if provided
            output = None
            if output_id:
                try:
                    output = Output.objects.get(id=output_id)
                except Output.DoesNotExist:
                    return Response(
                        {"error": f"Output with ID {output_id} not found"},
                        status=status.HTTP_404_NOT_FOUND
                    )
            
            # Create todo
            todo = initialize_todo(
                title=title,
                description=description,
                assigned_to=assigned_to,
                output=output,
                priority=priority
            )
            
            serializer = self.get_serializer(todo)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except Person.DoesNotExist:
            return Response(
                {"error": f"Person with ID {assigned_to_id} not found"},
                status=status.HTTP_404_NOT_FOUND
            )
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    @transaction.atomic
    def update(self, request, *args, **kwargs):
        todo = self.get_object()
        
        # Extract todo data
        title = request.data.get('title')
        description = request.data.get('description')
        priority = request.data.get('priority')
        
        try:
            # Update todo
            updated_todo = update_todo(
                todo=todo,
                title=title,
                description=description,
                priority=priority
            )
            
            serializer = self.get_serializer(updated_todo)
            return Response(serializer.data)
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    @action(detail=True, methods=['post'])
    def change_status(self, request, pk=None):
        todo = self.get_object()
        status_value = request.data.get('status')
        
        if not status_value:
            return Response(
                {"error": "Missing required field: status"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        valid_statuses = ['pending', 'in_progress', 'completed', 'cancelled']
        if status_value not in valid_statuses:
            return Response(
                {"error": f"Invalid status. Must be one of: {', '.join(valid_statuses)}"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            updated_todo = change_todo_status(todo, status_value)
            serializer = self.get_serializer(updated_todo)
            return Response(serializer.data)
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    @action(detail=True, methods=['post'])
    def reassign(self, request, pk=None):
        todo = self.get_object()
        person_id = request.data.get('person_id')
        
        if not person_id:
            return Response(
                {"error": "Missing required field: person_id"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            person = Person.objects.get(id=person_id)
            updated_todo = reassign_todo(todo, person)
            serializer = self.get_serializer(updated_todo)
            return Response(serializer.data)
        except Person.DoesNotExist:
            return Response(
                {"error": f"Person with ID {person_id} not found"},
                status=status.HTTP_404_NOT_FOUND
            )
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    @action(detail=False, methods=['get'])
    def by_person(self, request):
        person_id = request.query_params.get('person_id')
        
        if not person_id:
            return Response(
                {"error": "Missing required parameter: person_id"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            todos = get_todos_by_person(person_id)
            serializer = self.get_serializer(todos, many=True)
            return Response(serializer.data)
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    @action(detail=False, methods=['get'])
    def by_output(self, request):
        output_id = request.query_params.get('output_id')
        
        if not output_id:
            return Response(
                {"error": "Missing required parameter: output_id"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            todos = get_todos_by_output(output_id)
            serializer = self.get_serializer(todos, many=True)
            return Response(serializer.data)
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    @action(detail=False, methods=['get'])
    def by_status(self, request):
        status_value = request.query_params.get('status')
        
        if not status_value:
            return Response(
                {"error": "Missing required parameter: status"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            todos = get_todos_by_status(status_value)
            serializer = self.get_serializer(todos, many=True)
            return Response(serializer.data)
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )

```

#----------------------------------------------------------------------------------------------------

# core\views\user_view.py =========================================================

core\views\user_view.py:
```python
from rest_framework import viewsets, status
from rest_framework.response import Response
from django.db import transaction
from core.models import User, Person, Contact
from core.serializers.user_serializer import UserSerializer
from core.services.history.user import record_user_creation  # Add this
from core.services.history.initialization import initialize_history  # You can keep this if used elsewhere

class UserViewSet(viewsets.ModelViewSet):
    queryset = User.objects.all()
    serializer_class = UserSerializer
    
    @transaction.atomic
    def create(self, request, *args, **kwargs):
        # Extract user data
        username = request.data.get('username')
        password = request.data.get('password')
        person_id = request.data.get('person_id')
        authorization_id = request.data.get('authorization_id')
        is_active = request.data.get('is_active', True)
        is_staff = request.data.get('is_staff', False)
        is_superuser = request.data.get('is_superuser', False)
        
        # For creating a new person if needed
        first_name = request.data.get('first_name')
        last_name = request.data.get('last_name')
        email = request.data.get('email')
        department_id = request.data.get('department_id')
        
        # Validate required fields for user
        if not all([username, password, authorization_id]):
            return Response(
                {"error": "Missing required fields: username, password, authorization_id"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # If person_id is not provided, validate person creation fields
        if not person_id and not all([first_name, last_name]):
            return Response(
                {"error": "Either an existing person_id or first_name and last_name must be provided"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            # Get or create person
            if person_id:
                try:
                    person = Person.objects.get(id=person_id)
                    
                    # Check if person is already a user
                    if hasattr(person, 'user'):
                        return Response(
                            {"error": "This person is already associated with a user"},
                            status=status.HTTP_400_BAD_REQUEST
                        )
                    
                    # Mark the person as a user
                    person.is_user = True
                    person.save(update_fields=['is_user'])
                    
                except Person.DoesNotExist:
                    return Response(
                        {"error": f"Person with ID {person_id} not found"},
                        status=status.HTTP_404_NOT_FOUND
                    )
            else:
                # Create a new person
                person = Person.objects.create(
                    first_name=first_name,
                    last_name=last_name,
                    department_id=department_id,
                    is_user=True
                )
            
            # Ensure contact exists for the person
            try:
                contact = Contact.objects.get(id=person.contact_id)
                
                # Update email if provided and different
                if email and email != contact.email:
                    contact.email = email
                    contact.save(update_fields=['email'])
                    
            except Contact.DoesNotExist:
                # Create contact if it doesn't exist
                Contact.objects.create(
                    id=person.contact_id,
                    email=email or "",
                    address="",
                    phone="",
                    type="user"
                )
            
            # Create user
            user = User.objects.create_user(
                username=username,
                password=password,
                person=person,
                authorization_id=authorization_id,
                is_active=is_active,
                is_staff=is_staff,
                is_superuser=is_superuser
            )
            
            # Record in history
            record_user_creation(user)
            
            serializer = self.get_serializer(user)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    @transaction.atomic
    def update(self, request, *args, **kwargs):
        user = self.get_object()
        
        # Extract base user fields
        username = request.data.get('username', user.username)
        authorization_id = request.data.get('authorization_id')
        is_active = request.data.get('is_active', user.is_active)
        is_staff = request.data.get('is_staff', user.is_staff)
        is_superuser = request.data.get('is_superuser', user.is_superuser)
        
        # Extract person data if provided
        person_data = request.data.get('person_data', {})
        
        try:
            # Track what fields are updated
            user_updated_fields = []
            person_updated_fields = []
            
            # Update user fields
            if username != user.username:
                old_username = user.username
                user.username = username
                user_updated_fields.append('username')
                
            if is_active != user.is_active:
                user.is_active = is_active
                user_updated_fields.append('is_active')
                
            if is_staff != user.is_staff:
                user.is_staff = is_staff
                user_updated_fields.append('is_staff')
                
            if is_superuser != user.is_superuser:
                user.is_superuser = is_superuser
                user_updated_fields.append('is_superuser')
            
            # Update authorization if provided
            if authorization_id and authorization_id != user.authorization_id:
                try:
                    from core.models import Authorization
                    old_auth_id = user.authorization_id
                    authorization = Authorization.objects.get(id=authorization_id)
                    user.authorization = authorization
                    user_updated_fields.append('authorization')
                except Authorization.DoesNotExist:
                    return Response(
                        {"error": f"Authorization with ID {authorization_id} not found"},
                        status=status.HTTP_404_NOT_FOUND
                    )
            
            # Save user changes if any fields were updated
            if user_updated_fields:
                user.save()
                
                # Record user update in history
                from core.services.history.user import record_user_update
                record_user_update(user, user_updated_fields)
                
                # If username changed, record that specifically
                if 'username' in user_updated_fields:
                    from core.services.history.user import record_user_name_change
                    record_user_name_change(user, old_username, username)
            
            # Update password if provided
            if 'password' in request.data:
                user.set_password(request.data['password'])
                user.save(update_fields=['password'])
                
                # Record password change in history
                from core.services.history.user import record_user_password_change
                record_user_password_change(user)
            
            # Update person data if provided
            if person_data:
                person = user.person
                old_first_name = person.first_name
                old_last_name = person.last_name
                name_changed = False
                
                # Update person fields if provided
                if 'first_name' in person_data and person_data['first_name'] != person.first_name:
                    person.first_name = person_data['first_name']
                    person_updated_fields.append('first_name')
                    name_changed = True
                    
                if 'last_name' in person_data and person_data['last_name'] != person.last_name:
                    person.last_name = person_data['last_name']
                    person_updated_fields.append('last_name')
                    name_changed = True
                
                # Update department if provided
                if 'department_id' in person_data:
                    department_id = person_data['department_id']
                    old_department_id = person.department.id if person.department else None
                    
                    if str(department_id) != str(old_department_id):
                        if department_id:
                            try:
                                from core.models import Department
                                department = Department.objects.get(id=department_id)
                                person.department = department
                                person_updated_fields.append('department')
                                
                                # Record department change
                                from core.services.history.person import record_person_department_change
                                record_person_department_change(person, old_department_id, department_id)
                            except Department.DoesNotExist:
                                return Response(
                                    {"error": f"Department with ID {department_id} not found"},
                                    status=status.HTTP_404_NOT_FOUND
                                )
                        else:
                            person.department = None
                            person_updated_fields.append('department')
                            
                            # Record department change
                            from core.services.history.person import record_person_department_change
                            record_person_department_change(person, old_department_id, None)
                
                # Save person changes if any fields were updated
                if person_updated_fields:
                    person.save()
                    
                    # Record person update in history
                    from core.services.history.person import record_person_update
                    record_person_update(person, person_updated_fields)
                    
                    # If name changed, record that specifically
                    if name_changed:
                        from core.services.history.person import record_person_name_change
                        record_person_name_change(
                            person, 
                            old_first_name, old_last_name, 
                            person.first_name, person.last_name
                        )
                
                # Update contact if email provided
                if 'email' in person_data:
                    try:
                        contact = Contact.objects.get(id=person.contact_id)
                        old_email = contact.email
                        new_email = person_data['email']
                        
                        if old_email != new_email:
                            contact.email = new_email
                            contact.save(update_fields=['email'])
                            
                            # Record email change
                            from core.services.history.contact import record_contact_email_change
                            record_contact_email_change(contact, old_email, new_email)
                    except Contact.DoesNotExist:
                        # Create contact if it doesn't exist
                        Contact.objects.create(
                            id=person.contact_id,
                            email=person_data['email'],
                            type='user'
                        )
            
            # Return updated user data
            serializer = self.get_serializer(user)
            return Response(serializer.data)
        except Exception as e:
            import traceback
            print(traceback.format_exc())  # Log the full error
            return Response(
                {"error": str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )

```

#----------------------------------------------------------------------------------------------------

